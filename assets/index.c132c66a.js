const Th=function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const o of i)if(o.type==="childList")for(const r of o.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&n(r)}).observe(document,{childList:!0,subtree:!0});function a(i){const o={};return i.integrity&&(o.integrity=i.integrity),i.referrerpolicy&&(o.referrerPolicy=i.referrerpolicy),i.crossorigin==="use-credentials"?o.credentials="include":i.crossorigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function n(i){if(i.ep)return;i.ep=!0;const o=a(i);fetch(i.href,o)}};Th();function _r(e,t){const a=Object.create(null),n=e.split(",");for(let i=0;i<n.length;i++)a[n[i]]=!0;return t?i=>!!a[i.toLowerCase()]:i=>!!a[i]}const jh="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",Ph=_r(jh);function Ql(e){return!!e||e===""}function $i(e){if(ie(e)){const t={};for(let a=0;a<e.length;a++){const n=e[a],i=Ve(n)?Mh(n):$i(n);if(i)for(const o in i)t[o]=i[o]}return t}else{if(Ve(e))return e;if(De(e))return e}}const Ih=/;(?![^(]*\))/g,Ah=/:(.+)/;function Mh(e){const t={};return e.split(Ih).forEach(a=>{if(a){const n=a.split(Ah);n.length>1&&(t[n[0].trim()]=n[1].trim())}}),t}function Ui(e){let t="";if(Ve(e))t=e;else if(ie(e))for(let a=0;a<e.length;a++){const n=Ui(e[a]);n&&(t+=n+" ")}else if(De(e))for(const a in e)e[a]&&(t+=a+" ");return t.trim()}function Jh(e,t){if(e.length!==t.length)return!1;let a=!0;for(let n=0;a&&n<e.length;n++)a=Ma(e[n],t[n]);return a}function Ma(e,t){if(e===t)return!0;let a=Ss(e),n=Ss(t);if(a||n)return a&&n?e.getTime()===t.getTime():!1;if(a=Dn(e),n=Dn(t),a||n)return e===t;if(a=ie(e),n=ie(t),a||n)return a&&n?Jh(e,t):!1;if(a=De(e),n=De(t),a||n){if(!a||!n)return!1;const i=Object.keys(e).length,o=Object.keys(t).length;if(i!==o)return!1;for(const r in e){const s=e.hasOwnProperty(r),l=t.hasOwnProperty(r);if(s&&!l||!s&&l||!Ma(e[r],t[r]))return!1}}return String(e)===String(t)}function Tr(e,t){return e.findIndex(a=>Ma(a,t))}const Lh=e=>Ve(e)?e:e==null?"":ie(e)||De(e)&&(e.toString===tc||!ue(e.toString))?JSON.stringify(e,Zl,2):String(e),Zl=(e,t)=>t&&t.__v_isRef?Zl(e,t.value):Xa(t)?{[`Map(${t.size})`]:[...t.entries()].reduce((a,[n,i])=>(a[`${n} =>`]=i,a),{})}:nn(t)?{[`Set(${t.size})`]:[...t.values()]}:De(t)&&!ie(t)&&!ac(t)?String(t):t,_e={},Ya=[],jt=()=>{},Dh=()=>!1,Eh=/^on[^a-z]/,Wi=e=>Eh.test(e),jr=e=>e.startsWith("onUpdate:"),$e=Object.assign,Pr=(e,t)=>{const a=e.indexOf(t);a>-1&&e.splice(a,1)},Bh=Object.prototype.hasOwnProperty,be=(e,t)=>Bh.call(e,t),ie=Array.isArray,Xa=e=>Xn(e)==="[object Map]",nn=e=>Xn(e)==="[object Set]",Ss=e=>Xn(e)==="[object Date]",ue=e=>typeof e=="function",Ve=e=>typeof e=="string",Dn=e=>typeof e=="symbol",De=e=>e!==null&&typeof e=="object",ec=e=>De(e)&&ue(e.then)&&ue(e.catch),tc=Object.prototype.toString,Xn=e=>tc.call(e),Fh=e=>Xn(e).slice(8,-1),ac=e=>Xn(e)==="[object Object]",Ir=e=>Ve(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,ki=_r(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),qi=e=>{const t=Object.create(null);return a=>t[a]||(t[a]=e(a))},Rh=/-(\w)/g,bt=qi(e=>e.replace(Rh,(t,a)=>a?a.toUpperCase():"")),Vh=/\B([A-Z])/g,on=qi(e=>e.replace(Vh,"-$1").toLowerCase()),ha=qi(e=>e.charAt(0).toUpperCase()+e.slice(1)),xi=qi(e=>e?`on${ha(e)}`:""),En=(e,t)=>!Object.is(e,t),Ci=(e,t)=>{for(let a=0;a<e.length;a++)e[a](t)},Pi=(e,t,a)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,value:a})},Bn=e=>{const t=parseFloat(e);return isNaN(t)?e:t};let _s;const zh=()=>_s||(_s=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});let ft;class nc{constructor(t=!1){this.active=!0,this.effects=[],this.cleanups=[],!t&&ft&&(this.parent=ft,this.index=(ft.scopes||(ft.scopes=[])).push(this)-1)}run(t){if(this.active){const a=ft;try{return ft=this,t()}finally{ft=a}}}on(){ft=this}off(){ft=this.parent}stop(t){if(this.active){let a,n;for(a=0,n=this.effects.length;a<n;a++)this.effects[a].stop();for(a=0,n=this.cleanups.length;a<n;a++)this.cleanups[a]();if(this.scopes)for(a=0,n=this.scopes.length;a<n;a++)this.scopes[a].stop(!0);if(this.parent&&!t){const i=this.parent.scopes.pop();i&&i!==this&&(this.parent.scopes[this.index]=i,i.index=this.index)}this.active=!1}}}function Qn(e){return new nc(e)}function Hh(e,t=ft){t&&t.active&&t.effects.push(e)}function La(e){ft&&ft.cleanups.push(e)}const Ar=e=>{const t=new Set(e);return t.w=0,t.n=0,t},ic=e=>(e.w&la)>0,oc=e=>(e.n&la)>0,Oh=({deps:e})=>{if(e.length)for(let t=0;t<e.length;t++)e[t].w|=la},Gh=e=>{const{deps:t}=e;if(t.length){let a=0;for(let n=0;n<t.length;n++){const i=t[n];ic(i)&&!oc(i)?i.delete(e):t[a++]=i,i.w&=~la,i.n&=~la}t.length=a}},Bo=new WeakMap;let Sn=0,la=1;const Fo=30;let St;const Pa=Symbol(""),Ro=Symbol("");class Mr{constructor(t,a=null,n){this.fn=t,this.scheduler=a,this.active=!0,this.deps=[],this.parent=void 0,Hh(this,n)}run(){if(!this.active)return this.fn();let t=St,a=ra;for(;t;){if(t===this)return;t=t.parent}try{return this.parent=St,St=this,ra=!0,la=1<<++Sn,Sn<=Fo?Oh(this):Ts(this),this.fn()}finally{Sn<=Fo&&Gh(this),la=1<<--Sn,St=this.parent,ra=a,this.parent=void 0,this.deferStop&&this.stop()}}stop(){St===this?this.deferStop=!0:this.active&&(Ts(this),this.onStop&&this.onStop(),this.active=!1)}}function Ts(e){const{deps:t}=e;if(t.length){for(let a=0;a<t.length;a++)t[a].delete(e);t.length=0}}let ra=!0;const rc=[];function Da(){rc.push(ra),ra=!1}function Ea(){const e=rc.pop();ra=e===void 0?!0:e}function st(e,t,a){if(ra&&St){let n=Bo.get(e);n||Bo.set(e,n=new Map);let i=n.get(a);i||n.set(a,i=Ar()),sc(i)}}function sc(e,t){let a=!1;Sn<=Fo?oc(e)||(e.n|=la,a=!ic(e)):a=!e.has(St),a&&(e.add(St),St.deps.push(e))}function Gt(e,t,a,n,i,o){const r=Bo.get(e);if(!r)return;let s=[];if(t==="clear")s=[...r.values()];else if(a==="length"&&ie(e))r.forEach((l,c)=>{(c==="length"||c>=n)&&s.push(l)});else switch(a!==void 0&&s.push(r.get(a)),t){case"add":ie(e)?Ir(a)&&s.push(r.get("length")):(s.push(r.get(Pa)),Xa(e)&&s.push(r.get(Ro)));break;case"delete":ie(e)||(s.push(r.get(Pa)),Xa(e)&&s.push(r.get(Ro)));break;case"set":Xa(e)&&s.push(r.get(Pa));break}if(s.length===1)s[0]&&Vo(s[0]);else{const l=[];for(const c of s)c&&l.push(...c);Vo(Ar(l))}}function Vo(e,t){const a=ie(e)?e:[...e];for(const n of a)n.computed&&js(n);for(const n of a)n.computed||js(n)}function js(e,t){(e!==St||e.allowRecurse)&&(e.scheduler?e.scheduler():e.run())}const Nh=_r("__proto__,__v_isRef,__isVue"),lc=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(Dn)),$h=Jr(),Uh=Jr(!1,!0),Wh=Jr(!0),Ps=qh();function qh(){const e={};return["includes","indexOf","lastIndexOf"].forEach(t=>{e[t]=function(...a){const n=ge(this);for(let o=0,r=this.length;o<r;o++)st(n,"get",o+"");const i=n[t](...a);return i===-1||i===!1?n[t](...a.map(ge)):i}}),["push","pop","shift","unshift","splice"].forEach(t=>{e[t]=function(...a){Da();const n=ge(this)[t].apply(this,a);return Ea(),n}}),e}function Jr(e=!1,t=!1){return function(n,i,o){if(i==="__v_isReactive")return!e;if(i==="__v_isReadonly")return e;if(i==="__v_isShallow")return t;if(i==="__v_raw"&&o===(e?t?um:mc:t?hc:dc).get(n))return n;const r=ie(n);if(!e&&r&&be(Ps,i))return Reflect.get(Ps,i,o);const s=Reflect.get(n,i,o);return(Dn(i)?lc.has(i):Nh(i))||(e||st(n,"get",i),t)?s:Ae(s)?r&&Ir(i)?s:s.value:De(s)?e?Zn(s):tt(s):s}}const Kh=cc(),Yh=cc(!0);function cc(e=!1){return function(a,n,i,o){let r=a[n];if(Fn(r)&&Ae(r)&&!Ae(i))return!1;if(!e&&!Fn(i)&&(zo(i)||(i=ge(i),r=ge(r)),!ie(a)&&Ae(r)&&!Ae(i)))return r.value=i,!0;const s=ie(a)&&Ir(n)?Number(n)<a.length:be(a,n),l=Reflect.set(a,n,i,o);return a===ge(o)&&(s?En(i,r)&&Gt(a,"set",n,i):Gt(a,"add",n,i)),l}}function Xh(e,t){const a=be(e,t);e[t];const n=Reflect.deleteProperty(e,t);return n&&a&&Gt(e,"delete",t,void 0),n}function Qh(e,t){const a=Reflect.has(e,t);return(!Dn(t)||!lc.has(t))&&st(e,"has",t),a}function Zh(e){return st(e,"iterate",ie(e)?"length":Pa),Reflect.ownKeys(e)}const uc={get:$h,set:Kh,deleteProperty:Xh,has:Qh,ownKeys:Zh},em={get:Wh,set(e,t){return!0},deleteProperty(e,t){return!0}},tm=$e({},uc,{get:Uh,set:Yh}),Lr=e=>e,Ki=e=>Reflect.getPrototypeOf(e);function ci(e,t,a=!1,n=!1){e=e.__v_raw;const i=ge(e),o=ge(t);a||(t!==o&&st(i,"get",t),st(i,"get",o));const{has:r}=Ki(i),s=n?Lr:a?Br:Rn;if(r.call(i,t))return s(e.get(t));if(r.call(i,o))return s(e.get(o));e!==i&&e.get(t)}function ui(e,t=!1){const a=this.__v_raw,n=ge(a),i=ge(e);return t||(e!==i&&st(n,"has",e),st(n,"has",i)),e===i?a.has(e):a.has(e)||a.has(i)}function di(e,t=!1){return e=e.__v_raw,!t&&st(ge(e),"iterate",Pa),Reflect.get(e,"size",e)}function Is(e){e=ge(e);const t=ge(this);return Ki(t).has.call(t,e)||(t.add(e),Gt(t,"add",e,e)),this}function As(e,t){t=ge(t);const a=ge(this),{has:n,get:i}=Ki(a);let o=n.call(a,e);o||(e=ge(e),o=n.call(a,e));const r=i.call(a,e);return a.set(e,t),o?En(t,r)&&Gt(a,"set",e,t):Gt(a,"add",e,t),this}function Ms(e){const t=ge(this),{has:a,get:n}=Ki(t);let i=a.call(t,e);i||(e=ge(e),i=a.call(t,e)),n&&n.call(t,e);const o=t.delete(e);return i&&Gt(t,"delete",e,void 0),o}function Js(){const e=ge(this),t=e.size!==0,a=e.clear();return t&&Gt(e,"clear",void 0,void 0),a}function hi(e,t){return function(n,i){const o=this,r=o.__v_raw,s=ge(r),l=t?Lr:e?Br:Rn;return!e&&st(s,"iterate",Pa),r.forEach((c,u)=>n.call(i,l(c),l(u),o))}}function mi(e,t,a){return function(...n){const i=this.__v_raw,o=ge(i),r=Xa(o),s=e==="entries"||e===Symbol.iterator&&r,l=e==="keys"&&r,c=i[e](...n),u=a?Lr:t?Br:Rn;return!t&&st(o,"iterate",l?Ro:Pa),{next(){const{value:h,done:m}=c.next();return m?{value:h,done:m}:{value:s?[u(h[0]),u(h[1])]:u(h),done:m}},[Symbol.iterator](){return this}}}}function ea(e){return function(...t){return e==="delete"?!1:this}}function am(){const e={get(o){return ci(this,o)},get size(){return di(this)},has:ui,add:Is,set:As,delete:Ms,clear:Js,forEach:hi(!1,!1)},t={get(o){return ci(this,o,!1,!0)},get size(){return di(this)},has:ui,add:Is,set:As,delete:Ms,clear:Js,forEach:hi(!1,!0)},a={get(o){return ci(this,o,!0)},get size(){return di(this,!0)},has(o){return ui.call(this,o,!0)},add:ea("add"),set:ea("set"),delete:ea("delete"),clear:ea("clear"),forEach:hi(!0,!1)},n={get(o){return ci(this,o,!0,!0)},get size(){return di(this,!0)},has(o){return ui.call(this,o,!0)},add:ea("add"),set:ea("set"),delete:ea("delete"),clear:ea("clear"),forEach:hi(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(o=>{e[o]=mi(o,!1,!1),a[o]=mi(o,!0,!1),t[o]=mi(o,!1,!0),n[o]=mi(o,!0,!0)}),[e,a,t,n]}const[nm,im,om,rm]=am();function Dr(e,t){const a=t?e?rm:om:e?im:nm;return(n,i,o)=>i==="__v_isReactive"?!e:i==="__v_isReadonly"?e:i==="__v_raw"?n:Reflect.get(be(a,i)&&i in n?a:n,i,o)}const sm={get:Dr(!1,!1)},lm={get:Dr(!1,!0)},cm={get:Dr(!0,!1)},dc=new WeakMap,hc=new WeakMap,mc=new WeakMap,um=new WeakMap;function dm(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function hm(e){return e.__v_skip||!Object.isExtensible(e)?0:dm(Fh(e))}function tt(e){return Fn(e)?e:Er(e,!1,uc,sm,dc)}function fc(e){return Er(e,!1,tm,lm,hc)}function Zn(e){return Er(e,!0,em,cm,mc)}function Er(e,t,a,n,i){if(!De(e)||e.__v_raw&&!(t&&e.__v_isReactive))return e;const o=i.get(e);if(o)return o;const r=hm(e);if(r===0)return e;const s=new Proxy(e,r===2?n:a);return i.set(e,s),s}function Qa(e){return Fn(e)?Qa(e.__v_raw):!!(e&&e.__v_isReactive)}function Fn(e){return!!(e&&e.__v_isReadonly)}function zo(e){return!!(e&&e.__v_isShallow)}function pc(e){return Qa(e)||Fn(e)}function ge(e){const t=e&&e.__v_raw;return t?ge(t):e}function gc(e){return Pi(e,"__v_skip",!0),e}const Rn=e=>De(e)?tt(e):e,Br=e=>De(e)?Zn(e):e;function vc(e){ra&&St&&(e=ge(e),sc(e.dep||(e.dep=Ar())))}function bc(e,t){e=ge(e),e.dep&&Vo(e.dep)}function Ae(e){return!!(e&&e.__v_isRef===!0)}function D(e){return yc(e,!1)}function mm(e){return yc(e,!0)}function yc(e,t){return Ae(e)?e:new fm(e,t)}class fm{constructor(t,a){this.__v_isShallow=a,this.dep=void 0,this.__v_isRef=!0,this._rawValue=a?t:ge(t),this._value=a?t:Rn(t)}get value(){return vc(this),this._value}set value(t){t=this.__v_isShallow?t:ge(t),En(t,this._rawValue)&&(this._rawValue=t,this._value=this.__v_isShallow?t:Rn(t),bc(this))}}function sa(e){return Ae(e)?e.value:e}const pm={get:(e,t,a)=>sa(Reflect.get(e,t,a)),set:(e,t,a,n)=>{const i=e[t];return Ae(i)&&!Ae(a)?(i.value=a,!0):Reflect.set(e,t,a,n)}};function wc(e){return Qa(e)?e:new Proxy(e,pm)}function Fr(e){const t=ie(e)?new Array(e.length):{};for(const a in e)t[a]=z(e,a);return t}class gm{constructor(t,a,n){this._object=t,this._key=a,this._defaultValue=n,this.__v_isRef=!0}get value(){const t=this._object[this._key];return t===void 0?this._defaultValue:t}set value(t){this._object[this._key]=t}}function z(e,t,a){const n=e[t];return Ae(n)?n:new gm(e,t,a)}class vm{constructor(t,a,n,i){this._setter=a,this.dep=void 0,this.__v_isRef=!0,this._dirty=!0,this.effect=new Mr(t,()=>{this._dirty||(this._dirty=!0,bc(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!i,this.__v_isReadonly=n}get value(){const t=ge(this);return vc(t),(t._dirty||!t._cacheable)&&(t._dirty=!1,t._value=t.effect.run()),t._value}set value(t){this._setter(t)}}function bm(e,t,a=!1){let n,i;const o=ue(e);return o?(n=e,i=jt):(n=e.get,i=e.set),new vm(n,i,o||!i,a)}const jn=[];function ym(e,...t){Da();const a=jn.length?jn[jn.length-1].component:null,n=a&&a.appContext.config.warnHandler,i=wm();if(n)Ht(n,a,11,[e+t.join(""),a&&a.proxy,i.map(({vnode:o})=>`at <${tu(a,o.type)}>`).join(`
`),i]);else{const o=[`[Vue warn]: ${e}`,...t];i.length&&o.push(`
`,...km(i)),console.warn(...o)}Ea()}function wm(){let e=jn[jn.length-1];if(!e)return[];const t=[];for(;e;){const a=t[0];a&&a.vnode===e?a.recurseCount++:t.push({vnode:e,recurseCount:0});const n=e.component&&e.component.parent;e=n&&n.vnode}return t}function km(e){const t=[];return e.forEach((a,n)=>{t.push(...n===0?[]:[`
`],...xm(a))}),t}function xm({vnode:e,recurseCount:t}){const a=t>0?`... (${t} recursive calls)`:"",n=e.component?e.component.parent==null:!1,i=` at <${tu(e.component,e.type,n)}`,o=">"+a;return e.props?[i,...Cm(e.props),o]:[i+o]}function Cm(e){const t=[],a=Object.keys(e);return a.slice(0,3).forEach(n=>{t.push(...kc(n,e[n]))}),a.length>3&&t.push(" ..."),t}function kc(e,t,a){return Ve(t)?(t=JSON.stringify(t),a?t:[`${e}=${t}`]):typeof t=="number"||typeof t=="boolean"||t==null?a?t:[`${e}=${t}`]:Ae(t)?(t=kc(e,ge(t.value),!0),a?t:[`${e}=Ref<`,t,">"]):ue(t)?[`${e}=fn${t.name?`<${t.name}>`:""}`]:(t=ge(t),a?t:[`${e}=`,t])}function Ht(e,t,a,n){let i;try{i=n?e(...n):e()}catch(o){Yi(o,t,a)}return i}function gt(e,t,a,n){if(ue(e)){const o=Ht(e,t,a,n);return o&&ec(o)&&o.catch(r=>{Yi(r,t,a)}),o}const i=[];for(let o=0;o<e.length;o++)i.push(gt(e[o],t,a,n));return i}function Yi(e,t,a,n=!0){const i=t?t.vnode:null;if(t){let o=t.parent;const r=t.proxy,s=a;for(;o;){const c=o.ec;if(c){for(let u=0;u<c.length;u++)if(c[u](e,r,s)===!1)return}o=o.parent}const l=t.appContext.config.errorHandler;if(l){Ht(l,null,10,[e,r,s]);return}}Sm(e,a,i,n)}function Sm(e,t,a,n=!0){console.error(e)}let Ii=!1,Ho=!1;const it=[];let Vt=0;const Pn=[];let _n=null,Wa=0;const In=[];let aa=null,qa=0;const xc=Promise.resolve();let Rr=null,Oo=null;function Ee(e){const t=Rr||xc;return e?t.then(this?e.bind(this):e):t}function _m(e){let t=Vt+1,a=it.length;for(;t<a;){const n=t+a>>>1;Vn(it[n])<e?t=n+1:a=n}return t}function Cc(e){(!it.length||!it.includes(e,Ii&&e.allowRecurse?Vt+1:Vt))&&e!==Oo&&(e.id==null?it.push(e):it.splice(_m(e.id),0,e),Sc())}function Sc(){!Ii&&!Ho&&(Ho=!0,Rr=xc.then(jc))}function Tm(e){const t=it.indexOf(e);t>Vt&&it.splice(t,1)}function _c(e,t,a,n){ie(e)?a.push(...e):(!t||!t.includes(e,e.allowRecurse?n+1:n))&&a.push(e),Sc()}function jm(e){_c(e,_n,Pn,Wa)}function Pm(e){_c(e,aa,In,qa)}function Xi(e,t=null){if(Pn.length){for(Oo=t,_n=[...new Set(Pn)],Pn.length=0,Wa=0;Wa<_n.length;Wa++)_n[Wa]();_n=null,Wa=0,Oo=null,Xi(e,t)}}function Tc(e){if(Xi(),In.length){const t=[...new Set(In)];if(In.length=0,aa){aa.push(...t);return}for(aa=t,aa.sort((a,n)=>Vn(a)-Vn(n)),qa=0;qa<aa.length;qa++)aa[qa]();aa=null,qa=0}}const Vn=e=>e.id==null?1/0:e.id;function jc(e){Ho=!1,Ii=!0,Xi(e),it.sort((a,n)=>Vn(a)-Vn(n));const t=jt;try{for(Vt=0;Vt<it.length;Vt++){const a=it[Vt];a&&a.active!==!1&&Ht(a,null,14)}}finally{Vt=0,it.length=0,Tc(),Ii=!1,Rr=null,(it.length||Pn.length||In.length)&&jc(e)}}function Im(e,t,...a){if(e.isUnmounted)return;const n=e.vnode.props||_e;let i=a;const o=t.startsWith("update:"),r=o&&t.slice(7);if(r&&r in n){const u=`${r==="modelValue"?"model":r}Modifiers`,{number:h,trim:m}=n[u]||_e;m&&(i=a.map(f=>f.trim())),h&&(i=a.map(Bn))}let s,l=n[s=xi(t)]||n[s=xi(bt(t))];!l&&o&&(l=n[s=xi(on(t))]),l&&gt(l,e,6,i);const c=n[s+"Once"];if(c){if(!e.emitted)e.emitted={};else if(e.emitted[s])return;e.emitted[s]=!0,gt(c,e,6,i)}}function Pc(e,t,a=!1){const n=t.emitsCache,i=n.get(e);if(i!==void 0)return i;const o=e.emits;let r={},s=!1;if(!ue(e)){const l=c=>{const u=Pc(c,t,!0);u&&(s=!0,$e(r,u))};!a&&t.mixins.length&&t.mixins.forEach(l),e.extends&&l(e.extends),e.mixins&&e.mixins.forEach(l)}return!o&&!s?(n.set(e,null),null):(ie(o)?o.forEach(l=>r[l]=null):$e(r,o),n.set(e,r),r)}function Qi(e,t){return!e||!Wi(t)?!1:(t=t.slice(2).replace(/Once$/,""),be(e,t[0].toLowerCase()+t.slice(1))||be(e,on(t))||be(e,t))}let pt=null,Zi=null;function Ai(e){const t=pt;return pt=e,Zi=e&&e.type.__scopeId||null,t}function Am(e){Zi=e}function Mm(){Zi=null}function na(e,t=pt,a){if(!t||e._n)return e;const n=(...i)=>{n._d&&Us(-1);const o=Ai(t),r=e(...i);return Ai(o),n._d&&Us(1),r};return n._n=!0,n._c=!0,n._d=!0,n}function Co(e){const{type:t,vnode:a,proxy:n,withProxy:i,props:o,propsOptions:[r],slots:s,attrs:l,emit:c,render:u,renderCache:h,data:m,setupState:f,ctx:p,inheritAttrs:b}=e;let w,v;const S=Ai(e);try{if(a.shapeFlag&4){const P=i||n;w=Mt(u.call(P,P,h,o,f,m,p)),v=l}else{const P=t;w=Mt(P.length>1?P(o,{attrs:l,slots:s,emit:c}):P(o,null)),v=t.props?l:Jm(l)}}catch(P){Mn.length=0,Yi(P,e,1),w=d(Ot)}let k=w;if(v&&b!==!1){const P=Object.keys(v),{shapeFlag:j}=k;P.length&&j&7&&(r&&P.some(jr)&&(v=Lm(v,r)),k=ca(k,v))}return a.dirs&&(k=ca(k),k.dirs=k.dirs?k.dirs.concat(a.dirs):a.dirs),a.transition&&(k.transition=a.transition),w=k,Ai(S),w}const Jm=e=>{let t;for(const a in e)(a==="class"||a==="style"||Wi(a))&&((t||(t={}))[a]=e[a]);return t},Lm=(e,t)=>{const a={};for(const n in e)(!jr(n)||!(n.slice(9)in t))&&(a[n]=e[n]);return a};function Dm(e,t,a){const{props:n,children:i,component:o}=e,{props:r,children:s,patchFlag:l}=t,c=o.emitsOptions;if(t.dirs||t.transition)return!0;if(a&&l>=0){if(l&1024)return!0;if(l&16)return n?Ls(n,r,c):!!r;if(l&8){const u=t.dynamicProps;for(let h=0;h<u.length;h++){const m=u[h];if(r[m]!==n[m]&&!Qi(c,m))return!0}}}else return(i||s)&&(!s||!s.$stable)?!0:n===r?!1:n?r?Ls(n,r,c):!0:!!r;return!1}function Ls(e,t,a){const n=Object.keys(t);if(n.length!==Object.keys(e).length)return!0;for(let i=0;i<n.length;i++){const o=n[i];if(t[o]!==e[o]&&!Qi(a,o))return!0}return!1}function Em({vnode:e,parent:t},a){for(;t&&t.subTree===e;)(e=t.vnode).el=a,t=t.parent}const Bm=e=>e.__isSuspense;function Fm(e,t){t&&t.pendingBranch?ie(e)?t.effects.push(...e):t.effects.push(e):Pm(e)}function Oe(e,t){if(Ne){let a=Ne.provides;const n=Ne.parent&&Ne.parent.provides;n===a&&(a=Ne.provides=Object.create(n)),a[e]=t}}function we(e,t,a=!1){const n=Ne||pt;if(n){const i=n.parent==null?n.vnode.appContext&&n.vnode.appContext.provides:n.parent.provides;if(i&&e in i)return i[e];if(arguments.length>1)return a&&ue(t)?t.call(n.proxy):t}}function $t(e,t){return Vr(e,null,t)}const Ds={};function re(e,t,a){return Vr(e,t,a)}function Vr(e,t,{immediate:a,deep:n,flush:i,onTrack:o,onTrigger:r}=_e){const s=Ne;let l,c=!1,u=!1;if(Ae(e)?(l=()=>e.value,c=zo(e)):Qa(e)?(l=()=>e,n=!0):ie(e)?(u=!0,c=e.some(v=>Qa(v)||zo(v)),l=()=>e.map(v=>{if(Ae(v))return v.value;if(Qa(v))return Sa(v);if(ue(v))return Ht(v,s,2)})):ue(e)?t?l=()=>Ht(e,s,2):l=()=>{if(!(s&&s.isUnmounted))return h&&h(),gt(e,s,3,[m])}:l=jt,t&&n){const v=l;l=()=>Sa(v())}let h,m=v=>{h=w.onStop=()=>{Ht(v,s,4)}};if(Gn)return m=jt,t?a&&gt(t,s,3,[l(),u?[]:void 0,m]):l(),jt;let f=u?[]:Ds;const p=()=>{if(!!w.active)if(t){const v=w.run();(n||c||(u?v.some((S,k)=>En(S,f[k])):En(v,f)))&&(h&&h(),gt(t,s,3,[v,f===Ds?void 0:f,m]),f=v)}else w.run()};p.allowRecurse=!!t;let b;i==="sync"?b=p:i==="post"?b=()=>et(p,s&&s.suspense):b=()=>jm(p);const w=new Mr(l,b);return t?a?p():f=w.run():i==="post"?et(w.run.bind(w),s&&s.suspense):w.run(),()=>{w.stop(),s&&s.scope&&Pr(s.scope.effects,w)}}function Rm(e,t,a){const n=this.proxy,i=Ve(e)?e.includes(".")?Ic(n,e):()=>n[e]:e.bind(n,n);let o;ue(t)?o=t:(o=t.handler,a=t);const r=Ne;en(this);const s=Vr(i,o.bind(n),a);return r?en(r):Ia(),s}function Ic(e,t){const a=t.split(".");return()=>{let n=e;for(let i=0;i<a.length&&n;i++)n=n[a[i]];return n}}function Sa(e,t){if(!De(e)||e.__v_skip||(t=t||new Set,t.has(e)))return e;if(t.add(e),Ae(e))Sa(e.value,t);else if(ie(e))for(let a=0;a<e.length;a++)Sa(e[a],t);else if(nn(e)||Xa(e))e.forEach(a=>{Sa(a,t)});else if(ac(e))for(const a in e)Sa(e[a],t);return e}function Ac(){const e={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return yt(()=>{e.isMounted=!0}),lt(()=>{e.isUnmounting=!0}),e}const mt=[Function,Array],Vm={name:"BaseTransition",props:{mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:mt,onEnter:mt,onAfterEnter:mt,onEnterCancelled:mt,onBeforeLeave:mt,onLeave:mt,onAfterLeave:mt,onLeaveCancelled:mt,onBeforeAppear:mt,onAppear:mt,onAfterAppear:mt,onAppearCancelled:mt},setup(e,{slots:t}){const a=oo(),n=Ac();let i;return()=>{const o=t.default&&zr(t.default(),!0);if(!o||!o.length)return;let r=o[0];if(o.length>1){for(const b of o)if(b.type!==Ot){r=b;break}}const s=ge(e),{mode:l}=s;if(n.isLeaving)return So(r);const c=Es(r);if(!c)return So(r);const u=zn(c,s,n,a);Hn(c,u);const h=a.subTree,m=h&&Es(h);let f=!1;const{getTransitionKey:p}=c.type;if(p){const b=p();i===void 0?i=b:b!==i&&(i=b,f=!0)}if(m&&m.type!==Ot&&(!xa(c,m)||f)){const b=zn(m,s,n,a);if(Hn(m,b),l==="out-in")return n.isLeaving=!0,b.afterLeave=()=>{n.isLeaving=!1,a.update()},So(r);l==="in-out"&&c.type!==Ot&&(b.delayLeave=(w,v,S)=>{const k=Jc(n,m);k[String(m.key)]=m,w._leaveCb=()=>{v(),w._leaveCb=void 0,delete u.delayedLeave},u.delayedLeave=S})}return r}}},Mc=Vm;function Jc(e,t){const{leavingVNodes:a}=e;let n=a.get(t.type);return n||(n=Object.create(null),a.set(t.type,n)),n}function zn(e,t,a,n){const{appear:i,mode:o,persisted:r=!1,onBeforeEnter:s,onEnter:l,onAfterEnter:c,onEnterCancelled:u,onBeforeLeave:h,onLeave:m,onAfterLeave:f,onLeaveCancelled:p,onBeforeAppear:b,onAppear:w,onAfterAppear:v,onAppearCancelled:S}=t,k=String(e.key),P=Jc(a,e),j=(_,M)=>{_&&gt(_,n,9,M)},x=(_,M)=>{const I=M[1];j(_,M),ie(_)?_.every(J=>J.length<=1)&&I():_.length<=1&&I()},y={mode:o,persisted:r,beforeEnter(_){let M=s;if(!a.isMounted)if(i)M=b||s;else return;_._leaveCb&&_._leaveCb(!0);const I=P[k];I&&xa(e,I)&&I.el._leaveCb&&I.el._leaveCb(),j(M,[_])},enter(_){let M=l,I=c,J=u;if(!a.isMounted)if(i)M=w||l,I=v||c,J=S||u;else return;let T=!1;const L=_._enterCb=B=>{T||(T=!0,B?j(J,[_]):j(I,[_]),y.delayedLeave&&y.delayedLeave(),_._enterCb=void 0)};M?x(M,[_,L]):L()},leave(_,M){const I=String(e.key);if(_._enterCb&&_._enterCb(!0),a.isUnmounting)return M();j(h,[_]);let J=!1;const T=_._leaveCb=L=>{J||(J=!0,M(),L?j(p,[_]):j(f,[_]),_._leaveCb=void 0,P[I]===e&&delete P[I])};P[I]=e,m?x(m,[_,T]):T()},clone(_){return zn(_,t,a,n)}};return y}function So(e){if(eo(e))return e=ca(e),e.children=null,e}function Es(e){return eo(e)?e.children?e.children[0]:void 0:e}function Hn(e,t){e.shapeFlag&6&&e.component?Hn(e.component.subTree,t):e.shapeFlag&128?(e.ssContent.transition=t.clone(e.ssContent),e.ssFallback.transition=t.clone(e.ssFallback)):e.transition=t}function zr(e,t=!1,a){let n=[],i=0;for(let o=0;o<e.length;o++){let r=e[o];const s=a==null?r.key:String(a)+String(r.key!=null?r.key:o);r.type===pe?(r.patchFlag&128&&i++,n=n.concat(zr(r.children,t,s))):(t||r.type!==Ot)&&n.push(s!=null?ca(r,{key:s}):r)}if(i>1)for(let o=0;o<n.length;o++)n[o].patchFlag=-2;return n}function Hr(e){return ue(e)?{setup:e,name:e.name}:e}const Si=e=>!!e.type.__asyncLoader,eo=e=>e.type.__isKeepAlive;function Lc(e,t){Ec(e,"a",t)}function Dc(e,t){Ec(e,"da",t)}function Ec(e,t,a=Ne){const n=e.__wdc||(e.__wdc=()=>{let i=a;for(;i;){if(i.isDeactivated)return;i=i.parent}return e()});if(to(t,n,a),a){let i=a.parent;for(;i&&i.parent;)eo(i.parent.vnode)&&zm(n,t,a,i),i=i.parent}}function zm(e,t,a,n){const i=to(t,e,n,!0);Rc(()=>{Pr(n[t],i)},a)}function to(e,t,a=Ne,n=!1){if(a){const i=a[e]||(a[e]=[]),o=t.__weh||(t.__weh=(...r)=>{if(a.isUnmounted)return;Da(),en(a);const s=gt(t,a,e,r);return Ia(),Ea(),s});return n?i.unshift(o):i.push(o),o}}const Ut=e=>(t,a=Ne)=>(!Gn||e==="sp")&&to(e,t,a),ao=Ut("bm"),yt=Ut("m"),Bc=Ut("bu"),Fc=Ut("u"),lt=Ut("bum"),Rc=Ut("um"),Hm=Ut("sp"),Om=Ut("rtg"),Gm=Ut("rtc");function Nm(e,t=Ne){to("ec",e,t)}function Me(e,t){const a=pt;if(a===null)return e;const n=ro(a)||a.proxy,i=e.dirs||(e.dirs=[]);for(let o=0;o<t.length;o++){let[r,s,l,c=_e]=t[o];ue(r)&&(r={mounted:r,updated:r}),r.deep&&Sa(s),i.push({dir:r,instance:n,value:s,oldValue:void 0,arg:l,modifiers:c})}return e}function ga(e,t,a,n){const i=e.dirs,o=t&&t.dirs;for(let r=0;r<i.length;r++){const s=i[r];o&&(s.oldValue=o[r].value);let l=s.dir[n];l&&(Da(),gt(l,a,8,[e.el,s,e,t]),Ea())}}const Vc="components",$m="directives",zc=Symbol();function Um(e){return Ve(e)?Hc(Vc,e,!1)||e:e||zc}function ct(e){return Hc($m,e)}function Hc(e,t,a=!0,n=!1){const i=pt||Ne;if(i){const o=i.type;if(e===Vc){const s=eu(o,!1);if(s&&(s===t||s===bt(t)||s===ha(bt(t))))return o}const r=Bs(i[e]||o[e],t)||Bs(i.appContext[e],t);return!r&&n?o:r}}function Bs(e,t){return e&&(e[t]||e[bt(t)]||e[ha(bt(t))])}function Fs(e,t,a,n){let i;const o=a&&a[n];if(ie(e)||Ve(e)){i=new Array(e.length);for(let r=0,s=e.length;r<s;r++)i[r]=t(e[r],r,void 0,o&&o[r])}else if(typeof e=="number"){i=new Array(e);for(let r=0;r<e;r++)i[r]=t(r+1,r,void 0,o&&o[r])}else if(De(e))if(e[Symbol.iterator])i=Array.from(e,(r,s)=>t(r,s,void 0,o&&o[s]));else{const r=Object.keys(e);i=new Array(r.length);for(let s=0,l=r.length;s<l;s++){const c=r[s];i[s]=t(e[c],c,s,o&&o[s])}}else i=[];return a&&(a[n]=i),i}function Rs(e){const t={};for(const a in e)t[xi(a)]=e[a];return t}const Go=e=>e?Qc(e)?ro(e)||e.proxy:Go(e.parent):null,Mi=$e(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>Go(e.parent),$root:e=>Go(e.root),$emit:e=>e.emit,$options:e=>Gc(e),$forceUpdate:e=>e.f||(e.f=()=>Cc(e.update)),$nextTick:e=>e.n||(e.n=Ee.bind(e.proxy)),$watch:e=>Rm.bind(e)}),Wm={get({_:e},t){const{ctx:a,setupState:n,data:i,props:o,accessCache:r,type:s,appContext:l}=e;let c;if(t[0]!=="$"){const f=r[t];if(f!==void 0)switch(f){case 1:return n[t];case 2:return i[t];case 4:return a[t];case 3:return o[t]}else{if(n!==_e&&be(n,t))return r[t]=1,n[t];if(i!==_e&&be(i,t))return r[t]=2,i[t];if((c=e.propsOptions[0])&&be(c,t))return r[t]=3,o[t];if(a!==_e&&be(a,t))return r[t]=4,a[t];No&&(r[t]=0)}}const u=Mi[t];let h,m;if(u)return t==="$attrs"&&st(e,"get",t),u(e);if((h=s.__cssModules)&&(h=h[t]))return h;if(a!==_e&&be(a,t))return r[t]=4,a[t];if(m=l.config.globalProperties,be(m,t))return m[t]},set({_:e},t,a){const{data:n,setupState:i,ctx:o}=e;return i!==_e&&be(i,t)?(i[t]=a,!0):n!==_e&&be(n,t)?(n[t]=a,!0):be(e.props,t)||t[0]==="$"&&t.slice(1)in e?!1:(o[t]=a,!0)},has({_:{data:e,setupState:t,accessCache:a,ctx:n,appContext:i,propsOptions:o}},r){let s;return!!a[r]||e!==_e&&be(e,r)||t!==_e&&be(t,r)||(s=o[0])&&be(s,r)||be(n,r)||be(Mi,r)||be(i.config.globalProperties,r)},defineProperty(e,t,a){return a.get!=null?e._.accessCache[t]=0:be(a,"value")&&this.set(e,t,a.value,null),Reflect.defineProperty(e,t,a)}};let No=!0;function qm(e){const t=Gc(e),a=e.proxy,n=e.ctx;No=!1,t.beforeCreate&&Vs(t.beforeCreate,e,"bc");const{data:i,computed:o,methods:r,watch:s,provide:l,inject:c,created:u,beforeMount:h,mounted:m,beforeUpdate:f,updated:p,activated:b,deactivated:w,beforeDestroy:v,beforeUnmount:S,destroyed:k,unmounted:P,render:j,renderTracked:x,renderTriggered:y,errorCaptured:_,serverPrefetch:M,expose:I,inheritAttrs:J,components:T,directives:L,filters:B}=t;if(c&&Km(c,n,null,e.appContext.config.unwrapInjectedRef),r)for(const N in r){const K=r[N];ue(K)&&(n[N]=K.bind(a))}if(i){const N=i.call(a,a);De(N)&&(e.data=tt(N))}if(No=!0,o)for(const N in o){const K=o[N],de=ue(K)?K.bind(a,a):ue(K.get)?K.get.bind(a,a):jt,Z=!ue(K)&&ue(K.set)?K.set.bind(a):jt,te=g({get:de,set:Z});Object.defineProperty(n,N,{enumerable:!0,configurable:!0,get:()=>te.value,set:fe=>te.value=fe})}if(s)for(const N in s)Oc(s[N],n,a,N);if(l){const N=ue(l)?l.call(a):l;Reflect.ownKeys(N).forEach(K=>{Oe(K,N[K])})}u&&Vs(u,e,"c");function $(N,K){ie(K)?K.forEach(de=>N(de.bind(a))):K&&N(K.bind(a))}if($(ao,h),$(yt,m),$(Bc,f),$(Fc,p),$(Lc,b),$(Dc,w),$(Nm,_),$(Gm,x),$(Om,y),$(lt,S),$(Rc,P),$(Hm,M),ie(I))if(I.length){const N=e.exposed||(e.exposed={});I.forEach(K=>{Object.defineProperty(N,K,{get:()=>a[K],set:de=>a[K]=de})})}else e.exposed||(e.exposed={});j&&e.render===jt&&(e.render=j),J!=null&&(e.inheritAttrs=J),T&&(e.components=T),L&&(e.directives=L)}function Km(e,t,a=jt,n=!1){ie(e)&&(e=$o(e));for(const i in e){const o=e[i];let r;De(o)?"default"in o?r=we(o.from||i,o.default,!0):r=we(o.from||i):r=we(o),Ae(r)&&n?Object.defineProperty(t,i,{enumerable:!0,configurable:!0,get:()=>r.value,set:s=>r.value=s}):t[i]=r}}function Vs(e,t,a){gt(ie(e)?e.map(n=>n.bind(t.proxy)):e.bind(t.proxy),t,a)}function Oc(e,t,a,n){const i=n.includes(".")?Ic(a,n):()=>a[n];if(Ve(e)){const o=t[e];ue(o)&&re(i,o)}else if(ue(e))re(i,e.bind(a));else if(De(e))if(ie(e))e.forEach(o=>Oc(o,t,a,n));else{const o=ue(e.handler)?e.handler.bind(a):t[e.handler];ue(o)&&re(i,o,e)}}function Gc(e){const t=e.type,{mixins:a,extends:n}=t,{mixins:i,optionsCache:o,config:{optionMergeStrategies:r}}=e.appContext,s=o.get(t);let l;return s?l=s:!i.length&&!a&&!n?l=t:(l={},i.length&&i.forEach(c=>Ji(l,c,r,!0)),Ji(l,t,r)),o.set(t,l),l}function Ji(e,t,a,n=!1){const{mixins:i,extends:o}=t;o&&Ji(e,o,a,!0),i&&i.forEach(r=>Ji(e,r,a,!0));for(const r in t)if(!(n&&r==="expose")){const s=Ym[r]||a&&a[r];e[r]=s?s(e[r],t[r]):t[r]}return e}const Ym={data:zs,props:ka,emits:ka,methods:ka,computed:ka,beforeCreate:Ze,created:Ze,beforeMount:Ze,mounted:Ze,beforeUpdate:Ze,updated:Ze,beforeDestroy:Ze,beforeUnmount:Ze,destroyed:Ze,unmounted:Ze,activated:Ze,deactivated:Ze,errorCaptured:Ze,serverPrefetch:Ze,components:ka,directives:ka,watch:Qm,provide:zs,inject:Xm};function zs(e,t){return t?e?function(){return $e(ue(e)?e.call(this,this):e,ue(t)?t.call(this,this):t)}:t:e}function Xm(e,t){return ka($o(e),$o(t))}function $o(e){if(ie(e)){const t={};for(let a=0;a<e.length;a++)t[e[a]]=e[a];return t}return e}function Ze(e,t){return e?[...new Set([].concat(e,t))]:t}function ka(e,t){return e?$e($e(Object.create(null),e),t):t}function Qm(e,t){if(!e)return t;if(!t)return e;const a=$e(Object.create(null),e);for(const n in t)a[n]=Ze(e[n],t[n]);return a}function Zm(e,t,a,n=!1){const i={},o={};Pi(o,no,1),e.propsDefaults=Object.create(null),Nc(e,t,i,o);for(const r in e.propsOptions[0])r in i||(i[r]=void 0);a?e.props=n?i:fc(i):e.type.props?e.props=i:e.props=o,e.attrs=o}function ef(e,t,a,n){const{props:i,attrs:o,vnode:{patchFlag:r}}=e,s=ge(i),[l]=e.propsOptions;let c=!1;if((n||r>0)&&!(r&16)){if(r&8){const u=e.vnode.dynamicProps;for(let h=0;h<u.length;h++){let m=u[h];if(Qi(e.emitsOptions,m))continue;const f=t[m];if(l)if(be(o,m))f!==o[m]&&(o[m]=f,c=!0);else{const p=bt(m);i[p]=Uo(l,s,p,f,e,!1)}else f!==o[m]&&(o[m]=f,c=!0)}}}else{Nc(e,t,i,o)&&(c=!0);let u;for(const h in s)(!t||!be(t,h)&&((u=on(h))===h||!be(t,u)))&&(l?a&&(a[h]!==void 0||a[u]!==void 0)&&(i[h]=Uo(l,s,h,void 0,e,!0)):delete i[h]);if(o!==s)for(const h in o)(!t||!be(t,h)&&!0)&&(delete o[h],c=!0)}c&&Gt(e,"set","$attrs")}function Nc(e,t,a,n){const[i,o]=e.propsOptions;let r=!1,s;if(t)for(let l in t){if(ki(l))continue;const c=t[l];let u;i&&be(i,u=bt(l))?!o||!o.includes(u)?a[u]=c:(s||(s={}))[u]=c:Qi(e.emitsOptions,l)||(!(l in n)||c!==n[l])&&(n[l]=c,r=!0)}if(o){const l=ge(a),c=s||_e;for(let u=0;u<o.length;u++){const h=o[u];a[h]=Uo(i,l,h,c[h],e,!be(c,h))}}return r}function Uo(e,t,a,n,i,o){const r=e[a];if(r!=null){const s=be(r,"default");if(s&&n===void 0){const l=r.default;if(r.type!==Function&&ue(l)){const{propsDefaults:c}=i;a in c?n=c[a]:(en(i),n=c[a]=l.call(null,t),Ia())}else n=l}r[0]&&(o&&!s?n=!1:r[1]&&(n===""||n===on(a))&&(n=!0))}return n}function $c(e,t,a=!1){const n=t.propsCache,i=n.get(e);if(i)return i;const o=e.props,r={},s=[];let l=!1;if(!ue(e)){const u=h=>{l=!0;const[m,f]=$c(h,t,!0);$e(r,m),f&&s.push(...f)};!a&&t.mixins.length&&t.mixins.forEach(u),e.extends&&u(e.extends),e.mixins&&e.mixins.forEach(u)}if(!o&&!l)return n.set(e,Ya),Ya;if(ie(o))for(let u=0;u<o.length;u++){const h=bt(o[u]);Hs(h)&&(r[h]=_e)}else if(o)for(const u in o){const h=bt(u);if(Hs(h)){const m=o[u],f=r[h]=ie(m)||ue(m)?{type:m}:m;if(f){const p=Ns(Boolean,f.type),b=Ns(String,f.type);f[0]=p>-1,f[1]=b<0||p<b,(p>-1||be(f,"default"))&&s.push(h)}}}const c=[r,s];return n.set(e,c),c}function Hs(e){return e[0]!=="$"}function Os(e){const t=e&&e.toString().match(/^\s*function (\w+)/);return t?t[1]:e===null?"null":""}function Gs(e,t){return Os(e)===Os(t)}function Ns(e,t){return ie(t)?t.findIndex(a=>Gs(a,e)):ue(t)&&Gs(t,e)?0:-1}const Uc=e=>e[0]==="_"||e==="$stable",Or=e=>ie(e)?e.map(Mt):[Mt(e)],tf=(e,t,a)=>{if(t._n)return t;const n=na((...i)=>Or(t(...i)),a);return n._c=!1,n},Wc=(e,t,a)=>{const n=e._ctx;for(const i in e){if(Uc(i))continue;const o=e[i];if(ue(o))t[i]=tf(i,o,n);else if(o!=null){const r=Or(o);t[i]=()=>r}}},qc=(e,t)=>{const a=Or(t);e.slots.default=()=>a},af=(e,t)=>{if(e.vnode.shapeFlag&32){const a=t._;a?(e.slots=ge(t),Pi(t,"_",a)):Wc(t,e.slots={})}else e.slots={},t&&qc(e,t);Pi(e.slots,no,1)},nf=(e,t,a)=>{const{vnode:n,slots:i}=e;let o=!0,r=_e;if(n.shapeFlag&32){const s=t._;s?a&&s===1?o=!1:($e(i,t),!a&&s===1&&delete i._):(o=!t.$stable,Wc(t,i)),r=t}else t&&(qc(e,t),r={default:1});if(o)for(const s in i)!Uc(s)&&!(s in r)&&delete i[s]};function Kc(){return{app:null,config:{isNativeTag:Dh,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let of=0;function rf(e,t){return function(n,i=null){ue(n)||(n=Object.assign({},n)),i!=null&&!De(i)&&(i=null);const o=Kc(),r=new Set;let s=!1;const l=o.app={_uid:of++,_component:n,_props:i,_container:null,_context:o,_instance:null,version:jf,get config(){return o.config},set config(c){},use(c,...u){return r.has(c)||(c&&ue(c.install)?(r.add(c),c.install(l,...u)):ue(c)&&(r.add(c),c(l,...u))),l},mixin(c){return o.mixins.includes(c)||o.mixins.push(c),l},component(c,u){return u?(o.components[c]=u,l):o.components[c]},directive(c,u){return u?(o.directives[c]=u,l):o.directives[c]},mount(c,u,h){if(!s){const m=d(n,i);return m.appContext=o,u&&t?t(m,c):e(m,c,h),s=!0,l._container=c,c.__vue_app__=l,ro(m.component)||m.component.proxy}},unmount(){s&&(e(null,l._container),delete l._container.__vue_app__)},provide(c,u){return o.provides[c]=u,l}};return l}}function Wo(e,t,a,n,i=!1){if(ie(e)){e.forEach((m,f)=>Wo(m,t&&(ie(t)?t[f]:t),a,n,i));return}if(Si(n)&&!i)return;const o=n.shapeFlag&4?ro(n.component)||n.component.proxy:n.el,r=i?null:o,{i:s,r:l}=e,c=t&&t.r,u=s.refs===_e?s.refs={}:s.refs,h=s.setupState;if(c!=null&&c!==l&&(Ve(c)?(u[c]=null,be(h,c)&&(h[c]=null)):Ae(c)&&(c.value=null)),ue(l))Ht(l,s,12,[r,u]);else{const m=Ve(l),f=Ae(l);if(m||f){const p=()=>{if(e.f){const b=m?u[l]:l.value;i?ie(b)&&Pr(b,o):ie(b)?b.includes(o)||b.push(o):m?(u[l]=[o],be(h,l)&&(h[l]=u[l])):(l.value=[o],e.k&&(u[e.k]=l.value))}else m?(u[l]=r,be(h,l)&&(h[l]=r)):f&&(l.value=r,e.k&&(u[e.k]=r))};r?(p.id=-1,et(p,a)):p()}}}const et=Fm;function sf(e){return lf(e)}function lf(e,t){const a=zh();a.__VUE__=!0;const{insert:n,remove:i,patchProp:o,createElement:r,createText:s,createComment:l,setText:c,setElementText:u,parentNode:h,nextSibling:m,setScopeId:f=jt,cloneNode:p,insertStaticContent:b}=e,w=(C,A,E,V=null,R=null,W=null,X=!1,U=null,q=!!A.dynamicChildren)=>{if(C===A)return;C&&!xa(C,A)&&(V=Ha(C),Je(C,R,W,!0),C=null),A.patchFlag===-2&&(q=!1,A.dynamicChildren=null);const{type:G,ref:ae,shapeFlag:ee}=A;switch(G){case Nr:v(C,A,E,V);break;case Ot:S(C,A,E,V);break;case _o:C==null&&k(A,E,V,X);break;case pe:L(C,A,E,V,R,W,X,U,q);break;default:ee&1?x(C,A,E,V,R,W,X,U,q):ee&6?B(C,A,E,V,R,W,X,U,q):(ee&64||ee&128)&&G.process(C,A,E,V,R,W,X,U,q,Zt)}ae!=null&&R&&Wo(ae,C&&C.ref,W,A||C,!A)},v=(C,A,E,V)=>{if(C==null)n(A.el=s(A.children),E,V);else{const R=A.el=C.el;A.children!==C.children&&c(R,A.children)}},S=(C,A,E,V)=>{C==null?n(A.el=l(A.children||""),E,V):A.el=C.el},k=(C,A,E,V)=>{[C.el,C.anchor]=b(C.children,A,E,V,C.el,C.anchor)},P=({el:C,anchor:A},E,V)=>{let R;for(;C&&C!==A;)R=m(C),n(C,E,V),C=R;n(A,E,V)},j=({el:C,anchor:A})=>{let E;for(;C&&C!==A;)E=m(C),i(C),C=E;i(A)},x=(C,A,E,V,R,W,X,U,q)=>{X=X||A.type==="svg",C==null?y(A,E,V,R,W,X,U,q):I(C,A,R,W,X,U,q)},y=(C,A,E,V,R,W,X,U)=>{let q,G;const{type:ae,props:ee,shapeFlag:ne,transition:ce,patchFlag:ye,dirs:Ce}=C;if(C.el&&p!==void 0&&ye===-1)q=C.el=p(C.el);else{if(q=C.el=r(C.type,W,ee&&ee.is,ee),ne&8?u(q,C.children):ne&16&&M(C.children,q,null,V,R,W&&ae!=="foreignObject",X,U),Ce&&ga(C,null,V,"created"),ee){for(const je in ee)je!=="value"&&!ki(je)&&o(q,je,null,ee[je],W,C.children,V,R,Qe);"value"in ee&&o(q,"value",null,ee.value),(G=ee.onVnodeBeforeMount)&&At(G,V,C)}_(q,C,C.scopeId,X,V)}Ce&&ga(C,null,V,"beforeMount");const Se=(!R||R&&!R.pendingBranch)&&ce&&!ce.persisted;Se&&ce.beforeEnter(q),n(q,A,E),((G=ee&&ee.onVnodeMounted)||Se||Ce)&&et(()=>{G&&At(G,V,C),Se&&ce.enter(q),Ce&&ga(C,null,V,"mounted")},R)},_=(C,A,E,V,R)=>{if(E&&f(C,E),V)for(let W=0;W<V.length;W++)f(C,V[W]);if(R){let W=R.subTree;if(A===W){const X=R.vnode;_(C,X,X.scopeId,X.slotScopeIds,R.parent)}}},M=(C,A,E,V,R,W,X,U,q=0)=>{for(let G=q;G<C.length;G++){const ae=C[G]=U?oa(C[G]):Mt(C[G]);w(null,ae,A,E,V,R,W,X,U)}},I=(C,A,E,V,R,W,X)=>{const U=A.el=C.el;let{patchFlag:q,dynamicChildren:G,dirs:ae}=A;q|=C.patchFlag&16;const ee=C.props||_e,ne=A.props||_e;let ce;E&&va(E,!1),(ce=ne.onVnodeBeforeUpdate)&&At(ce,E,A,C),ae&&ga(A,C,E,"beforeUpdate"),E&&va(E,!0);const ye=R&&A.type!=="foreignObject";if(G?J(C.dynamicChildren,G,U,E,V,ye,W):X||de(C,A,U,null,E,V,ye,W,!1),q>0){if(q&16)T(U,A,ee,ne,E,V,R);else if(q&2&&ee.class!==ne.class&&o(U,"class",null,ne.class,R),q&4&&o(U,"style",ee.style,ne.style,R),q&8){const Ce=A.dynamicProps;for(let Se=0;Se<Ce.length;Se++){const je=Ce[Se],Ct=ee[je],Oa=ne[je];(Oa!==Ct||je==="value")&&o(U,je,Ct,Oa,R,C.children,E,V,Qe)}}q&1&&C.children!==A.children&&u(U,A.children)}else!X&&G==null&&T(U,A,ee,ne,E,V,R);((ce=ne.onVnodeUpdated)||ae)&&et(()=>{ce&&At(ce,E,A,C),ae&&ga(A,C,E,"updated")},V)},J=(C,A,E,V,R,W,X)=>{for(let U=0;U<A.length;U++){const q=C[U],G=A[U],ae=q.el&&(q.type===pe||!xa(q,G)||q.shapeFlag&70)?h(q.el):E;w(q,G,ae,null,V,R,W,X,!0)}},T=(C,A,E,V,R,W,X)=>{if(E!==V){for(const U in V){if(ki(U))continue;const q=V[U],G=E[U];q!==G&&U!=="value"&&o(C,U,G,q,X,A.children,R,W,Qe)}if(E!==_e)for(const U in E)!ki(U)&&!(U in V)&&o(C,U,E[U],null,X,A.children,R,W,Qe);"value"in V&&o(C,"value",E.value,V.value)}},L=(C,A,E,V,R,W,X,U,q)=>{const G=A.el=C?C.el:s(""),ae=A.anchor=C?C.anchor:s("");let{patchFlag:ee,dynamicChildren:ne,slotScopeIds:ce}=A;ce&&(U=U?U.concat(ce):ce),C==null?(n(G,E,V),n(ae,E,V),M(A.children,E,ae,R,W,X,U,q)):ee>0&&ee&64&&ne&&C.dynamicChildren?(J(C.dynamicChildren,ne,E,R,W,X,U),(A.key!=null||R&&A===R.subTree)&&Gr(C,A,!0)):de(C,A,E,ae,R,W,X,U,q)},B=(C,A,E,V,R,W,X,U,q)=>{A.slotScopeIds=U,C==null?A.shapeFlag&512?R.ctx.activate(A,E,V,X,q):F(A,E,V,R,W,X,q):$(C,A,q)},F=(C,A,E,V,R,W,X)=>{const U=C.component=yf(C,V,R);if(eo(C)&&(U.ctx.renderer=Zt),wf(U),U.asyncDep){if(R&&R.registerDep(U,N),!C.el){const q=U.subTree=d(Ot);S(null,q,A,E)}return}N(U,C,A,E,R,W,X)},$=(C,A,E)=>{const V=A.component=C.component;if(Dm(C,A,E))if(V.asyncDep&&!V.asyncResolved){K(V,A,E);return}else V.next=A,Tm(V.update),V.update();else A.el=C.el,V.vnode=A},N=(C,A,E,V,R,W,X)=>{const U=()=>{if(C.isMounted){let{next:ae,bu:ee,u:ne,parent:ce,vnode:ye}=C,Ce=ae,Se;va(C,!1),ae?(ae.el=ye.el,K(C,ae,X)):ae=ye,ee&&Ci(ee),(Se=ae.props&&ae.props.onVnodeBeforeUpdate)&&At(Se,ce,ae,ye),va(C,!0);const je=Co(C),Ct=C.subTree;C.subTree=je,w(Ct,je,h(Ct.el),Ha(Ct),C,R,W),ae.el=je.el,Ce===null&&Em(C,je.el),ne&&et(ne,R),(Se=ae.props&&ae.props.onVnodeUpdated)&&et(()=>At(Se,ce,ae,ye),R)}else{let ae;const{el:ee,props:ne}=A,{bm:ce,m:ye,parent:Ce}=C,Se=Si(A);if(va(C,!1),ce&&Ci(ce),!Se&&(ae=ne&&ne.onVnodeBeforeMount)&&At(ae,Ce,A),va(C,!0),ee&&yn){const je=()=>{C.subTree=Co(C),yn(ee,C.subTree,C,R,null)};Se?A.type.__asyncLoader().then(()=>!C.isUnmounted&&je()):je()}else{const je=C.subTree=Co(C);w(null,je,E,V,C,R,W),A.el=je.el}if(ye&&et(ye,R),!Se&&(ae=ne&&ne.onVnodeMounted)){const je=A;et(()=>At(ae,Ce,je),R)}(A.shapeFlag&256||Ce&&Si(Ce.vnode)&&Ce.vnode.shapeFlag&256)&&C.a&&et(C.a,R),C.isMounted=!0,A=E=V=null}},q=C.effect=new Mr(U,()=>Cc(G),C.scope),G=C.update=()=>q.run();G.id=C.uid,va(C,!0),G()},K=(C,A,E)=>{A.component=C;const V=C.vnode.props;C.vnode=A,C.next=null,ef(C,A.props,V,E),nf(C,A.children,E),Da(),Xi(void 0,C.update),Ea()},de=(C,A,E,V,R,W,X,U,q=!1)=>{const G=C&&C.children,ae=C?C.shapeFlag:0,ee=A.children,{patchFlag:ne,shapeFlag:ce}=A;if(ne>0){if(ne&128){te(G,ee,E,V,R,W,X,U,q);return}else if(ne&256){Z(G,ee,E,V,R,W,X,U,q);return}}ce&8?(ae&16&&Qe(G,R,W),ee!==G&&u(E,ee)):ae&16?ce&16?te(G,ee,E,V,R,W,X,U,q):Qe(G,R,W,!0):(ae&8&&u(E,""),ce&16&&M(ee,E,V,R,W,X,U,q))},Z=(C,A,E,V,R,W,X,U,q)=>{C=C||Ya,A=A||Ya;const G=C.length,ae=A.length,ee=Math.min(G,ae);let ne;for(ne=0;ne<ee;ne++){const ce=A[ne]=q?oa(A[ne]):Mt(A[ne]);w(C[ne],ce,E,null,R,W,X,U,q)}G>ae?Qe(C,R,W,!0,!1,ee):M(A,E,V,R,W,X,U,q,ee)},te=(C,A,E,V,R,W,X,U,q)=>{let G=0;const ae=A.length;let ee=C.length-1,ne=ae-1;for(;G<=ee&&G<=ne;){const ce=C[G],ye=A[G]=q?oa(A[G]):Mt(A[G]);if(xa(ce,ye))w(ce,ye,E,null,R,W,X,U,q);else break;G++}for(;G<=ee&&G<=ne;){const ce=C[ee],ye=A[ne]=q?oa(A[ne]):Mt(A[ne]);if(xa(ce,ye))w(ce,ye,E,null,R,W,X,U,q);else break;ee--,ne--}if(G>ee){if(G<=ne){const ce=ne+1,ye=ce<ae?A[ce].el:V;for(;G<=ne;)w(null,A[G]=q?oa(A[G]):Mt(A[G]),E,ye,R,W,X,U,q),G++}}else if(G>ne)for(;G<=ee;)Je(C[G],R,W,!0),G++;else{const ce=G,ye=G,Ce=new Map;for(G=ye;G<=ne;G++){const nt=A[G]=q?oa(A[G]):Mt(A[G]);nt.key!=null&&Ce.set(nt.key,G)}let Se,je=0;const Ct=ne-ye+1;let Oa=!1,ks=0;const wn=new Array(Ct);for(G=0;G<Ct;G++)wn[G]=0;for(G=ce;G<=ee;G++){const nt=C[G];if(je>=Ct){Je(nt,R,W,!0);continue}let It;if(nt.key!=null)It=Ce.get(nt.key);else for(Se=ye;Se<=ne;Se++)if(wn[Se-ye]===0&&xa(nt,A[Se])){It=Se;break}It===void 0?Je(nt,R,W,!0):(wn[It-ye]=G+1,It>=ks?ks=It:Oa=!0,w(nt,A[It],E,null,R,W,X,U,q),je++)}const xs=Oa?cf(wn):Ya;for(Se=xs.length-1,G=Ct-1;G>=0;G--){const nt=ye+G,It=A[nt],Cs=nt+1<ae?A[nt+1].el:V;wn[G]===0?w(null,It,E,Cs,R,W,X,U,q):Oa&&(Se<0||G!==xs[Se]?fe(It,E,Cs,2):Se--)}}},fe=(C,A,E,V,R=null)=>{const{el:W,type:X,transition:U,children:q,shapeFlag:G}=C;if(G&6){fe(C.component.subTree,A,E,V);return}if(G&128){C.suspense.move(A,E,V);return}if(G&64){X.move(C,A,E,Zt);return}if(X===pe){n(W,A,E);for(let ee=0;ee<q.length;ee++)fe(q[ee],A,E,V);n(C.anchor,A,E);return}if(X===_o){P(C,A,E);return}if(V!==2&&G&1&&U)if(V===0)U.beforeEnter(W),n(W,A,E),et(()=>U.enter(W),R);else{const{leave:ee,delayLeave:ne,afterLeave:ce}=U,ye=()=>n(W,A,E),Ce=()=>{ee(W,()=>{ye(),ce&&ce()})};ne?ne(W,ye,Ce):Ce()}else n(W,A,E)},Je=(C,A,E,V=!1,R=!1)=>{const{type:W,props:X,ref:U,children:q,dynamicChildren:G,shapeFlag:ae,patchFlag:ee,dirs:ne}=C;if(U!=null&&Wo(U,null,E,C,!0),ae&256){A.ctx.deactivate(C);return}const ce=ae&1&&ne,ye=!Si(C);let Ce;if(ye&&(Ce=X&&X.onVnodeBeforeUnmount)&&At(Ce,A,C),ae&6)ze(C.component,E,V);else{if(ae&128){C.suspense.unmount(E,V);return}ce&&ga(C,null,A,"beforeUnmount"),ae&64?C.type.remove(C,A,E,R,Zt,V):G&&(W!==pe||ee>0&&ee&64)?Qe(G,A,E,!1,!0):(W===pe&&ee&384||!R&&ae&16)&&Qe(q,A,E),V&&Y(C)}(ye&&(Ce=X&&X.onVnodeUnmounted)||ce)&&et(()=>{Ce&&At(Ce,A,C),ce&&ga(C,null,A,"unmounted")},E)},Y=C=>{const{type:A,el:E,anchor:V,transition:R}=C;if(A===pe){xe(E,V);return}if(A===_o){j(C);return}const W=()=>{i(E),R&&!R.persisted&&R.afterLeave&&R.afterLeave()};if(C.shapeFlag&1&&R&&!R.persisted){const{leave:X,delayLeave:U}=R,q=()=>X(E,W);U?U(C.el,W,q):q()}else W()},xe=(C,A)=>{let E;for(;C!==A;)E=m(C),i(C),C=E;i(A)},ze=(C,A,E)=>{const{bum:V,scope:R,update:W,subTree:X,um:U}=C;V&&Ci(V),R.stop(),W&&(W.active=!1,Je(X,C,A,E)),U&&et(U,A),et(()=>{C.isUnmounted=!0},A),A&&A.pendingBranch&&!A.isUnmounted&&C.asyncDep&&!C.asyncResolved&&C.suspenseId===A.pendingId&&(A.deps--,A.deps===0&&A.resolve())},Qe=(C,A,E,V=!1,R=!1,W=0)=>{for(let X=W;X<C.length;X++)Je(C[X],A,E,V,R)},Ha=C=>C.shapeFlag&6?Ha(C.component.subTree):C.shapeFlag&128?C.suspense.next():m(C.anchor||C.el),li=(C,A,E)=>{C==null?A._vnode&&Je(A._vnode,null,null,!0):w(A._vnode||null,C,A,null,null,null,E),Tc(),A._vnode=C},Zt={p:w,um:Je,m:fe,r:Y,mt:F,mc:M,pc:de,pbc:J,n:Ha,o:e};let bn,yn;return t&&([bn,yn]=t(Zt)),{render:li,hydrate:bn,createApp:rf(li,bn)}}function va({effect:e,update:t},a){e.allowRecurse=t.allowRecurse=a}function Gr(e,t,a=!1){const n=e.children,i=t.children;if(ie(n)&&ie(i))for(let o=0;o<n.length;o++){const r=n[o];let s=i[o];s.shapeFlag&1&&!s.dynamicChildren&&((s.patchFlag<=0||s.patchFlag===32)&&(s=i[o]=oa(i[o]),s.el=r.el),a||Gr(r,s))}}function cf(e){const t=e.slice(),a=[0];let n,i,o,r,s;const l=e.length;for(n=0;n<l;n++){const c=e[n];if(c!==0){if(i=a[a.length-1],e[i]<c){t[n]=i,a.push(n);continue}for(o=0,r=a.length-1;o<r;)s=o+r>>1,e[a[s]]<c?o=s+1:r=s;c<e[a[o]]&&(o>0&&(t[n]=a[o-1]),a[o]=n)}}for(o=a.length,r=a[o-1];o-- >0;)a[o]=r,r=t[r];return a}const uf=e=>e.__isTeleport,An=e=>e&&(e.disabled||e.disabled===""),$s=e=>typeof SVGElement<"u"&&e instanceof SVGElement,qo=(e,t)=>{const a=e&&e.to;return Ve(a)?t?t(a):null:a},df={__isTeleport:!0,process(e,t,a,n,i,o,r,s,l,c){const{mc:u,pc:h,pbc:m,o:{insert:f,querySelector:p,createText:b,createComment:w}}=c,v=An(t.props);let{shapeFlag:S,children:k,dynamicChildren:P}=t;if(e==null){const j=t.el=b(""),x=t.anchor=b("");f(j,a,n),f(x,a,n);const y=t.target=qo(t.props,p),_=t.targetAnchor=b("");y&&(f(_,y),r=r||$s(y));const M=(I,J)=>{S&16&&u(k,I,J,i,o,r,s,l)};v?M(a,x):y&&M(y,_)}else{t.el=e.el;const j=t.anchor=e.anchor,x=t.target=e.target,y=t.targetAnchor=e.targetAnchor,_=An(e.props),M=_?a:x,I=_?j:y;if(r=r||$s(x),P?(m(e.dynamicChildren,P,M,i,o,r,s),Gr(e,t,!0)):l||h(e,t,M,I,i,o,r,s,!1),v)_||fi(t,a,j,c,1);else if((t.props&&t.props.to)!==(e.props&&e.props.to)){const J=t.target=qo(t.props,p);J&&fi(t,J,null,c,0)}else _&&fi(t,x,y,c,1)}},remove(e,t,a,n,{um:i,o:{remove:o}},r){const{shapeFlag:s,children:l,anchor:c,targetAnchor:u,target:h,props:m}=e;if(h&&o(u),(r||!An(m))&&(o(c),s&16))for(let f=0;f<l.length;f++){const p=l[f];i(p,t,a,!0,!!p.dynamicChildren)}},move:fi,hydrate:hf};function fi(e,t,a,{o:{insert:n},m:i},o=2){o===0&&n(e.targetAnchor,t,a);const{el:r,anchor:s,shapeFlag:l,children:c,props:u}=e,h=o===2;if(h&&n(r,t,a),(!h||An(u))&&l&16)for(let m=0;m<c.length;m++)i(c[m],t,a,2);h&&n(s,t,a)}function hf(e,t,a,n,i,o,{o:{nextSibling:r,parentNode:s,querySelector:l}},c){const u=t.target=qo(t.props,l);if(u){const h=u._lpa||u.firstChild;if(t.shapeFlag&16)if(An(t.props))t.anchor=c(r(e),t,s(e),a,n,i,o),t.targetAnchor=h;else{t.anchor=r(e);let m=h;for(;m;)if(m=r(m),m&&m.nodeType===8&&m.data==="teleport anchor"){t.targetAnchor=m,u._lpa=t.targetAnchor&&r(t.targetAnchor);break}c(h,t,u,a,n,i,o)}}return t.anchor&&r(t.anchor)}const mf=df,pe=Symbol(void 0),Nr=Symbol(void 0),Ot=Symbol(void 0),_o=Symbol(void 0),Mn=[];let _t=null;function pi(e=!1){Mn.push(_t=e?null:[])}function ff(){Mn.pop(),_t=Mn[Mn.length-1]||null}let On=1;function Us(e){On+=e}function Yc(e){return e.dynamicChildren=On>0?_t||Ya:null,ff(),On>0&&_t&&_t.push(e),e}function Ws(e,t,a,n,i,o){return Yc(io(e,t,a,n,i,o,!0))}function qs(e,t,a,n,i){return Yc(d(e,t,a,n,i,!0))}function Ko(e){return e?e.__v_isVNode===!0:!1}function xa(e,t){return e.type===t.type&&e.key===t.key}const no="__vInternal",Xc=({key:e})=>e!=null?e:null,_i=({ref:e,ref_key:t,ref_for:a})=>e!=null?Ve(e)||Ae(e)||ue(e)?{i:pt,r:e,k:t,f:!!a}:e:null;function io(e,t=null,a=null,n=0,i=null,o=e===pe?0:1,r=!1,s=!1){const l={__v_isVNode:!0,__v_skip:!0,type:e,props:t,key:t&&Xc(t),ref:t&&_i(t),scopeId:Zi,slotScopeIds:null,children:a,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:o,patchFlag:n,dynamicProps:i,dynamicChildren:null,appContext:null};return s?($r(l,a),o&128&&e.normalize(l)):a&&(l.shapeFlag|=Ve(a)?8:16),On>0&&!r&&_t&&(l.patchFlag>0||o&6)&&l.patchFlag!==32&&_t.push(l),l}const d=pf;function pf(e,t=null,a=null,n=0,i=null,o=!1){if((!e||e===zc)&&(e=Ot),Ko(e)){const s=ca(e,t,!0);return a&&$r(s,a),On>0&&!o&&_t&&(s.shapeFlag&6?_t[_t.indexOf(e)]=s:_t.push(s)),s.patchFlag|=-2,s}if(Tf(e)&&(e=e.__vccOpts),t){t=gf(t);let{class:s,style:l}=t;s&&!Ve(s)&&(t.class=Ui(s)),De(l)&&(pc(l)&&!ie(l)&&(l=$e({},l)),t.style=$i(l))}const r=Ve(e)?1:Bm(e)?128:uf(e)?64:De(e)?4:ue(e)?2:0;return io(e,t,a,n,i,r,o,!0)}function gf(e){return e?pc(e)||no in e?$e({},e):e:null}function ca(e,t,a=!1){const{props:n,ref:i,patchFlag:o,children:r}=e,s=t?oe(n||{},t):n;return{__v_isVNode:!0,__v_skip:!0,type:e.type,props:s,key:s&&Xc(s),ref:t&&t.ref?a&&i?ie(i)?i.concat(_i(t)):[i,_i(t)]:_i(t):i,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:r,target:e.target,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:t&&e.type!==pe?o===-1?16:o|16:o,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:e.transition,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&ca(e.ssContent),ssFallback:e.ssFallback&&ca(e.ssFallback),el:e.el,anchor:e.anchor}}function ei(e=" ",t=0){return d(Nr,null,e,t)}function Mt(e){return e==null||typeof e=="boolean"?d(Ot):ie(e)?d(pe,null,e.slice()):typeof e=="object"?oa(e):d(Nr,null,String(e))}function oa(e){return e.el===null||e.memo?e:ca(e)}function $r(e,t){let a=0;const{shapeFlag:n}=e;if(t==null)t=null;else if(ie(t))a=16;else if(typeof t=="object")if(n&65){const i=t.default;i&&(i._c&&(i._d=!1),$r(e,i()),i._c&&(i._d=!0));return}else{a=32;const i=t._;!i&&!(no in t)?t._ctx=pt:i===3&&pt&&(pt.slots._===1?t._=1:(t._=2,e.patchFlag|=1024))}else ue(t)?(t={default:t,_ctx:pt},a=32):(t=String(t),n&64?(a=16,t=[ei(t)]):a=8);e.children=t,e.shapeFlag|=a}function oe(...e){const t={};for(let a=0;a<e.length;a++){const n=e[a];for(const i in n)if(i==="class")t.class!==n.class&&(t.class=Ui([t.class,n.class]));else if(i==="style")t.style=$i([t.style,n.style]);else if(Wi(i)){const o=t[i],r=n[i];r&&o!==r&&!(ie(o)&&o.includes(r))&&(t[i]=o?[].concat(o,r):r)}else i!==""&&(t[i]=n[i])}return t}function At(e,t,a,n=null){gt(e,t,7,[a,n])}const vf=Kc();let bf=0;function yf(e,t,a){const n=e.type,i=(t?t.appContext:e.appContext)||vf,o={uid:bf++,vnode:e,type:n,parent:t,appContext:i,root:null,next:null,subTree:null,effect:null,update:null,scope:new nc(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(i.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:$c(n,i),emitsOptions:Pc(n,i),emit:null,emitted:null,propsDefaults:_e,inheritAttrs:n.inheritAttrs,ctx:_e,data:_e,props:_e,attrs:_e,slots:_e,refs:_e,setupState:_e,setupContext:null,suspense:a,suspenseId:a?a.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return o.ctx={_:o},o.root=t?t.root:o,o.emit=Im.bind(null,o),e.ce&&e.ce(o),o}let Ne=null;const oo=()=>Ne||pt,en=e=>{Ne=e,e.scope.on()},Ia=()=>{Ne&&Ne.scope.off(),Ne=null};function Qc(e){return e.vnode.shapeFlag&4}let Gn=!1;function wf(e,t=!1){Gn=t;const{props:a,children:n}=e.vnode,i=Qc(e);Zm(e,a,i,t),af(e,n);const o=i?kf(e,t):void 0;return Gn=!1,o}function kf(e,t){const a=e.type;e.accessCache=Object.create(null),e.proxy=gc(new Proxy(e.ctx,Wm));const{setup:n}=a;if(n){const i=e.setupContext=n.length>1?Cf(e):null;en(e),Da();const o=Ht(n,e,0,[e.props,i]);if(Ea(),Ia(),ec(o)){if(o.then(Ia,Ia),t)return o.then(r=>{Ks(e,r,t)}).catch(r=>{Yi(r,e,0)});e.asyncDep=o}else Ks(e,o,t)}else Zc(e,t)}function Ks(e,t,a){ue(t)?e.type.__ssrInlineRender?e.ssrRender=t:e.render=t:De(t)&&(e.setupState=wc(t)),Zc(e,a)}let Ys;function Zc(e,t,a){const n=e.type;if(!e.render){if(!t&&Ys&&!n.render){const i=n.template;if(i){const{isCustomElement:o,compilerOptions:r}=e.appContext.config,{delimiters:s,compilerOptions:l}=n,c=$e($e({isCustomElement:o,delimiters:s},r),l);n.render=Ys(i,c)}}e.render=n.render||jt}en(e),Da(),qm(e),Ea(),Ia()}function xf(e){return new Proxy(e.attrs,{get(t,a){return st(e,"get","$attrs"),t[a]}})}function Cf(e){const t=n=>{e.exposed=n||{}};let a;return{get attrs(){return a||(a=xf(e))},slots:e.slots,emit:e.emit,expose:t}}function ro(e){if(e.exposed)return e.exposeProxy||(e.exposeProxy=new Proxy(wc(gc(e.exposed)),{get(t,a){if(a in t)return t[a];if(a in Mi)return Mi[a](e)}}))}const Sf=/(?:^|[-_])(\w)/g,_f=e=>e.replace(Sf,t=>t.toUpperCase()).replace(/[-_]/g,"");function eu(e,t=!0){return ue(e)?e.displayName||e.name:e.name||t&&e.__name}function tu(e,t,a=!1){let n=eu(t);if(!n&&t.__file){const i=t.__file.match(/([^/\\]+)\.\w+$/);i&&(n=i[1])}if(!n&&e&&e.parent){const i=o=>{for(const r in o)if(o[r]===t)return r};n=i(e.components||e.parent.type.components)||i(e.appContext.components)}return n?_f(n):a?"App":"Anonymous"}function Tf(e){return ue(e)&&"__vccOpts"in e}const g=(e,t)=>bm(e,t,Gn);function Wt(e,t,a){const n=arguments.length;return n===2?De(t)&&!ie(t)?Ko(t)?d(e,null,[t]):d(e,t):d(e,null,t):(n>3?a=Array.prototype.slice.call(arguments,2):n===3&&Ko(a)&&(a=[a]),d(e,t,a))}const jf="3.2.37",Pf="http://www.w3.org/2000/svg",Ca=typeof document<"u"?document:null,Xs=Ca&&Ca.createElement("template"),If={insert:(e,t,a)=>{t.insertBefore(e,a||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,a,n)=>{const i=t?Ca.createElementNS(Pf,e):Ca.createElement(e,a?{is:a}:void 0);return e==="select"&&n&&n.multiple!=null&&i.setAttribute("multiple",n.multiple),i},createText:e=>Ca.createTextNode(e),createComment:e=>Ca.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>Ca.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},cloneNode(e){const t=e.cloneNode(!0);return"_value"in e&&(t._value=e._value),t},insertStaticContent(e,t,a,n,i,o){const r=a?a.previousSibling:t.lastChild;if(i&&(i===o||i.nextSibling))for(;t.insertBefore(i.cloneNode(!0),a),!(i===o||!(i=i.nextSibling)););else{Xs.innerHTML=n?`<svg>${e}</svg>`:e;const s=Xs.content;if(n){const l=s.firstChild;for(;l.firstChild;)s.appendChild(l.firstChild);s.removeChild(l)}t.insertBefore(s,a)}return[r?r.nextSibling:t.firstChild,a?a.previousSibling:t.lastChild]}};function Af(e,t,a){const n=e._vtc;n&&(t=(t?[t,...n]:[...n]).join(" ")),t==null?e.removeAttribute("class"):a?e.setAttribute("class",t):e.className=t}function Mf(e,t,a){const n=e.style,i=Ve(a);if(a&&!i){for(const o in a)Yo(n,o,a[o]);if(t&&!Ve(t))for(const o in t)a[o]==null&&Yo(n,o,"")}else{const o=n.display;i?t!==a&&(n.cssText=a):t&&e.removeAttribute("style"),"_vod"in e&&(n.display=o)}}const Qs=/\s*!important$/;function Yo(e,t,a){if(ie(a))a.forEach(n=>Yo(e,t,n));else if(a==null&&(a=""),t.startsWith("--"))e.setProperty(t,a);else{const n=Jf(e,t);Qs.test(a)?e.setProperty(on(n),a.replace(Qs,""),"important"):e[n]=a}}const Zs=["Webkit","Moz","ms"],To={};function Jf(e,t){const a=To[t];if(a)return a;let n=bt(t);if(n!=="filter"&&n in e)return To[t]=n;n=ha(n);for(let i=0;i<Zs.length;i++){const o=Zs[i]+n;if(o in e)return To[t]=o}return t}const el="http://www.w3.org/1999/xlink";function Lf(e,t,a,n,i){if(n&&t.startsWith("xlink:"))a==null?e.removeAttributeNS(el,t.slice(6,t.length)):e.setAttributeNS(el,t,a);else{const o=Ph(t);a==null||o&&!Ql(a)?e.removeAttribute(t):e.setAttribute(t,o?"":a)}}function Df(e,t,a,n,i,o,r){if(t==="innerHTML"||t==="textContent"){n&&r(n,i,o),e[t]=a==null?"":a;return}if(t==="value"&&e.tagName!=="PROGRESS"&&!e.tagName.includes("-")){e._value=a;const l=a==null?"":a;(e.value!==l||e.tagName==="OPTION")&&(e.value=l),a==null&&e.removeAttribute(t);return}let s=!1;if(a===""||a==null){const l=typeof e[t];l==="boolean"?a=Ql(a):a==null&&l==="string"?(a="",s=!0):l==="number"&&(a=0,s=!0)}try{e[t]=a}catch{}s&&e.removeAttribute(t)}const[au,Ef]=(()=>{let e=Date.now,t=!1;if(typeof window<"u"){Date.now()>document.createEvent("Event").timeStamp&&(e=performance.now.bind(performance));const a=navigator.userAgent.match(/firefox\/(\d+)/i);t=!!(a&&Number(a[1])<=53)}return[e,t]})();let Xo=0;const Bf=Promise.resolve(),Ff=()=>{Xo=0},Rf=()=>Xo||(Bf.then(Ff),Xo=au());function zt(e,t,a,n){e.addEventListener(t,a,n)}function Vf(e,t,a,n){e.removeEventListener(t,a,n)}function zf(e,t,a,n,i=null){const o=e._vei||(e._vei={}),r=o[t];if(n&&r)r.value=n;else{const[s,l]=Hf(t);if(n){const c=o[t]=Of(n,i);zt(e,s,c,l)}else r&&(Vf(e,s,r,l),o[t]=void 0)}}const tl=/(?:Once|Passive|Capture)$/;function Hf(e){let t;if(tl.test(e)){t={};let a;for(;a=e.match(tl);)e=e.slice(0,e.length-a[0].length),t[a[0].toLowerCase()]=!0}return[on(e.slice(2)),t]}function Of(e,t){const a=n=>{const i=n.timeStamp||au();(Ef||i>=a.attached-1)&&gt(Gf(n,a.value),t,5,[n])};return a.value=e,a.attached=Rf(),a}function Gf(e,t){if(ie(t)){const a=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{a.call(e),e._stopped=!0},t.map(n=>i=>!i._stopped&&n&&n(i))}else return t}const al=/^on[a-z]/,Nf=(e,t,a,n,i=!1,o,r,s,l)=>{t==="class"?Af(e,n,i):t==="style"?Mf(e,a,n):Wi(t)?jr(t)||zf(e,t,a,n,r):(t[0]==="."?(t=t.slice(1),!0):t[0]==="^"?(t=t.slice(1),!1):$f(e,t,n,i))?Df(e,t,n,o,r,s,l):(t==="true-value"?e._trueValue=n:t==="false-value"&&(e._falseValue=n),Lf(e,t,n,i))};function $f(e,t,a,n){return n?!!(t==="innerHTML"||t==="textContent"||t in e&&al.test(t)&&ue(a)):t==="spellcheck"||t==="draggable"||t==="translate"||t==="form"||t==="list"&&e.tagName==="INPUT"||t==="type"&&e.tagName==="TEXTAREA"||al.test(t)&&Ve(a)?!1:t in e}const ta="transition",kn="animation",Dt=(e,{slots:t})=>Wt(Mc,iu(e),t);Dt.displayName="Transition";const nu={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},Uf=Dt.props=$e({},Mc.props,nu),ba=(e,t=[])=>{ie(e)?e.forEach(a=>a(...t)):e&&e(...t)},nl=e=>e?ie(e)?e.some(t=>t.length>1):e.length>1:!1;function iu(e){const t={};for(const T in e)T in nu||(t[T]=e[T]);if(e.css===!1)return t;const{name:a="v",type:n,duration:i,enterFromClass:o=`${a}-enter-from`,enterActiveClass:r=`${a}-enter-active`,enterToClass:s=`${a}-enter-to`,appearFromClass:l=o,appearActiveClass:c=r,appearToClass:u=s,leaveFromClass:h=`${a}-leave-from`,leaveActiveClass:m=`${a}-leave-active`,leaveToClass:f=`${a}-leave-to`}=e,p=Wf(i),b=p&&p[0],w=p&&p[1],{onBeforeEnter:v,onEnter:S,onEnterCancelled:k,onLeave:P,onLeaveCancelled:j,onBeforeAppear:x=v,onAppear:y=S,onAppearCancelled:_=k}=t,M=(T,L,B)=>{ia(T,L?u:s),ia(T,L?c:r),B&&B()},I=(T,L)=>{T._isLeaving=!1,ia(T,h),ia(T,f),ia(T,m),L&&L()},J=T=>(L,B)=>{const F=T?y:S,$=()=>M(L,T,B);ba(F,[L,$]),il(()=>{ia(L,T?l:o),Rt(L,T?u:s),nl(F)||ol(L,n,b,$)})};return $e(t,{onBeforeEnter(T){ba(v,[T]),Rt(T,o),Rt(T,r)},onBeforeAppear(T){ba(x,[T]),Rt(T,l),Rt(T,c)},onEnter:J(!1),onAppear:J(!0),onLeave(T,L){T._isLeaving=!0;const B=()=>I(T,L);Rt(T,h),ru(),Rt(T,m),il(()=>{!T._isLeaving||(ia(T,h),Rt(T,f),nl(P)||ol(T,n,w,B))}),ba(P,[T,B])},onEnterCancelled(T){M(T,!1),ba(k,[T])},onAppearCancelled(T){M(T,!0),ba(_,[T])},onLeaveCancelled(T){I(T),ba(j,[T])}})}function Wf(e){if(e==null)return null;if(De(e))return[jo(e.enter),jo(e.leave)];{const t=jo(e);return[t,t]}}function jo(e){return Bn(e)}function Rt(e,t){t.split(/\s+/).forEach(a=>a&&e.classList.add(a)),(e._vtc||(e._vtc=new Set)).add(t)}function ia(e,t){t.split(/\s+/).forEach(n=>n&&e.classList.remove(n));const{_vtc:a}=e;a&&(a.delete(t),a.size||(e._vtc=void 0))}function il(e){requestAnimationFrame(()=>{requestAnimationFrame(e)})}let qf=0;function ol(e,t,a,n){const i=e._endId=++qf,o=()=>{i===e._endId&&n()};if(a)return setTimeout(o,a);const{type:r,timeout:s,propCount:l}=ou(e,t);if(!r)return n();const c=r+"end";let u=0;const h=()=>{e.removeEventListener(c,m),o()},m=f=>{f.target===e&&++u>=l&&h()};setTimeout(()=>{u<l&&h()},s+1),e.addEventListener(c,m)}function ou(e,t){const a=window.getComputedStyle(e),n=p=>(a[p]||"").split(", "),i=n(ta+"Delay"),o=n(ta+"Duration"),r=rl(i,o),s=n(kn+"Delay"),l=n(kn+"Duration"),c=rl(s,l);let u=null,h=0,m=0;t===ta?r>0&&(u=ta,h=r,m=o.length):t===kn?c>0&&(u=kn,h=c,m=l.length):(h=Math.max(r,c),u=h>0?r>c?ta:kn:null,m=u?u===ta?o.length:l.length:0);const f=u===ta&&/\b(transform|all)(,|$)/.test(a[ta+"Property"]);return{type:u,timeout:h,propCount:m,hasTransform:f}}function rl(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max(...t.map((a,n)=>sl(a)+sl(e[n])))}function sl(e){return Number(e.slice(0,-1).replace(",","."))*1e3}function ru(){return document.body.offsetHeight}const su=new WeakMap,lu=new WeakMap,Kf={name:"TransitionGroup",props:$e({},Uf,{tag:String,moveClass:String}),setup(e,{slots:t}){const a=oo(),n=Ac();let i,o;return Fc(()=>{if(!i.length)return;const r=e.moveClass||`${e.name||"v"}-move`;if(!ep(i[0].el,a.vnode.el,r))return;i.forEach(Xf),i.forEach(Qf);const s=i.filter(Zf);ru(),s.forEach(l=>{const c=l.el,u=c.style;Rt(c,r),u.transform=u.webkitTransform=u.transitionDuration="";const h=c._moveCb=m=>{m&&m.target!==c||(!m||/transform$/.test(m.propertyName))&&(c.removeEventListener("transitionend",h),c._moveCb=null,ia(c,r))};c.addEventListener("transitionend",h)})}),()=>{const r=ge(e),s=iu(r);let l=r.tag||pe;i=o,o=t.default?zr(t.default()):[];for(let c=0;c<o.length;c++){const u=o[c];u.key!=null&&Hn(u,zn(u,s,n,a))}if(i)for(let c=0;c<i.length;c++){const u=i[c];Hn(u,zn(u,s,n,a)),su.set(u,u.el.getBoundingClientRect())}return d(l,null,o)}}},Yf=Kf;function Xf(e){const t=e.el;t._moveCb&&t._moveCb(),t._enterCb&&t._enterCb()}function Qf(e){lu.set(e,e.el.getBoundingClientRect())}function Zf(e){const t=su.get(e),a=lu.get(e),n=t.left-a.left,i=t.top-a.top;if(n||i){const o=e.el.style;return o.transform=o.webkitTransform=`translate(${n}px,${i}px)`,o.transitionDuration="0s",e}}function ep(e,t,a){const n=e.cloneNode();e._vtc&&e._vtc.forEach(r=>{r.split(/\s+/).forEach(s=>s&&n.classList.remove(s))}),a.split(/\s+/).forEach(r=>r&&n.classList.add(r)),n.style.display="none";const i=t.nodeType===1?t:t.parentNode;i.appendChild(n);const{hasTransform:o}=ou(n);return i.removeChild(n),o}const ua=e=>{const t=e.props["onUpdate:modelValue"]||!1;return ie(t)?a=>Ci(t,a):t};function tp(e){e.target.composing=!0}function ll(e){const t=e.target;t.composing&&(t.composing=!1,t.dispatchEvent(new Event("input")))}const Li={created(e,{modifiers:{lazy:t,trim:a,number:n}},i){e._assign=ua(i);const o=n||i.props&&i.props.type==="number";zt(e,t?"change":"input",r=>{if(r.target.composing)return;let s=e.value;a&&(s=s.trim()),o&&(s=Bn(s)),e._assign(s)}),a&&zt(e,"change",()=>{e.value=e.value.trim()}),t||(zt(e,"compositionstart",tp),zt(e,"compositionend",ll),zt(e,"change",ll))},mounted(e,{value:t}){e.value=t==null?"":t},beforeUpdate(e,{value:t,modifiers:{lazy:a,trim:n,number:i}},o){if(e._assign=ua(o),e.composing||document.activeElement===e&&e.type!=="range"&&(a||n&&e.value.trim()===t||(i||e.type==="number")&&Bn(e.value)===t))return;const r=t==null?"":t;e.value!==r&&(e.value=r)}},ap={deep:!0,created(e,t,a){e._assign=ua(a),zt(e,"change",()=>{const n=e._modelValue,i=tn(e),o=e.checked,r=e._assign;if(ie(n)){const s=Tr(n,i),l=s!==-1;if(o&&!l)r(n.concat(i));else if(!o&&l){const c=[...n];c.splice(s,1),r(c)}}else if(nn(n)){const s=new Set(n);o?s.add(i):s.delete(i),r(s)}else r(cu(e,o))})},mounted:cl,beforeUpdate(e,t,a){e._assign=ua(a),cl(e,t,a)}};function cl(e,{value:t,oldValue:a},n){e._modelValue=t,ie(t)?e.checked=Tr(t,n.props.value)>-1:nn(t)?e.checked=t.has(n.props.value):t!==a&&(e.checked=Ma(t,cu(e,!0)))}const np={created(e,{value:t},a){e.checked=Ma(t,a.props.value),e._assign=ua(a),zt(e,"change",()=>{e._assign(tn(e))})},beforeUpdate(e,{value:t,oldValue:a},n){e._assign=ua(n),t!==a&&(e.checked=Ma(t,n.props.value))}},ip={deep:!0,created(e,{value:t,modifiers:{number:a}},n){const i=nn(t);zt(e,"change",()=>{const o=Array.prototype.filter.call(e.options,r=>r.selected).map(r=>a?Bn(tn(r)):tn(r));e._assign(e.multiple?i?new Set(o):o:o[0])}),e._assign=ua(n)},mounted(e,{value:t}){ul(e,t)},beforeUpdate(e,t,a){e._assign=ua(a)},updated(e,{value:t}){ul(e,t)}};function ul(e,t){const a=e.multiple;if(!(a&&!ie(t)&&!nn(t))){for(let n=0,i=e.options.length;n<i;n++){const o=e.options[n],r=tn(o);if(a)ie(t)?o.selected=Tr(t,r)>-1:o.selected=t.has(r);else if(Ma(tn(o),t)){e.selectedIndex!==n&&(e.selectedIndex=n);return}}!a&&e.selectedIndex!==-1&&(e.selectedIndex=-1)}}function tn(e){return"_value"in e?e._value:e.value}function cu(e,t){const a=t?"_trueValue":"_falseValue";return a in e?e[a]:t}const uu={created(e,t,a){gi(e,t,a,null,"created")},mounted(e,t,a){gi(e,t,a,null,"mounted")},beforeUpdate(e,t,a,n){gi(e,t,a,n,"beforeUpdate")},updated(e,t,a,n){gi(e,t,a,n,"updated")}};function op(e,t){switch(e){case"SELECT":return ip;case"TEXTAREA":return Li;default:switch(t){case"checkbox":return ap;case"radio":return np;default:return Li}}}function gi(e,t,a,n,i){const r=op(e.tagName,a.props&&a.props.type)[i];r&&r(e,t,a,n)}const Et={beforeMount(e,{value:t},{transition:a}){e._vod=e.style.display==="none"?"":e.style.display,a&&t?a.beforeEnter(e):xn(e,t)},mounted(e,{value:t},{transition:a}){a&&t&&a.enter(e)},updated(e,{value:t,oldValue:a},{transition:n}){!t!=!a&&(n?t?(n.beforeEnter(e),xn(e,!0),n.enter(e)):n.leave(e,()=>{xn(e,!1)}):xn(e,t))},beforeUnmount(e,{value:t}){xn(e,t)}};function xn(e,t){e.style.display=t?e._vod:"none"}const rp=$e({patchProp:Nf},If);let dl;function sp(){return dl||(dl=sf(rp))}const lp=(...e)=>{const t=sp().createApp(...e),{mount:a}=t;return t.mount=n=>{const i=cp(n);if(!i)return;const o=t._component;!ue(o)&&!o.render&&!o.template&&(o.template=i.innerHTML),i.innerHTML="";const r=a(i,!1,i instanceof SVGElement);return i instanceof Element&&(i.removeAttribute("v-cloak"),i.setAttribute("data-v-app","")),r},t};function cp(e){return Ve(e)?document.querySelector(e):e}function hl(e,t,a){up(e,t),t.set(e,a)}function up(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}function dp(e,t,a){var n=du(e,t,"set");return hp(e,n,a),a}function hp(e,t,a){if(t.set)t.set.call(e,a);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=a}}function ya(e,t){var a=du(e,t,"get");return mp(e,a)}function du(e,t,a){if(!t.has(e))throw new TypeError("attempted to "+a+" private field on non-instance");return t.get(e)}function mp(e,t){return t.get?t.get.call(e):t.value}function hu(e,t,a){const n=t.length-1;if(n<0)return e===void 0?a:e;for(let i=0;i<n;i++){if(e==null)return a;e=e[t[i]]}return e==null||e[t[n]]===void 0?a:e[t[n]]}function ti(e,t){if(e===t)return!0;if(e instanceof Date&&t instanceof Date&&e.getTime()!==t.getTime()||e!==Object(e)||t!==Object(t))return!1;const a=Object.keys(e);return a.length!==Object.keys(t).length?!1:a.every(n=>ti(e[n],t[n]))}function Qo(e,t,a){return e==null||!t||typeof t!="string"?a:e[t]!==void 0?e[t]:(t=t.replace(/\[(\w+)\]/g,".$1"),t=t.replace(/^\./,""),hu(e,t.split("."),a))}function Jt(e,t,a){if(t==null)return e===void 0?a:e;if(e!==Object(e))return a;if(typeof t=="string")return Qo(e,t,a);if(Array.isArray(t))return hu(e,t,a);if(typeof t!="function")return a;const n=t(e,a);return typeof n>"u"?a:n}function _a(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;return Array.from({length:e},(a,n)=>t+n)}function Q(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"px";if(!(e==null||e===""))return isNaN(+e)?String(e):isFinite(+e)?`${Number(e)}${t}`:void 0}function Zo(e){return e!==null&&typeof e=="object"&&!Array.isArray(e)}function fp(e){return e==null?void 0:e.$el}const ml=Object.freeze({enter:13,tab:9,delete:46,esc:27,space:32,up:38,down:40,left:37,right:39,end:35,home:36,del:46,backspace:8,insert:45,pageup:33,pagedown:34,shift:16}),er=Object.freeze({enter:"Enter",tab:"Tab",delete:"Delete",esc:"Escape",space:"Space",up:"ArrowUp",down:"ArrowDown",left:"ArrowLeft",right:"ArrowRight",end:"End",home:"Home",del:"Delete",backspace:"Backspace",insert:"Insert",pageup:"PageUp",pagedown:"PageDown",shift:"Shift"});function mu(e){return Object.keys(e)}function Bt(e,t){const a=Object.create(null),n=Object.create(null);for(const i in e)t.some(o=>o instanceof RegExp?o.test(i):o===i)?a[i]=e[i]:n[i]=e[i];return[a,n]}function Ba(e){return Bt(e,["class","style","id",/^data-/])}function vt(e){return e==null?[]:Array.isArray(e)?e:[e]}function Lt(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:1;return Math.max(t,Math.min(a,e))}function Po(e,t){let a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:"0";return e+a.repeat(Math.max(0,t-e.length))}function pp(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1;const a=[];let n=0;for(;n<e.length;)a.push(e.substr(n,t)),n+=t;return a}function fl(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1e3;if(e<t)return`${e} B`;const a=t===1024?["Ki","Mi","Gi"]:["k","M","G"];let n=-1;for(;Math.abs(e)>=t&&n<a.length-1;)e/=t,++n;return`${e.toFixed(1)} ${a[n]}B`}function da(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},a=arguments.length>2?arguments[2]:void 0;const n={};for(const i in e)n[i]=e[i];for(const i in t){const o=e[i],r=t[i];if(Zo(o)&&Zo(r)){n[i]=da(o,r,a);continue}if(Array.isArray(o)&&Array.isArray(r)&&a){n[i]=a(o,r);continue}n[i]=r}return n}function fu(e){return e.map(t=>t.type===pe?fu(t.children):t).flat()}function Ur(){return(arguments.length>0&&arguments[0]!==void 0?arguments[0]:"").replace(/[^a-z]/gi,"-").replace(/\B([A-Z])/g,"-$1").toLowerCase()}function Jn(e,t){if(!t||typeof t!="object")return[];if(Array.isArray(t))return t.map(a=>Jn(e,a)).flat(1);if(Array.isArray(t.children))return t.children.map(a=>Jn(e,a)).flat(1);if(t.component){if(Object.getOwnPropertySymbols(t.component.provides).includes(e))return[t.component];if(t.component.subTree)return Jn(e,t.component.subTree).flat(1)}return[]}var vi=new WeakMap,Ga=new WeakMap;class gp{constructor(t){hl(this,vi,{writable:!0,value:[]}),hl(this,Ga,{writable:!0,value:0}),this.size=t}push(t){ya(this,vi)[ya(this,Ga)]=t,dp(this,Ga,(ya(this,Ga)+1)%this.size)}values(){return ya(this,vi).slice(ya(this,Ga)).concat(ya(this,vi).slice(0,ya(this,Ga)))}}function vp(e){return"touches"in e?{clientX:e.touches[0].clientX,clientY:e.touches[0].clientY}:{clientX:e.clientX,clientY:e.clientY}}function bp(e){return Fr(tt({value:g(e)}).value)}function tr(e,t){return e.includes(t)}const Di=Symbol.for("vuetify:defaults");function yp(e){return D(e!=null?e:{})}function pu(){const e=we(Di);if(!e)throw new Error("[Vuetify] Could not find defaults instance");return e}function Ue(e,t){const a=pu(),n=D(e),i=g(()=>{const o=sa(t==null?void 0:t.scoped),r=sa(t==null?void 0:t.reset),s=sa(t==null?void 0:t.root);let l=da(n.value,{prev:a.value});if(o)return l;if(r||s){const c=Number(r||1/0);for(let u=0;u<=c&&l.prev;u++)l=l.prev;return l}return da(l.prev,l)});return Oe(Di,i),i}const gu=["top","bottom"],wp=["start","end","left","right"];function ar(e,t){let[a,n]=e.split(" ");return n||(n=tr(gu,a)?"start":tr(wp,a)?"top":"center"),{side:pl(a,t),align:pl(n,t)}}function pl(e,t){return e==="start"?t?"right":"left":e==="end"?t?"left":"right":e}function Io(e){return{side:{center:"center",top:"bottom",bottom:"top",left:"right",right:"left"}[e.side],align:e.align}}function Ao(e){return{side:e.side,align:{center:"center",top:"bottom",bottom:"top",left:"right",right:"left"}[e.align]}}function gl(e){return{side:e.align,align:e.side}}function vl(e){return tr(gu,e.side)?"y":"x"}class Za{constructor(t){let{x:a,y:n,width:i,height:o}=t;this.x=a,this.y=n,this.width=i,this.height=o}get top(){return this.y}get bottom(){return this.y+this.height}get left(){return this.x}get right(){return this.x+this.width}}function bl(e,t){return{x:{before:Math.max(0,t.left-e.left),after:Math.max(0,e.right-t.right)},y:{before:Math.max(0,t.top-e.top),after:Math.max(0,e.bottom-t.bottom)}}}function Wr(e){const t=e.getBoundingClientRect(),a=getComputedStyle(e),n=a.transform;if(n){let i,o,r,s,l;if(n.startsWith("matrix3d("))i=n.slice(9,-1).split(/, /),o=+i[0],r=+i[5],s=+i[12],l=+i[13];else if(n.startsWith("matrix("))i=n.slice(7,-1).split(/, /),o=+i[0],r=+i[3],s=+i[4],l=+i[5];else return new Za(t);const c=a.transformOrigin,u=t.x-s-(1-o)*parseFloat(c),h=t.y-l-(1-r)*parseFloat(c.slice(c.indexOf(" ")+1)),m=o?t.width/o:e.offsetWidth+1,f=r?t.height/r:e.offsetHeight+1;return new Za({x:u,y:h,width:m,height:f})}else return new Za(t)}function vu(e,t,a){if(a&&(t={_isVue:!0,$parent:a,$options:t}),t){if(t.$_alreadyWarned=t.$_alreadyWarned||[],t.$_alreadyWarned.includes(e))return;t.$_alreadyWarned.push(e)}return`[Vuetify] ${e}`+(t?Cp(t):"")}function Aa(e,t,a){const n=vu(e,t,a);n!=null&&console.warn(n)}function nr(e,t,a){const n=vu(e,t,a);n!=null&&console.error(n)}const kp=/(?:^|[-_])(\w)/g,xp=e=>e.replace(kp,t=>t.toUpperCase()).replace(/[-_]/g,"");function Mo(e,t){if(e.$root===e)return"<Root>";const a=typeof e=="function"&&e.cid!=null?e.options:e._isVue?e.$options||e.constructor.options:e||{};let n=a.name||a._componentTag;const i=a.__file;if(!n&&i){const o=i.match(/([^/\\]+)\.vue$/);n=o==null?void 0:o[1]}return(n?`<${xp(n)}>`:"<Anonymous>")+(i&&t!==!1?` at ${i}`:"")}function Cp(e){if(e._isVue&&e.$parent){const t=[];let a=0;for(;e;){if(t.length>0){const n=t[t.length-1];if(n.constructor===e.constructor){a++,e=e.$parent;continue}else a>0&&(t[t.length-1]=[n,a],a=0)}t.push(e),e=e.$parent}return`

found in

`+t.map((n,i)=>`${i===0?"---> ":" ".repeat(5+i*2)}${Array.isArray(n)?`${Mo(n[0])}... (${n[1]} recursive calls)`:Mo(n)}`).join(`
`)}else return`

(found in ${Mo(e)})`}const Sp=[[3.2406,-1.5372,-.4986],[-.9689,1.8758,.0415],[.0557,-.204,1.057]],_p=e=>e<=.0031308?e*12.92:1.055*e**(1/2.4)-.055,Tp=[[.4124,.3576,.1805],[.2126,.7152,.0722],[.0193,.1192,.9505]],jp=e=>e<=.04045?e/12.92:((e+.055)/1.055)**2.4;function bu(e){const t=Array(3),a=_p,n=Sp;for(let i=0;i<3;++i)t[i]=Math.round(Lt(a(n[i][0]*e[0]+n[i][1]*e[1]+n[i][2]*e[2]))*255);return(t[0]<<16)+(t[1]<<8)+(t[2]<<0)}function qr(e){const t=[0,0,0],a=jp,n=Tp,i=a((e>>16&255)/255),o=a((e>>8&255)/255),r=a((e>>0&255)/255);for(let s=0;s<3;++s)t[s]=n[s][0]*i+n[s][1]*o+n[s][2]*r;return t}const Ei=.20689655172413793,Pp=e=>e>Ei**3?Math.cbrt(e):e/(3*Ei**2)+4/29,Ip=e=>e>Ei?e**3:3*Ei**2*(e-4/29);function yu(e){const t=Pp,a=t(e[1]);return[116*a-16,500*(t(e[0]/.95047)-a),200*(a-t(e[2]/1.08883))]}function wu(e){const t=Ip,a=(e[0]+16)/116;return[t(a+e[1]/500)*.95047,t(a),t(a-e[2]/200)*1.08883]}function yl(e){return!!e&&/^(#|var\(--|(rgb|hsl)a?\()/.test(e)}function Bi(e){let t;if(typeof e=="number")t=e;else if(typeof e=="string"){let a=e.startsWith("#")?e.substring(1):e;a.length===3&&(a=a.split("").map(n=>n+n).join("")),a.length!==6&&Aa(`'${e}' is not a valid rgb color`),t=parseInt(a,16)}else throw new TypeError(`Colors can only be numbers or strings, recieved ${e==null?e:e.constructor.name} instead`);return t<0?(Aa(`Colors cannot be negative: '${e}'`),t=0):(t>16777215||isNaN(t))&&(Aa(`'${e}' is not a valid rgb color`),t=16777215),t}function Ap(e){let t=e.toString(16);return t.length<6&&(t="0".repeat(6-t.length)+t),"#"+t}function so(e){const{h:t,s:a,v:n,a:i}=e,o=s=>{const l=(s+t/60)%6;return n-n*a*Math.max(Math.min(l,4-l,1),0)},r=[o(5),o(3),o(1)].map(s=>Math.round(s*255));return{r:r[0],g:r[1],b:r[2],a:i}}function Kr(e){if(!e)return{h:0,s:1,v:1,a:1};const t=e.r/255,a=e.g/255,n=e.b/255,i=Math.max(t,a,n),o=Math.min(t,a,n);let r=0;i!==o&&(i===t?r=60*(0+(a-n)/(i-o)):i===a?r=60*(2+(n-t)/(i-o)):i===n&&(r=60*(4+(t-a)/(i-o)))),r<0&&(r=r+360);const s=i===0?0:(i-o)/i,l=[r,s,i];return{h:l[0],s:l[1],v:l[2],a:e.a}}function ku(e){const{h:t,s:a,v:n,a:i}=e,o=n-n*a/2,r=o===1||o===0?0:(n-o)/Math.min(o,1-o);return{h:t,s:r,l:o,a:i}}function xu(e){const{h:t,s:a,l:n,a:i}=e,o=n+a*Math.min(n,1-n),r=o===0?0:2-2*n/o;return{h:t,s:r,v:o,a:i}}function Mp(e){return`rgba(${e.r}, ${e.g}, ${e.b}, ${e.a})`}function Cu(e){return Mp(so(e))}function Jp(e){const t=a=>{const n=Math.round(a).toString(16);return("00".substr(0,2-n.length)+n).toUpperCase()};return`#${[t(e.r),t(e.g),t(e.b),t(Math.round(e.a*255))].join("")}`}function Lp(e){const t=pp(e.slice(1),2).map(a=>parseInt(a,16));return{r:t[0],g:t[1],b:t[2],a:Math.round(t[3]/255*100)/100}}function Su(e){const t=Lp(e);return Kr(t)}function _u(e){return Jp(so(e))}function Dp(e){return e.startsWith("#")&&(e=e.slice(1)),e=e.replace(/([^0-9a-f])/gi,"F"),(e.length===3||e.length===4)&&(e=e.split("").map(t=>t+t).join("")),e.length===6?e=Po(e,8,"F"):e=Po(Po(e,6),8,"F"),`#${e}`.toUpperCase().substr(0,9)}function Tu(e){const t=Bi(e);return{r:(t&16711680)>>16,g:(t&65280)>>8,b:t&255}}function Ep(e,t){const a=yu(qr(e));return a[0]=a[0]+t*10,bu(wu(a))}function Bp(e,t){const a=yu(qr(e));return a[0]=a[0]-t*10,bu(wu(a))}function ir(e){const t=Bi(e);return qr(t)[1]}function Fp(e,t){const a=ir(e),n=ir(t),i=Math.max(a,n),o=Math.min(a,n);return(i+.05)/(o+.05)}function Rp(e,t){var a,n;return((a=e.props)==null?void 0:a.hasOwnProperty(t))||((n=e.props)==null?void 0:n.hasOwnProperty(Ur(t)))}const H=function(t){var a;if(t._setup=(a=t._setup)!=null?a:t.setup,!t.name)return Aa("The component is missing an explicit name, unable to generate default prop value"),t;if(t._setup){var n;t.props=(n=t.props)!=null?n:{},t.props._as=String,t.setup=function(o,r){const s=oo(),l=pu(),c=mm(),u=fc({...ge(o)});$t(()=>{var f;const p=l.value.global,b=l.value[(f=o._as)!=null?f:t.name];if(b){const S=Object.entries(b).filter(k=>{let[P]=k;return P.startsWith("V")});S.length&&(c.value=Object.fromEntries(S))}for(const S of Object.keys(o)){let k;if(Rp(s.vnode,S))k=o[S];else{var w,v;k=(w=(v=b==null?void 0:b[S])!=null?v:p==null?void 0:p[S])!=null?w:o[S]}u[S]!==k&&(u[S]=k)}});const h=t._setup(u,r);let m;return re(c,(f,p)=>{!f&&m?m.stop():f&&!p&&(m=Qn(),m.run(()=>{Ue(f)}))},{immediate:!0}),h}}return t};function Fe(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:!0;return t=>(e?H:Hr)(t)}function ut(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"div",a=arguments.length>2?arguments[2]:void 0;return H({name:a!=null?a:ha(bt(e.replace(/__/g,"-"))),props:{tag:{type:String,default:t}},setup(n,i){let{slots:o}=i;return()=>{var r;return Wt(n.tag,{class:e},(r=o.default)==null?void 0:r.call(o))}}})}function ju(e){if(typeof e.getRootNode!="function"){for(;e.parentNode;)e=e.parentNode;return e!==document?null:document}const t=e.getRootNode();return t!==document&&t.getRootNode({composed:!0})!==document?null:t}const Nn="cubic-bezier(0.4, 0, 0.2, 1)",Vp="cubic-bezier(0.0, 0, 0.2, 1)",zp="cubic-bezier(0.4, 0, 1, 1)";function Ke(e,t){const a=oo();if(!a)throw new Error(`[Vuetify] ${e} ${t||"must be called from inside a setup function"}`);return a}function qt(){var e;let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"composables";return Ur((e=Ke(t).type)==null?void 0:e.name)}let Pu=0,Ti=new WeakMap;function Ye(){const e=Ke("getUid");if(Ti.has(e))return Ti.get(e);{const t=Pu++;return Ti.set(e,t),t}}Ye.reset=()=>{Pu=0,Ti=new WeakMap};function Iu(e){for(;e;){if(Yr(e))return e;e=e.parentElement}return document.scrollingElement}function Fi(e){const t=[];for(;e;)Yr(e)&&t.push(e),e=e.parentElement;return t}function Yr(e){if(!e||e.nodeType!==Node.ELEMENT_NODE)return!1;const t=window.getComputedStyle(e);return t.overflowY==="scroll"||t.overflowY==="auto"&&e.scrollHeight>e.clientHeight}const Pe=typeof window<"u",Xr=Pe&&"IntersectionObserver"in window,Hp=Pe&&("ontouchstart"in window||window.navigator.maxTouchPoints>0),or=Pe&&CSS.supports("selector(:focus-visible)");function Op(e){for(;e;){if(window.getComputedStyle(e).position==="fixed")return!0;e=e.offsetParent}return!1}function me(e,t){return a=>Object.keys(e).reduce((n,i)=>{const r=typeof e[i]=="object"&&e[i]!=null&&!Array.isArray(e[i])?e[i]:{type:e[i]};return a&&i in a?n[i]={...r,default:a[i]}:n[i]=r,t&&(n[i].source=t),n},{})}function O(e){const t=Ke("useRender");t.render=e}const rr=Symbol.for("vuetify:display"),wl={mobileBreakpoint:"lg",thresholds:{xs:0,sm:600,md:960,lg:1280,xl:1920,xxl:2560}},Gp=function(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:wl;return da(wl,e)};function kl(e){return Pe&&!e?window.innerWidth:0}function xl(e){return Pe&&!e?window.innerHeight:0}function Np(){const e=Pe?window.navigator.userAgent:"ssr";function t(p){return Boolean(e.match(p))}const a=t(/android/i),n=t(/iphone|ipad|ipod/i),i=t(/cordova/i),o=t(/electron/i),r=t(/chrome/i),s=t(/edge/i),l=t(/firefox/i),c=t(/opera/i),u=t(/win/i),h=t(/mac/i),m=t(/linux/i),f=t(/ssr/i);return{android:a,ios:n,cordova:i,electron:o,chrome:r,edge:s,firefox:l,opera:c,win:u,mac:h,linux:m,touch:Hp,ssr:f}}function $p(e,t){const{thresholds:a,mobileBreakpoint:n}=Gp(e),i=D(xl(t)),o=Np(),r=tt({}),s=D(kl(t));function l(){i.value=xl(),s.value=kl()}return t&&Ee(()=>l()),$t(()=>{const c=s.value<a.sm,u=s.value<a.md&&!c,h=s.value<a.lg&&!(u||c),m=s.value<a.xl&&!(h||u||c),f=s.value<a.xxl&&!(m||h||u||c),p=s.value>=a.xxl,b=c?"xs":u?"sm":h?"md":m?"lg":f?"xl":"xxl",w=typeof n=="number"?n:a[n],v=o.ssr?o.android||o.ios||o.opera:s.value<w;r.xs=c,r.sm=u,r.md=h,r.lg=m,r.xl=f,r.xxl=p,r.smAndUp=!c,r.mdAndUp=!(c||u),r.lgAndUp=!(c||u||h),r.xlAndUp=!(c||u||h||m),r.smAndDown=!(h||m||f||p),r.mdAndDown=!(m||f||p),r.lgAndDown=!(f||p),r.xlAndDown=!p,r.name=b,r.height=i.value,r.width=s.value,r.mobile=v,r.mobileBreakpoint=n,r.platform=o,r.thresholds=a}),Pe&&window.addEventListener("resize",l,{passive:!0}),Fr(r)}function Qr(){const e=we(rr);if(!e)throw new Error("Could not find Vuetify display injection");return e}const Up={collapse:"mdi-chevron-up",complete:"mdi-check",cancel:"mdi-close-circle",close:"mdi-close",delete:"mdi-close-circle",clear:"mdi-close-circle",success:"mdi-check-circle",info:"mdi-information",warning:"mdi-alert-circle",error:"mdi-close-circle",prev:"mdi-chevron-left",next:"mdi-chevron-right",checkboxOn:"mdi-checkbox-marked",checkboxOff:"mdi-checkbox-blank-outline",checkboxIndeterminate:"mdi-minus-box",delimiter:"mdi-circle",sort:"mdi-arrow-up",expand:"mdi-chevron-down",menu:"mdi-menu",subgroup:"mdi-menu-down",dropdown:"mdi-menu-down",radioOn:"mdi-radiobox-marked",radioOff:"mdi-radiobox-blank",edit:"mdi-pencil",ratingEmpty:"mdi-star-outline",ratingFull:"mdi-star",ratingHalf:"mdi-star-half-full",loading:"mdi-cached",first:"mdi-page-first",last:"mdi-page-last",unfold:"mdi-unfold-more-horizontal",file:"mdi-paperclip",plus:"mdi-plus",minus:"mdi-minus"},Wp={component:e=>Wt(Zr,{...e,class:"mdi"})},se=[String,Function,Object],sr=Symbol.for("vuetify:icons"),lo=me({icon:{type:se,required:!0},tag:{type:String,required:!0}},"icon"),Au=H({name:"VComponentIcon",props:lo(),setup(e){return()=>d(e.tag,null,{default:()=>[d(e.icon,null,null)]})}}),Mu=H({name:"VSvgIcon",inheritAttrs:!1,props:lo(),setup(e,t){let{attrs:a}=t;return()=>d(e.tag,oe(a,{style:null}),{default:()=>[d("svg",{class:"v-icon__svg",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",role:"img","aria-hidden":"true"},[d("path",{d:e.icon},null)])]})}}),qp=H({name:"VLigatureIcon",props:lo(),setup(e){return()=>d(e.tag,null,{default:()=>[e.icon]})}}),Zr=H({name:"VClassIcon",props:lo(),setup(e){return()=>d(e.tag,{class:e.icon},null)}}),Kp={svg:{component:Mu},class:{component:Zr}};function Yp(e){return da({defaultSet:"mdi",sets:{...Kp,mdi:Wp},aliases:Up},e)}const Xp=e=>{const t=we(sr);if(!t)throw new Error("Missing Vuetify Icons provide!");return{iconData:g(()=>{const n=Ae(e)?e.value:e.icon;if(!n)throw new Error("Icon value is undefined or null");let i=n;if(typeof n=="string"&&n.includes("$")){var o;i=(o=t.aliases)==null?void 0:o[n.slice(n.indexOf("$")+1)]}if(!i)throw new Error(`Could not find aliased icon "${n}"`);if(typeof i!="string")return{component:Au,icon:i};const r=Object.keys(t.sets).find(c=>typeof i=="string"&&i.startsWith(`${c}:`)),s=r?i.slice(r.length+1):i;return{component:t.sets[r!=null?r:t.defaultSet].component,icon:s}})}},Qp={badge:"Badge",close:"Close",dataIterator:{noResultsText:"No matching records found",loadingText:"Loading items..."},dataTable:{itemsPerPageText:"Rows per page:",ariaLabel:{sortDescending:"Sorted descending.",sortAscending:"Sorted ascending.",sortNone:"Not sorted.",activateNone:"Activate to remove sorting.",activateDescending:"Activate to sort descending.",activateAscending:"Activate to sort ascending."},sortBy:"Sort by"},dataFooter:{itemsPerPageText:"Items per page:",itemsPerPageAll:"All",nextPage:"Next page",prevPage:"Previous page",firstPage:"First page",lastPage:"Last page",pageText:"{0}-{1} of {2}"},datePicker:{itemsSelected:"{0} selected",nextMonthAriaLabel:"Next month",nextYearAriaLabel:"Next year",prevMonthAriaLabel:"Previous month",prevYearAriaLabel:"Previous year"},noDataText:"No data available",carousel:{prev:"Previous visual",next:"Next visual",ariaLabel:{delimiter:"Carousel slide {0} of {1}"}},calendar:{moreEvents:"{0} more"},fileInput:{counter:"{0} files",counterSize:"{0} files ({1} in total)"},timePicker:{am:"AM",pm:"PM"},pagination:{ariaLabel:{root:"Pagination Navigation",next:"Next page",previous:"Previous page",page:"Goto Page {0}",currentPage:"Page {0}, Current Page",first:"First page",last:"Last page"}},rating:{ariaLabel:{item:"Rating {0} of {1}"}}},Zp={af:!1,ar:!0,bg:!1,ca:!1,ckb:!1,cs:!1,de:!1,el:!1,en:!1,es:!1,et:!1,fa:!1,fi:!1,fr:!1,hr:!1,hu:!1,he:!0,id:!1,it:!1,ja:!1,ko:!1,lv:!1,lt:!1,nl:!1,no:!1,pl:!1,pt:!1,ro:!1,ru:!1,sk:!1,sl:!1,srCyrl:!1,srLatn:!1,sv:!1,th:!1,tr:!1,az:!1,uk:!1,vi:!1,zhHans:!1,zhHant:!1},$n=Symbol.for("vuetify:rtl");function eg(e,t){var a,n;return Ju({rtl:{...Zp,...(a=t==null?void 0:t.rtl)!=null?a:{}},isRtl:D((n=t==null?void 0:t.defaultRtl)!=null?n:!1),rtlClasses:D("")},e)}function Ju(e,t,a){const n=g(()=>typeof(a==null?void 0:a.rtl)=="boolean"?a.rtl:t.current.value&&e.rtl.hasOwnProperty(t.current.value)?e.rtl[t.current.value]:e.isRtl.value);return{isRtl:n,rtl:e.rtl,rtlClasses:g(()=>`v-locale--is-${n.value?"rtl":"ltr"}`)}}function tg(e,t){const a=we($n);if(!a)throw new Error("[Vuetify] Could not find injected rtl instance");const n=Ju(a,t,e);return Oe($n,n),n}function ma(){const e=we($n);if(!e)throw new Error("[Vuetify] Could not find injected rtl instance");return e}const Ri=Symbol.for("vuetify:locale-adapter"),bi=Symbol.for("vuetify:locale");function ag(e){const t=we(Ri);if(!t)throw new Error("[Vuetify] Could not find injected locale adapter");return t.createScope(e)}function Kt(){const e=we(Ri);if(!e)throw new Error("[Vuetify] Could not find injected locale adapter");return e.getScope()}function ng(e){return!!e&&e.hasOwnProperty("getScope")&&e.hasOwnProperty("createScope")&&e.hasOwnProperty("createRoot")}function ig(e,t){const a=ng(t)?t:sg(t),n=a.createRoot(e);return e==null||e.provide($n,eg(n,t)),a}const Cl="$vuetify.",Sl=(e,t)=>e.replace(/\{(\d+)\}/g,(a,n)=>String(t[+n])),og=(e,t,a)=>function(n){for(var i=arguments.length,o=new Array(i>1?i-1:0),r=1;r<i;r++)o[r-1]=arguments[r];if(!n.startsWith(Cl))return Sl(n,o);const s=n.replace(Cl,""),l=e.value&&a.value[e.value],c=t.value&&a.value[t.value];let u=Qo(l,s,null);return u||(Aa(`Translation key "${n}" not found in "${e.value}", trying fallback locale`),u=Qo(c,s,null)),u||(nr(`Translation key "${n}" not found in fallback`),u=n),typeof u!="string"&&(nr(`Translation key "${n}" has a non-string value`),u=n),Sl(u,o)};function rg(e,t){return(a,n)=>new Intl.NumberFormat([e.value,t.value],n).format(a)}function sg(e){const t=a=>{const n=D(a.current),i=D(a.fallback),o=D(a.messages);return{current:n,fallback:i,messages:o,t:og(n,i,o),n:rg(n,i)}};return{createRoot:a=>{var n,i,o;const r=t({current:(n=e==null?void 0:e.defaultLocale)!=null?n:"en",fallback:(i=e==null?void 0:e.fallbackLocale)!=null?i:"en",messages:(o=e==null?void 0:e.messages)!=null?o:{en:Qp}});if(!a)throw new Error("[Vuetify] Could not find default app instance");return a.provide(bi,r),r},getScope:()=>{const a=we(bi);if(!a)throw new Error("[Vuetify] Could not find injected locale instance");return a},createScope:a=>{const n=we(bi);if(!n)throw new Error("[Vuetify] Could not find injected locale instance");const i=t({current:g(()=>{var o;return(o=a==null?void 0:a.locale)!=null?o:n.current.value}),fallback:g(()=>{var o;return(o=a==null?void 0:a.locale)!=null?o:n.fallback.value}),messages:g(()=>{var o;return(o=a==null?void 0:a.messages)!=null?o:n.messages.value})});return Oe(bi,i),i}}}const Na=2.4,_l=.2126729,Tl=.7151522,jl=.072175,lg=.55,cg=.58,ug=.57,dg=.62,yi=.03,Pl=1.45,hg=5e-4,mg=1.25,fg=1.25,Il=.078,Al=12.82051282051282,wi=.06,Ml=.001;function Jl(e,t){const a=((e>>16&255)/255)**Na,n=((e>>8&255)/255)**Na,i=((e>>0&255)/255)**Na,o=((t>>16&255)/255)**Na,r=((t>>8&255)/255)**Na,s=((t>>0&255)/255)**Na;let l=a*_l+n*Tl+i*jl,c=o*_l+r*Tl+s*jl;if(l<=yi&&(l+=(yi-l)**Pl),c<=yi&&(c+=(yi-c)**Pl),Math.abs(c-l)<hg)return 0;let u;if(c>l){const h=(c**lg-l**cg)*mg;u=h<Ml?0:h<Il?h-h*Al*wi:h-wi}else{const h=(c**dg-l**ug)*fg;u=h>-Ml?0:h>-Il?h-h*Al*wi:h+wi}return u*100}const Un=Symbol.for("vuetify:theme"),ve=me({theme:String},"theme"),Cn={defaultTheme:"light",variations:{colors:[],lighten:0,darken:0},themes:{light:{dark:!1,colors:{background:"#FFFFFF",surface:"#FFFFFF","surface-variant":"#424242","on-surface-variant":"#EEEEEE",primary:"#6200EE","primary-darken-1":"#3700B3",secondary:"#03DAC6","secondary-darken-1":"#018786",error:"#B00020",info:"#2196F3",success:"#4CAF50",warning:"#FB8C00"},variables:{"border-color":"#000000","border-opacity":.12,"high-emphasis-opacity":.87,"medium-emphasis-opacity":.6,"disabled-opacity":.38,"idle-opacity":.04,"hover-opacity":.04,"focus-opacity":.12,"selected-opacity":.08,"activated-opacity":.12,"pressed-opacity":.12,"dragged-opacity":.08,"kbd-background-color":"#212529","kbd-color":"#FFFFFF","code-background-color":"#C2C2C2"}},dark:{dark:!0,colors:{background:"#121212",surface:"#212121","surface-variant":"#BDBDBD","on-surface-variant":"#424242",primary:"#BB86FC","primary-darken-1":"#3700B3",secondary:"#03DAC5","secondary-darken-1":"#03DAC5",error:"#CF6679",info:"#2196F3",success:"#4CAF50",warning:"#FB8C00"},variables:{"border-color":"#FFFFFF","border-opacity":.12,"high-emphasis-opacity":.87,"medium-emphasis-opacity":.6,"disabled-opacity":.38,"idle-opacity":.1,"hover-opacity":.04,"focus-opacity":.12,"selected-opacity":.08,"activated-opacity":.12,"pressed-opacity":.16,"dragged-opacity":.08,"kbd-background-color":"#212529","kbd-color":"#FFFFFF","code-background-color":"#B7B7B7"}}}};function pg(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:Cn;if(!e)return{...Cn,isDisabled:!0};const t={};for(const[o,r]of Object.entries((a=e.themes)!=null?a:{})){var a,n,i;const s=r.dark?(n=Cn.themes)==null?void 0:n.dark:(i=Cn.themes)==null?void 0:i.light;t[o]=da(s,r)}return da(Cn,{...e,themes:t})}function gg(e,t){const a=e._context.provides.usehead,n=tt(pg(t)),i=D(n.defaultTheme),o=D(n.themes),r=g(()=>{const h={};for(const[m,f]of Object.entries(o.value)){const p=h[m]={...f,colors:{...f.colors}};if(n.variations)for(const b of n.variations.colors){const w=p.colors[b];for(const v of["lighten","darken"]){const S=v==="lighten"?Ep:Bp;for(const k of _a(n.variations[v],1))p.colors[`${b}-${v}-${k}`]=Ap(S(Bi(w),k))}}for(const b of Object.keys(p.colors)){if(/on-[a-z]/.test(b)||p.colors[`on-${b}`])continue;const w=`on-${b}`,v=Bi(p.colors[b]),S=Math.abs(Jl(0,v)),k=Math.abs(Jl(16777215,v));p.colors[w]=k>Math.min(S,50)?"#fff":"#000"}}return h}),s=g(()=>r.value[i.value]),l=g(()=>{const h=[];s.value.dark&&$a(h,":root",["color-scheme: dark"]);for(const[f,p]of Object.entries(r.value)){const{variables:b,dark:w}=p;$a(h,`.v-theme--${f}`,[`color-scheme: ${w?"dark":"normal"}`,...vg(p),...Object.keys(b).map(v=>{const S=b[v],k=typeof S=="string"&&S.startsWith("#")?Tu(S):void 0,P=k?`${k.r}, ${k.g}, ${k.b}`:void 0;return`--v-${v}: ${P!=null?P:S}`})])}const m=new Set(Object.values(r.value).flatMap(f=>Object.keys(f.colors)));for(const f of m)/on-[a-z]/.test(f)?$a(h,`.${f}`,[`color: rgb(var(--v-theme-${f})) !important`]):($a(h,`.bg-${f}`,[`--v-theme-overlay-multiplier: var(--v-theme-${f}-overlay-multiplier)`,`background: rgb(var(--v-theme-${f})) !important`,`color: rgb(var(--v-theme-on-${f})) !important`]),$a(h,`.text-${f}`,[`color: rgb(var(--v-theme-${f})) !important`]),$a(h,`.border-${f}`,[`--v-border-color: var(--v-theme-${f})`]));return h.map((f,p)=>p===0?f:`    ${f}`).join("")});if(a)a.addHeadObjs(g(()=>({style:[{children:l.value,type:"text/css",id:"vuetify-theme-stylesheet"}]}))),Pe&&$t(()=>a.updateDOM());else{let m=function(){if(!n.isDisabled){if(typeof document<"u"&&!h){const f=document.createElement("style");f.type="text/css",f.id="vuetify-theme-stylesheet",h=f,document.head.appendChild(h)}h&&(h.innerHTML=l.value)}};var u=m;let h=Pe?document.getElementById("vuetify-theme-stylesheet"):null;re(l,m,{immediate:!0})}const c=g(()=>n.isDisabled?void 0:`v-theme--${i.value}`);return{isDisabled:n.isDisabled,name:i,themes:o,current:s,computedThemes:r,themeClasses:c,styles:l,global:{name:i,current:s}}}function ke(e){Ke("provideTheme");const t=we(Un,null);if(!t)throw new Error("Could not find Vuetify theme injection");const a=g(()=>{var o;return(o=e.theme)!=null?o:t==null?void 0:t.name.value}),n=g(()=>t.isDisabled?void 0:`v-theme--${a.value}`),i={...t,name:a,themeClasses:n};return Oe(Un,i),i}function Lu(){Ke("useTheme");const e=we(Un,null);if(!e)throw new Error("Could not find Vuetify theme injection");return e}function $a(e,t,a){e.push(`${t} {
`,...a.map(n=>`  ${n};
`),`}
`)}function vg(e){const t=e.dark?2:1,a=e.dark?1:2,n=[];for(const[i,o]of Object.entries(e.colors)){const r=Tu(o);n.push(`--v-theme-${i}: ${r.r},${r.g},${r.b}`),i.startsWith("on-")||n.push(`--v-theme-${i}-overlay-multiplier: ${ir(o)>.18?t:a}`)}return n}function an(e){const t=D(),a=D();if(Pe){const n=new ResizeObserver(i=>{e==null||e(i,n),i.length&&(a.value=i[0].contentRect)});lt(()=>{n.disconnect()}),re(t,(i,o)=>{o&&(n.unobserve(o),a.value=void 0),i&&n.observe(i)},{flush:"post"})}return{resizeRef:t,contentRect:Zn(a)}}const Vi=Symbol.for("vuetify:layout"),Du=Symbol.for("vuetify:layout-item"),Jo=1e3,Eu=me({overlaps:{type:Array,default:()=>[]},fullHeight:Boolean},"layout"),rn=me({name:{type:String},order:{type:[Number,String],default:0},absolute:Boolean},"layout-item");function bg(){const e=we(Vi);if(!e)throw new Error("Could not find injected Vuetify layout");return e}function sn(e){var t;const a=we(Vi);if(!a)throw new Error("Could not find injected Vuetify layout");const n=(t=e.id)!=null?t:`layout-item-${Ye()}`,i=Ke("useLayoutItem");Oe(Du,{id:n});const o=D(!1);Dc(()=>o.value=!0),Lc(()=>o.value=!1);const{layoutItemStyles:r,layoutItemScrimStyles:s}=a.register(i,{...e,active:g(()=>o.value?!1:e.active.value),id:n});return lt(()=>a.unregister(n)),{layoutItemStyles:r,layoutRect:a.layoutRect,layoutItemScrimStyles:s}}const yg=(e,t,a,n)=>{let i={top:0,left:0,right:0,bottom:0};const o=[{id:"",layer:{...i}}];for(const r of e){const s=t.get(r),l=a.get(r),c=n.get(r);if(!s||!l||!c)continue;const u={...i,[s.value]:parseInt(i[s.value],10)+(c.value?parseInt(l.value,10):0)};o.push({id:r,layer:u}),i=u}return o};function Bu(e){const t=we(Vi,null),a=g(()=>t?t.rootZIndex.value-100:Jo),n=D([]),i=tt(new Map),o=tt(new Map),r=tt(new Map),s=tt(new Map),l=tt(new Map),{resizeRef:c,contentRect:u}=an(),h=g(()=>{var j;const x=new Map,y=(j=e.overlaps)!=null?j:[];for(const _ of y.filter(M=>M.includes(":"))){const[M,I]=_.split(":");if(!n.value.includes(M)||!n.value.includes(I))continue;const J=i.get(M),T=i.get(I),L=o.get(M),B=o.get(I);!J||!T||!L||!B||(x.set(I,{position:J.value,amount:parseInt(L.value,10)}),x.set(M,{position:T.value,amount:-parseInt(B.value,10)}))}return x}),m=g(()=>{const j=[...new Set([...r.values()].map(y=>y.value))].sort((y,_)=>y-_),x=[];for(const y of j){const _=n.value.filter(M=>{var I;return((I=r.get(M))==null?void 0:I.value)===y});x.push(..._)}return yg(x,i,o,s)}),f=g(()=>!Array.from(l.values()).some(j=>j.value)),p=g(()=>{const j=m.value[m.value.length-1].layer;return{position:"relative",paddingLeft:Q(j.left),paddingRight:Q(j.right),paddingTop:Q(j.top),paddingBottom:Q(j.bottom),...f.value?void 0:{transition:"none"}}}),b=g(()=>m.value.slice(1).map((j,x)=>{let{id:y}=j;const{layer:_}=m.value[x],M=o.get(y);return{id:y,..._,size:Number(M.value)}})),w=j=>b.value.find(x=>x.id===j),v=Ke("createLayout"),S=D(!1);yt(()=>{S.value=!0}),Oe(Vi,{register:(j,x)=>{let{id:y,order:_,position:M,layoutSize:I,elementSize:J,active:T,disableTransitions:L,absolute:B}=x;r.set(y,_),i.set(y,M),o.set(y,I),s.set(y,T),L&&l.set(y,L);const $=Jn(Du,v==null?void 0:v.vnode).indexOf(j);$>-1?n.value.splice($,0,y):n.value.push(y);const N=g(()=>b.value.findIndex(te=>te.id===y)),K=g(()=>a.value+m.value.length*2-N.value*2),de=g(()=>{const te=M.value==="left"||M.value==="right",fe=M.value==="right",Je=M.value==="bottom",Y={[M.value]:0,zIndex:K.value,transform:`translate${te?"X":"Y"}(${(T.value?0:-110)*(fe||Je?-1:1)}%)`,position:B.value||a.value!==Jo?"absolute":"fixed",...f.value?void 0:{transition:"none"}};if(!S.value)return Y;if(N.value<0)throw new Error(`Layout item "${y}" is missing`);const xe=b.value[N.value];if(!xe)throw new Error(`Could not find layout item "${y}`);const ze=h.value.get(y);return ze&&(xe[ze.position]+=ze.amount),{...Y,height:te?`calc(100% - ${xe.top}px - ${xe.bottom}px)`:J.value?`${J.value}px`:void 0,marginLeft:fe?void 0:`${xe.left}px`,marginRight:fe?`${xe.right}px`:void 0,marginTop:M.value!=="bottom"?`${xe.top}px`:void 0,marginBottom:M.value!=="top"?`${xe.bottom}px`:void 0,width:te?J.value?`${J.value}px`:void 0:`calc(100% - ${xe.left}px - ${xe.right}px)`}}),Z=g(()=>({zIndex:K.value-1,position:a.value===Jo?"fixed":"absolute"}));return{layoutItemStyles:de,layoutItemScrimStyles:Z,zIndex:K}},unregister:j=>{r.delete(j),i.delete(j),o.delete(j),s.delete(j),l.delete(j),n.value=n.value.filter(x=>x!==j)},mainStyles:p,getLayoutItem:w,items:b,layoutRect:u,rootZIndex:a});const k=g(()=>["v-layout",{"v-layout--full-height":e.fullHeight}]),P=g(()=>({zIndex:a.value}));return{layoutClasses:k,layoutStyles:P,getLayoutItem:w,items:b,layoutRect:u,layoutRef:c}}const wg=function(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return{install:a=>{const{blueprint:n,...i}=e,o=da(n,i),{aliases:r={},components:s={},directives:l={}}=o;for(const m in l)a.directive(m,l[m]);for(const m in s)a.component(m,s[m]);for(const m in r)a.component(m,H({...r[m],name:m}));function c(m){a.provide(Di,yp(o.defaults)),a.provide(rr,$p(o.display,m)),a.provide(Un,gg(a,o.theme)),a.provide(sr,Yp(o.icons)),a.provide(Ri,ig(a,o.locale))}Pe||c(),Ye.reset();const u=a.mount;a.mount=(m,f,p)=>{c(f);const b=u(m,f,p);return a.mount=u,b};function h(m){var f,p,b;const w=this.$,v=(f=(p=w.parent)==null?void 0:p.provides)!=null?f:(b=w.vnode.appContext)==null?void 0:b.provides;if(v&&m in v)return v[m]}a.mixin({computed:{$vuetify(){return tt({defaults:h.call(this,Di),display:h.call(this,rr),theme:h.call(this,Un),icons:h.call(this,sr),locale:h.call(this,Ri),rtl:h.call(this,$n)})}}})}}},kg={version:"0.8",base_url:"https://pretalx.com/juliacon-2022/schedule/",conference:{acronym:"juliacon-2022",title:"JuliaCon 2022 (Times are UTC)",start:"2022-07-19",end:"2022-07-30",daysCount:12,timeslot_duration:"00:05",time_zone_name:"UTC",rooms:[{name:"Green",guid:null,description:null,capacity:null},{name:"Red",guid:null,description:null,capacity:null},{name:"Purple",guid:null,description:null,capacity:null},{name:"Blue",guid:null,description:null,capacity:null},{name:"BoF",guid:null,description:null,capacity:null},{name:"JuMP",guid:null,description:null,capacity:null},{name:"Sponsored forums",guid:null,description:null,capacity:null}],days:[{index:1,date:"2022-07-19",day_start:"2022-07-19T04:00:00+00:00",day_end:"2022-07-20T03:59:00+00:00",rooms:{Green:[{id:21293,guid:"ccc3a51e-b1ed-5a17-99de-c2653a560eb6",logo:"",date:"2022-07-19T14:00:00+00:00",start:"14:00",duration:"03:00",room:"Green",slug:"juliacon-2022-21293-introduction-to-julia",url:"https://pretalx.com/juliacon-2022/talk/WLNWBV/",title:"Introduction to Julia",subtitle:"",track:"JuliaCon",type:"Workshop",language:"en",abstract:`This workshop is geared towards anyone who wants to start using Julia.\r
It will be an extremely accessible overview of Julia.`,description:`We'll cover how to download and install Julia in Windows, Mac and Linux.\r
Next, we will show how to use Julia in the terminal (REPL), in VSCode,\r
and also in an interactive notebook with Pluto.\r
We will contrast Julia with Python, showcasing major differences and\r
also comparing Julia to a popular beginner's language such as Python.\r
Additionally, we will teach how to install and uninstall packages.\r
The bulk of the workshop will be how to run Julia commands,\r
what are statements and an overview of the Julia syntax.\r
We encourage everyone that wants to know more about Julia independent of\r
skill-level to join us.`,recording_license:"",do_not_record:!1,persons:[{id:21367,code:"KFWW8C",public_name:"Jose Storopoli",biography:null,answers:[]}],links:[],attachments:[],answers:[]}]}},{index:2,date:"2022-07-20",day_start:"2022-07-20T04:00:00+00:00",day_end:"2022-07-21T03:59:00+00:00",rooms:{Green:[{id:18060,guid:"c52117a8-ea06-5f0a-a64a-c9b8a98a780a",logo:"",date:"2022-07-20T14:00:00+00:00",start:"14:00",duration:"03:00",room:"Green",slug:"juliacon-2022-18060-introduction-to-graph-computing",url:"https://pretalx.com/juliacon-2022/talk/WL9FZZ/",title:"Introduction to Graph Computing",subtitle:"",track:"JuliaCon",type:"Workshop",language:"en",abstract:"Graph computing is an innovative technology that allows developers to build applications and systems as directed acyclic graphs (DAGs). Graph computing offers generic solutions to some of the most fundamental challenges in enterprise computing such as scalability, transparency and lineage. In this workshop, we survey the available graph computing tools in Julia, then walk through a few hands-on examples of building real world applications and systems using graph computing.",description:`Graph computing is an innovative and hyper-efficient technology for building large and distributed systems or applications, where common challenges include scalability, transparency, explainability, lineage, adaptability and reproducibility. We coined the acronym STELAR for these challenges. \r
\r
In almost every organization, significant engineering resources and efforts are devoted to addressing the STELAR needs for their core enterprise systems. These efforts are not portable because they are specific to the particular organization and architecture. For example, the solution to improve the scalability of the trading system at JP Morgan is not applicable to Goldman Sachs, as their technology stacks are fundamentally different. There is an enormous waste of time, money, energy and human talents for re-creating bespoke solutions to the same STELAR problems across the industry. The world would be a much better place if we could solve these problems once and for all in enterprise systems. This is the promise of graph computing.\r
\r
Instead of functions in the traditional programming paradigm, directed acyclic graphs (DAG) are the fundamental building blocks in graph computing. A DAG is a special type of graph, which consists of a collection of nodes and directional connections between them. Acyclic means that these connections do not form any loops. A DAG can also be used as a generic representation of any kind of computing or workflow. Conceptually, any computation, from the simplest formula in a spreadsheet to the most complex enterprise systems, reduces to a DAG. In graph computing, complex DAGs representing entire applications or systems are built by composing smaller and modular DAGs, analogous to function compositions in the traditional programming paradigm.\r
\r
Compared to the function centric representation in traditional programming, DAG is a much better and more convenient representation for building generic solutions to STELAR. Once built, these solutions are applicable to any enterprise system as they all reduce to DAGs. \r
\r
The outline of this workshop is as follows:\r
\r
* Introduction to the key ideas and benefits of graph computing, and how DAGs can help solve the STELAR program generically.\r
* Survey of existing graph computing solutions, approaches and tools. We will cover both Python and Julia tools, as well as commercial and open source solutions\r
* Discuss the key challenges in graph computing and approaches, including graph creation and distribution\r
* Hands-on sessions in building real world applications/systems using graph computing. In these sessions, we will be using available graph computing tools like Dask, Dagger.jl and Julius etc. \r
  * Build a simple task graph and execute it\r
  * Query the graph data after execution\r
  * Build an ML data processing pipeline\r
  * Building generic and reusable patterns using graph composition\r
  * Graph distribution, for building distributed systems\r
  * End to end AAD (adjoint algorithmic differentiation) with graphs\r
  * Build streaming pipelines in graph\r
*Plenty of time for questions.`,recording_license:"",do_not_record:!1,persons:[{id:17652,code:"SHXTDN",public_name:"Yadong Li",biography:`Yadong Li is the CTO and co-founder of Julius Technologies Inc. He has over 17 years of experience in quantitative finance, and has held a number of senior leadership roles at Lehman Brothers and Barclays. Yadong has published multiple papers on derivative pricing/risk, capital allocation and optimization etc. He also taught at the Courant Math Finance Master program at NYU. Yadong also has a Ph.D. in Physics, and Master degrees in Computer Science and Financial Engineering. \r
\r
Yadong is a pioneer in the graph computing space. He created Julius' low-code, auto-scaling and visual graph computing platform that delivers the power of graph computing to every developer!`,answers:[]}],links:[],attachments:[],answers:[]},{id:18061,guid:"10883bef-d1d0-5fa0-a854-4a9b7694d792",logo:"",date:"2022-07-20T18:00:00+00:00",start:"18:00",duration:"03:00",room:"Green",slug:"juliacon-2022-18061-getting-started-with-julia-and-machine-learning",url:"https://pretalx.com/juliacon-2022/talk/Q7WJ9F/",title:"Getting started with Julia and Machine Learning",subtitle:"",track:"JuliaCon",type:"Workshop",language:"en",abstract:`A three-hour introductory workshop for newcomers to Julia and machine\r
learning. Participants will have training in some technical domain,\r
for example, in science, economics or engineering. While no prior\r
experience with Julia or machine learning is needed, it is assumed \r
participants have Julia 1.7 installed on their computer.`,description:`## Overview\r
\r
In their simplest manifestation, machine learning algorithms extract,\r
or "learn", from historical data some essential properties enabling\r
them to respond intelligently to new data (typically,\r
automatically). For example, spam filters predict whether to designate\r
a new email as "junk", based on how a user previously designated a\r
large number of previous messages. A property valuation site suggests\r
the sale price for a new home, given its location and other\r
attributes, based on a database of previous sales.\r
\r
Julia is uniquely positioned to accelerate developments in machine\r
learning and there has been an explosion of Julia machine learning\r
libraries. [MLJ](https://alan-turing-institute.github.io/MLJ.jl/dev/)\r
(Machine Learning in Julia) is a popular toolbox providing a common\r
interface for interacting with over 180 machine learning models\r
written in Julia and other languages. This workshop will introduce\r
basic machine learning concepts, and walk participants through enough\r
Julia to get started using MLJ.\r
\r
\r
## Prerequisites\r
\r
- **Essential.** A computer with [Julia 1.7.3](https://github.com/ablaom/HelloJulia.jl/blob/dev/FIRST_STEPS.md) installed.\r
\r
- **Strongly recommended,** Workshop resources pre-installed. See [here](https://github.com/ablaom/HelloJulia.jl/wiki/JuliaCon-2022-workshop:-Getting-started-with-Julia-and-MLJ).\r
\r
- **Recommended.** Basic linear algebra and statistics, such\r
  as covered in first year university courses.\r
\r
- **Recommended but not essential.** Prior experience with a scripting\r
  language, such as python, MATLAB or R.\r
\r
## Objectives\r
\r
- Be able to carry out basic mathematical operations using Julia,\r
  perform random sampling, define and apply functions, carry out\r
  iterative tasks\r
\r
- Be able to load data sets and do basic plotting\r
\r
- Understand what supervised learning models are, and how to evaluate\r
  them using a holdout test set or using cross-validation\r
\r
- Be able to train and evaluate a supervised learning model using\r
  the MLJ package\r
\r
\r
## Resources\r
\r
[HelloJulia.jl](https://github.com/ablaom/HelloJulia.jl)\r
\r
## Format\r
\r
This workshop will be a combination of formal presentation and live\r
coding.`,recording_license:"",do_not_record:!1,persons:[{id:1046,code:"CK3MKJ",public_name:"Anthony Blaom",biography:`[Anthony Blaom](https://ablaom.github.io) Anthony Blaom is a mathematician, publishing in areas of pure mathematics, and a scientific computing consultant. He is a co-creator and lead contributor for MLJ, an open-source machine learning platform written in Julia.\r
\r
Dr. Blaom was initially trained as a mechanical engineer at the University of Melbourne in 1991. After completing a MSc in Aeronautics and a PhD in Mathematics at Caltech in 1998, he joined the University of Auckland as a Lecturer. For a while he switched to adjunct teaching, focusing on his young children, whom he homeschooled while living on the small island of Waiheke.\r
\r
Dr. Blaom is currently a Senior Research Fellow in the Department of Computer Science, University of Auckland.`,answers:[]},{id:18436,code:"SFJ7MN",public_name:"Samuel",biography:null,answers:[]}],links:[],attachments:[],answers:[]}]}},{index:3,date:"2022-07-21",day_start:"2022-07-21T04:00:00+00:00",day_end:"2022-07-22T03:59:00+00:00",rooms:{Green:[{id:17247,guid:"3d1e08c2-5279-5e21-85c2-e64f1b8d490f",logo:"/media/juliacon-2022/submissions/9PKGGH/pretty_VPVkItu.png",date:"2022-07-21T14:00:00+00:00",start:"14:00",duration:"03:00",room:"Green",slug:"juliacon-2022-17247-gpu-accelerated-medical-image-segmentation-framework",url:"https://pretalx.com/juliacon-2022/talk/9PKGGH/",title:"GPU accelerated medical image segmentation framework",subtitle:"",track:"JuliaCon",type:"Workshop",language:"en",abstract:`Medical image segmentation with Julia \r
Participants can download data before task 9 from https://drive.google.com/drive/folders/1HqEgzS8BV2c7xYNrZdEAnrHk7osJJ--2 \r
Additionally tou can download required libraries to your enviroment\r
]add ProgressMeter StaticArrays BSON Distributed Flux Hyperopt Plots MedEye3d Distributions Clustering IrrationalConstants ParallelStencil CUDA HDF5 MedEval3D Colors`,description:`As the preparation for the workshop I will ask participants to load earlier  the dataset on which we would work on - Dataset can be found in link [2]. Additionally you can load required packages to the enviroment where You will work in [3]. In order to fully participate you need to have Nvidia GPU available.\r
\r
Medical image segmentation is a rapidly developing field of Computer Vision. This area of research requires knowledge in radiologic imaging, mathematics and computer science. In order to provide assistance to the researchers multiple software packages were developed. However because of the rapidly changing scientific environment those tools can no longer be effective for some of the users.\r
Such situation is present in the case of Julia language users that require support for the interactive programming development style that is not popular among traditional software tools. Another characteristic of modern programming for 3 dimensional medical imaging data is GPU acceleration which can give outstanding improvement of algorithms performance in case of working with  3D medical imaging. Hence in this work the author presents sets of new Julia language software tools that are designed to fulfil emerging needs. Those tools include GPU accelerated medical image viewer with annotation possibilities that is characterised by a very convenient programming interface. CUDA accelerated Medical segmentation metrics tool that supplies state of the art implementations of algorithms required for quantification of similarity between algorithm output and gold standard. Lastly, a set of utility tools connecting those two mentioned packages with HDF5 file system and preprocessing using MONAI and PythonCall.\r
 \r
Main unique feature of the presented framework is ease of interoperability with other Julia packages, which in the rapidly developing ecosystem of scientific computing may spark in the opinion of the author application of multiple algorithms from fields usually not widely used in medical image segmentation like differential programming, topology etc.\r
 \r
I am planning to conduct a workshop with the assumption of only basic knowledge of Julia programming and no medical knowledge at all. Most of the time would be devoted to walk through end to end example medical image segmentation like in the tutorial available under link below [1], with code executed live during workshop. In order to run some parts of the workshop users would need a CUDA environment. Because of the complex nature of the problem some theoretical introductions will also be needed.\r
 \r
Plan for the workshop :\r
 \r
1.Introduction to medical imaging data format\r
 \r
2.Presentation of loading data and simple preprocessing using MONAI and PythonCall\r
 \r
3.Tutorial presenting how to use MedEye3d viewer and annotator\r
 \r
4.Implementing first phase of example algorithm on CPU showing some Julia features supporting work on multidimensional arrays\r
 \r
5.Presenting further part of the example algorithm using GPU acceleration with CUDA.jl and ParallelStencil with short introduction to GPU programming .\r
 \r
6.Presenting how to save and retrieve data using HDF5.jl\r
 \r
7.Show how to apply medical segmentation metrics from MedEval3D, and some introduction how to choose properly the metric depending on the problem\r
 \r
8.Discuss How one can improve the performance of the algorithm and what are some planned  future directions\r
 \r
 \r
[1] https://github.com/jakubMitura14/MedPipe3DTutorial\r
[2]Participants can download data before task 9 from https://drive.google.com/drive/folders/1HqEgzS8BV2c7xYNrZdEAnrHk7osJJ--2 \r
[3] ]add Flux Hyperopt Plots UNet MedEye3d Distributions Clustering IrrationalConstants ParallelStencil CUDA HDF5 MedEval3D MedPipe3D Colors`,recording_license:"",do_not_record:!1,persons:[{id:18092,code:"LQTEAK",public_name:"Jakub Mitura",biography:"I am a student in my last year of MSc in Computer Science - Big Data Specialization  (graduation June 2022 r.) also a physician in the last year of nuclear medicine residency working with various modalities of medical imaging. Additionally for the last 4 years I have been a lecturer  in international programmes teaching subjects like Anatomy and Radiology in English . Simultaneously I am a junior research assistant in Medical University of Lublin and  in the final steps of acquiring a PhD in Nuclear Medicine. I already passed all examinations, and have preliminary positive reviews, formally I will acquire PhD probably on 14.04.2022",answers:[]}],links:[],attachments:[],answers:[]}]}},{index:4,date:"2022-07-22",day_start:"2022-07-22T04:00:00+00:00",day_end:"2022-07-23T03:59:00+00:00",rooms:{Green:[{id:17967,guid:"527094a3-8c9f-5842-9776-cfb2d44cffcc",logo:"",date:"2022-07-22T08:00:00+00:00",start:"08:00",duration:"03:00",room:"Green",slug:"juliacon-2022-17967-statistics-symposium",url:"https://pretalx.com/juliacon-2022/talk/7JNQCM/",title:"Statistics symposium",subtitle:"",track:"JuliaCon",type:"Minisymposium",language:"en",abstract:"Statistics is a domain where some early stage development of packages, and some early applications, have come about in Julia. We think of this mini-symposium as a combination of (a) Report on many interesting recent developments in this field and (b) Offer a birds eye view to the people interested in this field, and help them assess the state of maturity so as to make decisions about whether Julia is appropriate for their statistics work.",description:`1. "Doing applied statistics research in Julia", Ajay Shah (20 minutes)\r
  We show the journey of two applied statistics research papers, done fully in Julia, by researchers who were previously working in R. What was convenient, what were the chokepoints, what were the gains in expressivity and in performance. Based on this, we evaluate the state of maturity of Julia for doing applied statistics. We propose practical pathways for statisticians, and speak to the Julia community about what is required next. We report on recent developments in the field of Julia and statistics.\r
\r
2. "CRRao: A unified framework for statistical models", Sourish Das (20 minutes)\r
  Many statistical models are available in Julia, and many more will come. CRRao is a consistent framework through which callers interact with a large suite of models. For the end-user, it reduces the cost and complexity of estimating statistical models. It offers convenient guidelines through which development of additional statistical models can take place in the future.\r
\r
3. "TSx: A time series class for Julia", Chirag Anand (20 minutes)\r
  DataFrames.jl is a powerful system, but expressing the standard tasks of manipulating time series -- e.g. as seen in finance or macroeconomics -- is often cumbersome. We draw on the work of the R community, which has built zoo and xts, to build a time series class, TSx, which delivers a simple set of operators and functions for the people working with time series. It constitutes syntactic sugar on top of the capabilities of DataFrame.jl and thus harnesses the capabilities and efficiency of that package. We conduct comparisons of capabilities and performance against zoo and xts in R.\r
\r
4. "Comparing glm in Julia, R and SAS", Mousum Datta (10 minutes)\r
  glm is an unusually important class of statistical models. We compare the capabilities, correctness and performance of the present glm systems in Julia, R and SAS. We report on recent improvements that have been injected into GLM.jl.\r
\r
5. "Working with survey data", Ayush Patnaik (10 minutes)\r
  The Julia package survey.jl builds some of the functionality required for statistical estimators with stratified random sampling. For a limited subset of the capabilities of Thomas Lumley's R package \`survey', we show the correctness and the performance gains of the Julia package.`,recording_license:"",do_not_record:!1,persons:[{id:18380,code:"SKRLCP",public_name:"Ajay Shah",biography:`Ajay Shah studied at IIT, Bombay and USC, Los Angeles. He has held positions at Centre for Monitoring Indian Economy (CMIE), Indira Gandhi Institute for Development Research (IGIDR), Department of Economic Affairs at the Ministry of Finance and National Institute for Public Finance and Policy (NIPFP). He is now part of xKDR Forum and Jindal Global University. His  research is at the intersection of economics, law and public administration. His second book, co-authored with Vijay Kelkar, "In service of the republic: The art and science of economic policy", featured in Bloomberg's global "2020 Best Books on Business and Leadership". His work can be accessed on his home page (http://www.mayin.org/ajayshah).`,answers:[]}],links:[],attachments:[],answers:[]},{id:18135,guid:"f4d9d071-73de-5f90-b324-9286bfbf4486",logo:"/media/juliacon-2022/submissions/JYDQEB/collisions_hNkPW20.png",date:"2022-07-22T14:00:00+00:00",start:"14:00",duration:"03:00",room:"Green",slug:"juliacon-2022-18135-juliamolsim-computation-with-atoms",url:"https://pretalx.com/juliacon-2022/talk/JYDQEB/",title:"JuliaMolSim: Computation with Atoms",subtitle:"",track:"JuliaCon",type:"Minisymposium",language:"en",abstract:"The JuliaMolSim community is hosting a minisymposium! Come hear about AtomsBase, our project to create a unified interface for representing atomic geometries, as well as packages for simulation (both quantum mechanical and classical particles-based) and machine learning on atomistic systems. Do you have an idea for a package you think the community needs? Participate in our \u201Cquick pitch\u201D session and find co-developers to help build it!",description:`The JuliaMolSim community is open to anyone who uses/develops Julia code that is used for simulating/analyzing systems that are resolved at the level of atomic/molecular coordinates. You can learn more about the packages we maintain and join conversations on our Slack workspace by going to our website at [https://juliamolsim.github.io](https://juliamolsim.github.io/) .\r
\r
Our BoF session from JuliaCon 2021, \u201CBuilding a Chemistry and Materials Science Ecosystem in Julia,\u201D helped jumpstart the Slack community. A major subsequent output from those ongoing conversations was the development of the AtomsBase interface, defining a common set of functions for specifying atomic geometries. We\u2019re really excited about the prospect of this effort enabling great interoperability between different types of simulation and analysis as well as to share code for tasks like visualization and I/O. In fact, it already has begun to have this impact in a number of academic projects with international collaborators and funded by major agencies such as the US Department of Energy. A major part of the strength and impact of these efforts has been substantial investment of effort from the beginning by mathematicians, computer scientists, and domain scientists working together, a hallmark of the Julia community writ large and a major part of the reason we\u2019re building this community in Julia.\r
\r
This year, we\u2019re hosting a minisymposium to keep the community going strong, make new connections, show off cool projects, and collect new ideas! Our planned agenda (so far!) is as follows:\r
\r
1. Introduction to JuliaMolSim in general and AtomsBase in particular with brief showcase of packages adopting the interface so far\r
2. Some \u201Cdeeper-dive\u201D talks on packages now using AtomsBase, focusing on updates since last JuliaCon and also elucidating other emerging themes such as support for automatic differentiation (AD) and GPU utilization\r
    1. Chemellia machine learning ecosystem (Rachel Kurchin)\r
    2. Molly.jl particle simulation package (Joe Greener)\r
    3. DFTK.jl density functional theory package (Michael Herbst)\r
    4. CESMIX project (Emmanuel Lujan)\r
3. Other contributed talks from the JuliaMolSim community, including:\r
    1. Fermi.jl (Gustavo Aroeira)\r
    2. ACE.jl (Christoph Ortner)\r
    3. NQCDynamics.jl (James Gardner)\r
4. \u201CQuick pitch\u201D session: what\u2019s the next community project a la AtomsBase? Pitch your idea and find collaborators! (If you are interested in pitching, contact the minisymposium organizers and we will be in touch with more details). Some example topics could include:\r
    1. Plotting recipes (e.g. in Makie) for AtomsBase systems\r
    2. An ab initio MD engine based in Molly, utilizing DFTK for energy/force calculations via AtomsBase`,recording_license:"",do_not_record:!1,persons:[{id:9646,code:"BKJLVX",public_name:"Rachel Kurchin",biography:"rkurchin.github.io",answers:[]}],links:[],attachments:[],answers:[]}],Red:[{id:18122,guid:"fbf81ddc-b4de-59a5-bb4d-3c91fb7c7a74",logo:"",date:"2022-07-22T15:00:00+00:00",start:"15:00",duration:"03:00",room:"Red",slug:"juliacon-2022-18122-hands-on-ocean-modeling-and-ml-with-oceananigans-jl",url:"https://pretalx.com/juliacon-2022/talk/VAHYFE/",title:"Hands-on ocean modeling and ML with Oceananigans.jl",subtitle:"",track:null,type:"Workshop",language:"en",abstract:"Come get your feet wet with Oceananigans.jl, a native Julia, fast, friendly, flexible and fun ocean model. In the first half of this workshop participants will be helped to run and analyze one of several simple ocean problems. The problems relate to state-of-the-art challenges in climate science and computational science. In the second half we will examine Julia language features, packages and design choices that enable Oceananigans.jl.",description:`Oceananigans.jl is a state of the art ocean modeling tool written from scratch in Julia. Oceananigans uses an underlying finite volume, locally orthogonal staggered-grid fluid modeling paradigm. This allows Oceananigans to support everything from highly-idealized large-eddy-simulation studies of geophysical turbulence to large scale planetary circulation projects. The code is configured for different problems using native Julia scripting. Julia metaprogramming supports wide flexibility in numerical methods and supports large ensemble experiments. These latter style of experiment facilitate semi-automated Bayesian search that can be used to produce reduced-order models that emulate more detailed physical process models accurately.  Julia typing and dispatch is used to support discrete numerics involving staggered numerical grid locations and to support (through the Julia KernelAbstractions.jl package) GPU and CPU execution from a single code base. Advanced graphics with Makie.jl and data management using NCDatasets.jl and JLD2.jl are fully integrated. Integration of Oceananigans within SciML workflows for developing neural differentiable equation improvements to physics based schemes is also possible.\r
\r
In this workshop we cover both hands-on execution of a variety of different model configurations and exploring how key features of the Julia language and packages from the Julia ecosystem are used to enable a range of use cases.\r
\r
The workshop will include two parts. A first part will consist of breakout room sessions. Each room will have a lead who will walk participants through configuring and running an Oceananigans instance on either a cloud resource or on participants local systems. A second part will involve multiple Oceananigans.jl team members walking through the key Julia language aspects that make Oceananigans a flexible and fun tool to use for all manner of scientific ocean modeling problems on Earth and beyond.\r
\r
Workshop participants will get hands-on experience with real-world high-end scientific modeling for ocean and fluid problems in Julia. They will also learn about the how many elements of the Julia language and ecosystem can be used together to create a performant and expressive modeling tool that is also easy to engage with.`,recording_license:"",do_not_record:!1,persons:[{id:1156,code:"W7TEDS",public_name:"Chris Hill",biography:"Chris Hill is a computational scientist at MIT who has developed ocean and planetary models and modeling tools that are used by thousands of researchers yearly. He has been working with members of the Julia community from its earliest days.",answers:[]},{id:10455,code:"CJ9SDV",public_name:"Francis Poulin",biography:"Professor of Applied Mathematics at the University of Waterloo.",answers:[]},{id:10485,code:"JVB98C",public_name:"Gregory Wagner",biography:"Physical oceanographer working on approximate models for ocean turbulence",answers:[]},{id:903,code:"3C7UBC",public_name:"Valentin Churavy",biography:"asads",answers:[]},{id:18477,code:"QPR3V3",public_name:"Simone Silvestri",biography:null,answers:[]},{id:18478,code:"ECGMQA",public_name:"Tomas Chor",biography:"I'm a postdoctoral research at the University of Maryland, Dept of Atmospheric and Oceanic Science",answers:[]},{id:18479,code:"GRBYGP",public_name:"Suyash Bire",biography:null,answers:[]},{id:18482,code:"QN3AMH",public_name:"Rodrigo Duran",biography:"www.oceanresearch.xyz",answers:[]},{id:18493,code:"LN8KHT",public_name:"Jean-Michel Campin",biography:"Working with Oceananigans.jl",answers:[]}],links:[],attachments:[],answers:[]}]}},{index:5,date:"2022-07-23",day_start:"2022-07-23T04:00:00+00:00",day_end:"2022-07-24T03:59:00+00:00",rooms:{Green:[{id:16905,guid:"2f9e46b8-554f-5648-8ca4-6d4b3d297aa2",logo:"/media/juliacon-2022/submissions/F7WDXE/statsJulia_NmURM8n.png",date:"2022-07-23T10:00:00+00:00",start:"10:00",duration:"03:00",room:"Green",slug:"juliacon-2022-16905-introduction-to-julia-with-a-focus-on-statistics-in-hebrew-",url:"https://pretalx.com/juliacon-2022/talk/F7WDXE/",title:"Introduction to Julia with a focus on statistics (in Hebrew)",subtitle:"",track:null,type:"Workshop",language:"en",abstract:`This session has moved to Zoom. Please join with Zoom ID: 6376486897 at 2PM Israel time. \r
\r
This (Hebrew language) workshop provides an introduction to the Julia language for machine learning engineers, data-scientists, and statisticians. Attendees will gain a solid entry point for using Julia as their preferred data analysis tool.`,description:`This Juliacon 2022 workshop in Hebrew (\u05E2\u05D1\u05E8\u05D9\u05EA) is aimed at data-scientists, machine learning engineers, and statisticians that have experience with a language like Python or R, but have not used Julia previously. In learning to use Julia, a contemporary "stats based" approach is taken focusing on short scripts that achieve concrete goals. This is similar to the approach of the [Statistics with Julia book](https://statisticswithjulia.org/). \r
\r
The primary focus is on statistical applications and packages. The Julia language is covered as a by-product of the applications. Thus, this workshop is much more of a how to use Julia for stats course than a how to program in Julia course. This approach may be suitable for statisticians and data-scientists that tend to do their day-to-day scripting with a data and model based approach - as opposed to a software development approach.\r
\r
An extensive Jupyter notebook for the workshop together with data files is [here](https://github.com/yoninazarathy/StatisticsWithJuliaFromTheGroundUp-2022). You can install it to follow along. The Jupyter notebook is not in Hebrew. \r
\r
If you don't already have Julia with IJulia (Jupyter) installed, you can follow the instructions in [this video](https://www.youtube.com/watch?v=KJleqSITuRo). It is recommended that you have Julia 1.7.3 or higher installed.`,recording_license:"",do_not_record:!1,persons:[{id:9298,code:"777AC8",public_name:"Yoni Nazarathy",biography:"Associate Professor Yoni Nazarathy from the University of Queensland Australia, specializes in data science, probability and statistics. His specific research interests include scheduling, control, queueing theory, and machine learning. He has been at The University of Queensland for over a decade, teaching courses in the Masters of Data Science program and working on research. Prior to his previous academic positions in Melbourne and the Netherlands, he worked in the aerospace industry in Israel. He is the co-author of a data science book, [Statistics with Julia: Fundamentals for Data Science, Machine Learning and Artificial Intelligence](https://statisticswithjulia.org/) as well as an ongoing book with drafts available [The Mathematical Engineering of Deep Learning](https://deeplearningmath.org/).",answers:[]}],links:[],attachments:[],answers:[]},{id:18051,guid:"60511273-252d-577d-b6e7-85bbfb19b626",logo:"",date:"2022-07-23T14:00:00+00:00",start:"14:00",duration:"03:00",room:"Green",slug:"juliacon-2022-18051-interactive-data-visualizations-with-makie-jl",url:"https://pretalx.com/juliacon-2022/talk/FBLWD3/",title:"Interactive data visualizations with Makie.jl",subtitle:"",track:"JuliaCon",type:"Workshop",language:"en",abstract:"Makie.jl is a Julia-native interactive data visualization library. In this workshop, participants will learn how to create complex interactive and static plots, using the full range of tools Makie has to offer. Topics could include writing custom recipes, understanding the scene graph, mastering the layout system, handling complex observable structures and tweaking visual styles. The workshop will also be an opportunity to learn about the architecture and underlying ideas of Makie.",description:"The participants will follow along while different small interactive visualization projects are coded live, showing how to go from idea to implementation.",recording_license:"",do_not_record:!1,persons:[{id:10477,code:"37WXQK",public_name:"Julius Krumbiegel",biography:"Julius is a psychologist-turned-programmer who enjoys transforming raw data into visualizations that are both aesthetically pleasing and easy to understand.",answers:[]},{id:966,code:"JSJDXE",public_name:"Simon Danisch",biography:`Simon is a freelance software engineer who has been part of the Julia community for more than 9 years and is the author of many Julia packages:\r
* Makie\r
* GeometryBasics\r
* GPUArrays\r
* PackageCompiler\r
* JSServe\r
* FileIO`,answers:[]}],links:[],attachments:[],answers:[]}]}},{index:6,date:"2022-07-24",day_start:"2022-07-24T04:00:00+00:00",day_end:"2022-07-25T03:59:00+00:00",rooms:{Green:[{id:16549,guid:"e63b7458-8e2b-50cc-9332-bffeebdfa52c",logo:"",date:"2022-07-24T14:00:00+00:00",start:"14:00",duration:"03:00",room:"Green",slug:"juliacon-2022-16549-julia-repl-mastery-workshop",url:"https://pretalx.com/juliacon-2022/talk/PFUHDL/",title:"Julia REPL Mastery Workshop",subtitle:"",track:"JuliaCon",type:"Workshop",language:"en",abstract:"A fundamental Julia experience is feeling the power of computing at your fingertips - but how many of us squeeze the absolute most out of the Julia REPL? In this workshop, you'll go from 0 to hero in about 3 hours with a whopping collection of all the tips, tricks and goodies you could ever hope for in your Julia REPL experience.",description:`This workshop will be a jam-packed, hands-on tour of the Julia REPL so that beginners and experts alike can learn a few tips and tricks. Every Julia user spends a significant amount of coding time interacting with the REPL - my claim for this workshop is that all Julia users can save themselves more than 3 hours of productive coding time over their careers should they attend this workshop, so why not invest in yourself now?\r
Plan (pending review) for the material that will be covered:\r
* Navigation - moving around, basic commands, variables, shortcuts and keyboard combinations, cross language comparison of REPL features, Vim Mode homework\r
* Internals and configuration - Basic APIs, display control codes, terminals and font support, startup file options, prompt changing, flag configurations\r
* REPL Modes - Shell mode, Pkg mode, help mode, workflow demos for contributing code fixes, BuildYourOwnMode demo, Term.jl\r
* Tools and packages - OhMyREPL.jl, PkgTemplates.jl, Eyeball.jl, TerminalPager.jl, AbstractTrees.jl, Debugger.jl, UnicodePlots.jl, ProgressMeters.jl, PlutoREPL.jl assignment`,recording_license:"",do_not_record:!1,persons:[{id:1182,code:"JE89PF",public_name:"Miguel Raz Guzm\xE1n Macedo",biography:"Miguel Raz es un estudiante de f\xEDsica de la UNAM.",answers:[]}],links:[],attachments:[],answers:[]}]}},{index:7,date:"2022-07-25",day_start:"2022-07-25T04:00:00+00:00",day_end:"2022-07-26T03:59:00+00:00",rooms:{Green:[{id:18023,guid:"633277d2-9ec6-5e7c-bf82-370ebe0bf8c6",logo:"",date:"2022-07-25T14:00:00+00:00",start:"14:00",duration:"03:00",room:"Green",slug:"juliacon-2022-18023-differentiable-earth-system-models-in-julia",url:"https://pretalx.com/juliacon-2022/talk/UNVUDM/",title:"Differentiable Earth system models in Julia",subtitle:"",track:"JuliaCon",type:"Minisymposium",language:"en",abstract:"This minisymposium will feature the use of the differentiable programming paradigm applied to Earth System Models (ESMs). The goal is to exploit derivative information and seamlessly combine PDE-constrained optimization and scientific machine learning (SciML). Speakers will address (1) Why differentiable programming for ESMs; (2) What ESM applications are we targeting?; and (3) How are we realizing differentiable ESMs? Target ESMs include ice sheet, ocean, and solid Earth models.",description:`The differentiable programming paradigm offers large potential to improve Earth system models (ESMs) in at least two ways: (i) in the context of parameter calibration, state estimation, initialization for prediction, and uncertainty quantification derivative information (tangent linear, adjoint and Hessian) are key ingredients; (ii) combining PDE-constrained optimization with SciML approaches may be performed naturally in a composable way and within the same programming framework. This minisymposium is organized in three parts (all speakers listed are tentative):\r
\r
1/ Why differentiable programming for ESMs? Speakers will discuss the use of derivative information for PDE-constrained optimization in ice sheet (M. Morlighem, N. Petra), ocean (P. Heimbach) and solid Earth (B. Kaus) modeling; the use  of SciML in the context of ESMs (J. Le Sommer, A. Ramadhan); The use of adjoints for sensitivity analysis and uncertainty quantification (N. Loose).\r
\r
2/ What ESM applications are we targeting? The minisymposium will feature three ESM applications for\r
Global ocean modeling (C. Hill); ice sheet modeling (J. Bolibar, L. Raess).\r
\r
3/ How are we realizing differentiable ESMs? A key algorithmic framework is the use of general-purpose automatic differentiation. The Julia is developing a number of packages. ESM applications will likely push the envelope of the capability of existing AD tools. The minisymposium will present how these tools are being used in the context of ESMs (S. Williamson, M. Morlighem). Furthermore, specific algorithmic challenges in ongoing AD tool development will be highlighted (S. Narayanan/M. Schanen/...). \r
\r
The minisymposium seeks to engage both the ESM and the AD tool communities to advance their respective capability. There will be time for discussion. Ideally we are targeting a 3-hour mini symposium.`,recording_license:"",do_not_record:!1,persons:[{id:18410,code:"KKHQBQ",public_name:"Patrick Heimbach",biography:`I am a computational oceanographer, professor in the Jackson School of Geosciences, and W. A. \u201CTex\u201D Moncrief, Jr., chair III in Simulation-Based Engineering and Sciences in the Oden Institute at the University of Texas at Austin. At UT, I direct the CRIOS-UT.github.io group.\r
\r
My research focuses on ocean and ice dynamics and their role in the global climate system. A computational focus is the use of inverse methods and automatic differentiation applied to ocean and sea ice model parameter and state estimation, uncertainty quantification and observing system design. I earned my Ph.D. from the Max-Planck-Institute for Meteorology and the University of Hamburg, Germany. Prior to joining UT, I spent 16 years at MIT. I am the lead-PI of an NSF CSSI project DJ4Earth.github.io (since 08/2021).`,answers:[]},{id:18474,code:"PMC8EJ",public_name:"Nora Loose",biography:null,answers:[]},{id:18475,code:"89P8MK",public_name:"Mathieu Morlighem",biography:null,answers:[]},{id:18425,code:"NHMXEV",public_name:"Boris Kaus",biography:"Computational geodynamicist at the University of Mainz, Germany",answers:[]},{id:1156,code:"W7TEDS",public_name:"Chris Hill",biography:"Chris Hill is a computational scientist at MIT who has developed ocean and planetary models and modeling tools that are used by thousands of researchers yearly. He has been working with members of the Julia community from its earliest days.",answers:[]},{id:18485,code:"QNPKMA",public_name:"Sri Hari Krishna Narayanan",biography:"Sri Hari Krishna is a Computer Scientist at Argonne National Laboratory. He conducts research in automatic differentiation, develops AD tools, and applies them to different scientific domains.",answers:[]},{id:18490,code:"FSAGLX",public_name:"Sarah Williamson",biography:null,answers:[]}],links:[],attachments:[],answers:[]},{id:16904,guid:"c7a74b18-5993-53e9-905c-20cc1db06bff",logo:"",date:"2022-07-25T18:00:00+00:00",start:"18:00",duration:"03:00",room:"Green",slug:"juliacon-2022-16904-modeling-of-chemical-reaction-networks-using-catalyst-jl",url:"https://pretalx.com/juliacon-2022/talk/98UQX3/",title:"Modeling of Chemical Reaction Networks using Catalyst.jl",subtitle:"",track:"JuliaCon",type:"Workshop",language:"en",abstract:"Catalyst.jl is a modeling package for analysis and high performance simulation of chemical reaction networks (CRNs). It defines symbolic representations for CRNs, which can be created programmatically or specified via a domain specific language. Catalyst provides tooling to analyze models, and to translate CRNs to ModelingToolkit-based ODE, SDE, and jump process models. In this workshop we will overview how to generate, analyze, and efficiently solve such models across a variety of applications.",description:`Workshop Pluto notebooks will be available at https://github.com/TorkelE/JuliaCon2022_Catalyst_Workshop\r
\r
At the highest level, Catalyst models can be specified via a domain-specific language (DSL), where they can be concisely written as a list of chemical reactions. Such models are converted into a Symbolics.jl-based intermediate representation (IR), represented as a ModelingToolkit.jl AbstractSystem. This IR acts as a common target for many tools within SciML, enabling them to be applied to Catalyst-based models. Symbolic models can also be directly constructed using the symbolic IR, allowing programmatic construction of CRNs or extensions of DSL-defined CRNs.\r
\r
In this workshop, we will demonstrate how to generate CRN models through the Catalyst DSL and programmatically via the IR. Catalyst features such as custom rate laws, component-based modeling, and parametric stoichiometry will be explored to demonstrate the breadth of models supported by Catalyst. We will then illustrate how such models can be translated to other symbolic Modelingtoolkit-based mathematical representations, and simulated with SciML tooling. Such representations include deterministic ODE models (based on reaction rate equations), stochastic SDE models (based on chemical Langevin equations), and stochastic jump process models (based on the chemical master equation and Gillespie's method). For each of these representations, the DifferentialEquations.jl package provides a variety of solvers that can accurately and efficiently simulate the model's dynamics. We will also demonstrate further tools for analysis of CRN-based models, including methods for parameter fitting, network analysis, calculation of steady states, and bifurcation analysis (through the BifurcationKit.jl package).\r
\r
To help users with real-world applicability, we will demonstrate how to appropriately use the Catalyst and SciML tooling to scale simulations to tens of thousands of reactions in ways that exploit sparsity, giving easy access to methodologies which outperform competitor packages by orders of magnitude in performance. Aspects such as parallelization of simulations, automatic differentiation usage (in model calibration), and more will be discussed throughout the various topics to give users a complete view of how Catalyst.jl can impact their modeling workflows.`,recording_license:"",do_not_record:!1,persons:[{id:10560,code:"CKKFMJ",public_name:"Torkel Loman",biography:"Torkel Loman is a PhD student at the University of Cambridge, working on mathematical modelling of biochemical reaction networks in bacterial stress response.",answers:[]},{id:1224,code:"L3ZKDL",public_name:"Samuel Isaacson",biography:null,answers:[]}],links:[],attachments:[],answers:[]}],Red:[{id:16365,guid:"c43901e9-1a37-56c3-9b32-5c27838119b1",logo:"",date:"2022-07-25T18:00:00+00:00",start:"18:00",duration:"03:00",room:"Red",slug:"juliacon-2022-16365-julia-in-astronomy-astrophysics-research",url:"https://pretalx.com/juliacon-2022/talk/DFA3RD/",title:"Julia in Astronomy & Astrophysics Research",subtitle:"",track:"JuliaCon",type:"Minisymposium",language:"en",abstract:"This minisymposium aims to provide researchers in astronomers and astrophysicists an opportunity to share how Julia has enhanced their science and the challenges they encountered.  We aim to identify shared needs (e.g., opportunities for new/upgraded packages) that could significantly accelerate the adoption of Julia among the astronomical research community.  A secondary goal is to help strengthen the community of Julia developers active in astronomical research.",description:`This mini-symposium aims to help accelerate the adoption of Julia among astronomers and astrophysicists.  Astrophysicists have long been among the leaders in High-Performance Computing.  Large astronomical surveys continue to create new opportunities for researchers with the skills and tools to harness Big Data efficiently.  Early adopters of Julia have developed packages providing functionality commonly needed by the astronomical community (e.g., AstroLib,jl, AstroTime.jl, Cosmology.jl, FITSIO.jl, UnitfulAstro.jl) and/or gained experience applying Julia to their research problems.  According to NASA\u2019s Astrophysical Data System, ~30 astronomy papers include \u201CJulia\u201D and \u201CBezanson et al. (2017)\u201D, with over half of those being published since 2021.  This mini-symposium invite researchers with experience applying Julia to astronomical research to share their experiences through a series of short talks and followed by a panel discussion.  \r
     Talks should not emphasize the astronomical methods or conclusions, but rather how using Julia impacted their project.  How did Julia enhance their science or their productivity?   What challenges related to Julia did they encounter?  What work-arounds did they find?  What additions or upgrades to the Julia package ecosystem would be helpful for their future projects?  \u2026or for accelerating adoption of Julia among the astronomical community?  What resources did they use for integrating their research groups and/or collaborators into the Julia community?  Where could filling a gap in documentation and or developing improved training materials be particularly impactful for helping astronomers to transition to Julia?`,recording_license:"",do_not_record:!1,persons:[{id:17130,code:"VFFPB7",public_name:"Eric B. Ford",biography:'<a href="https://personal.psu.edu/~ebf11">Eric Ford</a> is a Professor of <a href="http://astro.psu.edu/">Astronomy & Astrophysics</a> at the Pennsylvania State University, where he is active in its <a href="https://www.icds.psu.edu/">Institute for Computational & Data Sciences</a>, <a href="https://astrostatistics.psu.edu/">Center for Astrostatistics</a>, and <a href="https://exoplanets.psu.edu/">Center for Exoplanets & Habitable Worlds</a>.  Ford\u2019s research focuses on detecting and characterizing planetary systems around other stars.  This often involves using Julia to apply modern Bayesian methods to improve the interpretation of exoplanet observations.  Ford has taught a graduate-level class on <a href="https://psuastro528.github.io/">High-Performance Computing for Astrophysics</a> using Julia since 2014.',answers:[]}],links:[],attachments:[],answers:[]}]}},{index:8,date:"2022-07-26",day_start:"2022-07-26T04:00:00+00:00",day_end:"2022-07-27T03:59:00+00:00",rooms:{Green:[{id:17892,guid:"4f0c38ab-8f1e-5397-9cdf-8ea2d041eb57",logo:"/media/juliacon-2022/submissions/LUWYRJ/Julia_for_HPC-minisymposium-juliacon22_AKrxsio.png",date:"2022-07-26T14:00:00+00:00",start:"14:00",duration:"03:00",room:"Green",slug:"juliacon-2022-17892-julia-for-high-performance-computing",url:"https://pretalx.com/juliacon-2022/talk/LUWYRJ/",title:"Julia for High-Performance Computing",subtitle:"",track:"JuliaCon",type:"Minisymposium",language:"en",abstract:'The "Julia for HPC" minisymposium aims to gather current and prospective Julia practitioners in the field of high-performance computing (HPC) from multidisciplinary applications. We invite participation from industry, academia, and government institutions interested in Julia\u2019s capabilities for supercomputing. The goal is to provide a venue for Julia enthusiasts to share best practices, discuss current limitations, and identify future developments in the scientific HPC community.',description:`**YouTube Link:** https://www.youtube.com/watch?v=fog1x9rs71Q\r
\r
As we approach the era of exascale computing, scalable performance and fast development on extremely heterogeneous hardware have become ever more important aspects for high-performance computing (HPC). Scientists and developers with interest in Julia for HPC need to know how to leverage the capabilities of the  language and ecosystem to address these issues and which tools and best practices can help them to achieve their performance goals.\r
\r
What do we mean by HPC? While HPC can be mainly associated with running large-scale physical simulations like computational fluid dynamics, molecular dynamics, high-energy physics, climate models etc., we use a more inclusive definition beyond the scope of computational science and engineering. More recently, rapid prototyping with high-productivity languages like Julia, machine learning training, data management, computer science research, research software engineering, large scale data visualization and in-situ analysis have expanded the scope for defining HPC. For us, the core of HPC is not to run simple test problems faster but involves everything that enables solving challenging problems in simulation or data science, on heterogeneous hardware platforms, from a high-end workstation to the world's largest supercomputers powered with different vendors CPUs and accelerators (e.g. GPUs).\r
\r
In this two-hour minisymposium, we will give an overview of the current state of affairs of Julia for HPC in a series of eight 10-minute talks. The focus of these overview talks is to introduce and motivate the audience by highlighting aspects making the Julia language beneficial for scientific HPC workflows such as scalable deployments, compute accelerator support, user support, and HPC applications. In addition, we have reserved some time for participants to interact, discuss and share the current landscape of their investments in Julia HPC, while encouraging networking with their colleagues over topics of common interest.\r
\r
The minisymposium schedule, with confirmed speakers and topics, is as follows:\r
\r
* 0:00: *William F Godoy (ORNL) & Michael Schlottke-Lakemper (U Stuttgart/HLRS):* **Julia for High-Performance Computing**\r
* 0:05: *Samuel Omlin (CSCS):* **Scalability of the Julia/GPU stack**\r
* 0:15: *Simon Byrne (Caltech/CliMA):* **MPI.jl**\r
* 0:25: Q&A\r
* 0:30: *Tim Besard (Julia Computing):* **CUDA.jl: Update on new features and developments**\r
* 0:40: *Julian Samaroo (MIT):* **AMDGPU.jl: State of development and roadmap to the future**\r
* 0:50: Q&A\r
* 1:00: *Albert Reuther (MIT):* **Supporting Julia Users at MIT LL Supercomputing Center**\r
* 1:10: *Johannes Blaschke (NERSC):* **Supporting Julia users on NERSC\u2019s \u201CCori\u201D and \u201CPerlmutter\u201D systems**\r
* 1:20: Q&A\r
* 1:25: *Michael Schlottke-Lakemper (U Stuttgart/HLRS):* **Running Julia code in parallel with MPI: Lessons learned**\r
* 1:35: *Ludovic R\xE4ss (ETH Zurich):* **Julia and GPU-HPC for geoscience applications**\r
* 1:45: Q&A, Discussion & Wrap up\r
\r
The overall goal of the minisymposium is to identify and summarize current practices, limitations, and future developments as Julia experiences growth and positions itself in the larger HPC community due to its appeal in scientific computing. It also exemplifies the strength of the existing Julia HPC community that collaboratively prepared this event. We are an international, multi institutional, and multi disciplinary group interested in advancing Julia for HPC applications in our academic and national laboratory environments. We would like to welcome new people from multiple backgrounds sharing our interest and bring them together in this minisymposium.\r
\r
In this spirit, the minisymposium will serve as a starting point for further Julia HPC activities at JuliaCon 2022. During the main conference, **a Birds of Feather session** will provide an opportunity to bring together the community for more discussions and to allow new HPC users to join the conversation. Furthermore, a number of talks will be dedicated to topics relevant for HPC developers and users alike.`,recording_license:"",do_not_record:!1,persons:[{id:10161,code:"ZBB3MC",public_name:"Michael Schlottke-Lakemper",biography:"Michael is a group leader and research software engineer at the High-Performance Computing Center Stuttgart of the University of Stuttgart, Germany. His research focus is on numerical methods for adaptive multi-physics simulations, high-performance computing with Julia, and scientific machine learning.",answers:[]},{id:4153,code:"R3SWQF",public_name:"Carsten Bauer",biography:"Theoretical Physicist - Scientific HPC Advisor - National High Performance Computing (NHR) - Paderborn Center for Parallel Computing (PC\xB2)",answers:[]},{id:10183,code:"WYXDAB",public_name:"Hendrik Ranocha",biography:"I am interested in numerical analysis and scientific computing with applications in science and engineering. In particular, I like to analyze and develop numerical methods for differential equations, focusing on stability, mimetic properties, structure preservation, and efficiency. I started with the common mix of C, C++, Fortran, Python, Matlab, Mathematica etc. Nowadays, I am using Julia nearly exclusively for my work. Currently, I am an Assistant Professor in Applied Mathematics at the University of Hamburg. If you want to know more about me, please visit [my website](https://ranocha.de/).",answers:[]},{id:10503,code:"K9PVSE",public_name:"Johannes Blaschke",biography:null,answers:[]},{id:18329,code:"898839",public_name:"Jeffrey Vetter",biography:null,answers:[]}],links:[],attachments:[],answers:[]}],Red:[{id:16291,guid:"e1cbae2b-46b5-58cb-b446-20b5c7b36d2e",logo:"",date:"2022-07-26T14:00:00+00:00",start:"14:00",duration:"03:00",room:"Red",slug:"juliacon-2022-16291-a-complete-guide-to-efficient-transformations-of-data-frames",url:"https://pretalx.com/juliacon-2022/talk/83E8CW/",title:"A Complete Guide to Efficient Transformations of data frames",subtitle:"",track:"JuliaCon",type:"Workshop",language:"en",abstract:"DataFrames.jl provides a comprehensive set of functions that allow performing transformations of tabular data using an operation specification language. This language lets users pass columns from a source data frame, a function to apply to them, and column names to store the result in the target data frame. In this workshop, I will explain the functionalities that it provides. [Here](https://github.com/bkamins/JuliaCon2022-DataFrames-Tutorial) you can find workshop materials.",description:"The operation specification language that is part of DataFrames.jl can be used to perform transformations of data frames and split-apply-combine operations of grouped data frames. It is supported by the following functions `combine`, `select`, `select!`, `transform`, `transform!`, `subset`, and `subset!`.\r\n\r\nOver the years, following users' requests, DataFrames.jl operation specification language has evolved over the years to efficiently support virtually any operation typically needed when working with tabular data. However, this means that it has become relatively complex. New users often feel overwhelmed by the number of options it provides.\r\n\r\nThis workshop aims to give a comprehensive guide to DataFrames.jl operation specification language. The presented material will help users learn this language and will be a reference resource.\r\n\r\nWorkshop materials are available for download [here](https://github.com/bkamins/JuliaCon2022-DataFrames-Tutorial).",recording_license:"",do_not_record:!1,persons:[{id:929,code:"DHRPEA",public_name:"Bogumi\u0142 Kami\u0144ski",biography:`I am a researcher in the fields of operations research and computational social science.\r
\r
For development I mostly use Julia language.\r
\r
I am one of the maintainers of DataFrames.jl.`,answers:[]}],links:[],attachments:[],answers:[]}]}},{index:9,date:"2022-07-27",day_start:"2022-07-27T04:00:00+00:00",day_end:"2022-07-28T03:59:00+00:00",rooms:{Green:[{id:18033,guid:"e92ad33e-5199-56a8-bae6-c656ebd4fbdd",logo:"",date:"2022-07-27T12:30:00+00:00",start:"12:30",duration:"00:10",room:"Green",slug:"juliacon-2022-18033--do-block-considered-harmless",url:"https://pretalx.com/juliacon-2022/talk/WKNY78/",title:"`do block` considered harmless",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Is life possible without for-loops? This talk reviews some syntactic constructs available in Julia, especially the do-block, and relates them to programming language theory concepts.",description:'First we go through the similarities between for-loops, comprehensions and functions such as `map` and `reduce`. Programming as building useful abstractions. How "constraints liberate", and abstract ideas can impact concrete computational performance. Finally we discuss a couple of new features in Julia 1.9, especially `Unfold`.',recording_license:"",do_not_record:!1,persons:[{id:994,code:"KXTSV7",public_name:"Nicolau Leal Werneck",biography:"Electrical Engineering PhD from Brazil specializing in computer vision and pattern recognition. Julia programmer since v1.0 and scruffy functional programmer.",answers:[]}],links:[],attachments:[],answers:[]},{id:18114,guid:"477c327f-2126-5f4a-a928-5d3b7aebd160",logo:"",date:"2022-07-27T12:40:00+00:00",start:"12:40",duration:"00:10",room:"Green",slug:"juliacon-2022-18114-teaching-with-julia-my-experience-",url:"https://pretalx.com/juliacon-2022/talk/KGLNUH/",title:"Teaching with Julia (my experience)",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"I am tenure at the University and I teach several courses of Computer Science. In this talk of 10 minutes I will teach how I will my use of Julia as a useful resource for teaching. In this talk I will introduce how I have used Pluto/PlutoSliderServer to explain concept and to allow students to check some implementations. Also, I show an online web for creating easily online quiz for Moodle. Finally, I have used it to prototype some algorithms that later the students should implement.",description:`I am tenure at the University and I teach several courses of Computer Science. Some time ago I started to use Julia in my research, and more recently I have started to use it as a teaboth ching resource. In this talk I do not refer Julia as the programming language for students (they are last courses in which students can use whatever programming language they want), but as a resource to create tools to help me in the teaching.\r
\r
In this regards, I have used Julia in three different approach, that I will quickly cover:\r
\r
- For explaining concepts, I have used Pluto notebooks to visualize them. Also, recently I have used PlutoSliderServer (as Pluto but without editing option) to allow students to check some calculations they have to do during their exercises. An example is https://mh.danimolina.net/ (in Spanish).\r
\r
- Due to the pandemic period, the use of online tests in Moodle has increased a lot. There are several formats to create them, but they are not intuitive enough for non-technical people. In order to solve that, I have created an online web to create easily the online quiz for Moodle (https://pradofacil.danimolina.net/, in Spanish), with a simple syntax that people from different background can easily use it.\r
\r
- Finally, in some courses student must implement several algorithms. In order to identify the best parameter values, and to identify the best approaches to implements them, I previously solve them in Julia. Also, it has serve me to predict how much computational time they will require. In my experience, although some specific implementation in C++ is faster, the average implementations takes similar time than using Julia. Many implementations are slower than my Julia implementation, due to some developing decisions.\r
\r
I consider this talk could be interesting for audience due to the following reasons:\r
\r
- It gives a very general view of the possibilities of Julia as a teaching resource.\r
\r
- It can be useful for other teachers giving ideas of integrating Julia in their portfolio.\r
\r
- It shows my personal experience, and the feedback obtained.\r
\r
I will be able to prepare the talk both in English and in Spanish. If it is accepted I will create an English version of the shown resources.`,recording_license:"",do_not_record:!1,persons:[{id:4442,code:"LM37DY",public_name:"Daniel Molina",biography:"I am tenure in Computer Science at the University of Granada, Spain. I strongly support free software in my life and use it daily in my teaching. I learned Julia more than a year ago, mainly for research, in Machine Learning and Optimization, but also for teaching.",answers:[]}],links:[],attachments:[],answers:[]},{id:17997,guid:"0ebccf54-2da6-5f2f-84dd-2bdf78508c6f",logo:"/media/juliacon-2022/submissions/X37FHS/cbl_2d_juliacon_lxvYT0T.png",date:"2022-07-27T12:50:00+00:00",start:"12:50",duration:"00:10",room:"Green",slug:"juliacon-2022-17997-simulation-of-atmospheric-turbulence-with-microhh-jl",url:"https://pretalx.com/juliacon-2022/talk/X37FHS/",title:"Simulation of atmospheric turbulence with MicroHH.jl",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Turbulence in the atmosphere is often studied using 3D simulations as a virtual laboratory. Most experiments require code modification by users, but this is hard, because most codes are written in low-level languages as Fortran and C++. MicroHH.jl, a Julia port of the dynamical core of MicroHH, has been designed to solve this problem. It is built on MPI.jl, LoopVectorization.jl, CUDA.jl, and HDF5.jl for the IO. Interaction with running simulations is made possible via user scripts.",description:"",recording_license:"",do_not_record:!1,persons:[{id:17117,code:"PTRG8U",public_name:"Chiel van Heerwaarden",biography:"I am an atmospheric scientist trying to understand the interactions between turbulence, clouds, radiation and the land surface with 3D simulation and field observations (see chiel.ghost.io). The main tool of our research lab is MicroHH, our in-house C++/CUDA 3D simulation code. Recently, I have ported the dynamical core of MicroHH to Julia to make the code more accessible to students, as C++ is often too complex to learn for a short project, and have a tool for future SciML projects.",answers:[]}],links:[],attachments:[],answers:[]},{id:17242,guid:"da86161b-a720-5012-b266-8833580d5c08",logo:"/media/juliacon-2022/submissions/XRQRK3/ProtoSyn_ocFsqVN.png",date:"2022-07-27T13:00:00+00:00",start:"13:00",duration:"00:10",room:"Green",slug:"juliacon-2022-17242-protosyn-jl-a-package-for-molecular-manipulation-and-simulation",url:"https://pretalx.com/juliacon-2022/talk/XRQRK3/",title:"ProtoSyn.jl: a package for molecular manipulation and simulation",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:`ProtoSyn.jl is an open-source alternative to molecular manipulation and simulations software, built with a modular architecture and offering a clean canvas where new protocols and models can be tested and benchmarked. By delivering good documentation, ProtoSyn.jl aims to lower the entry barrier to inexperienced scientists and allow a \u201Cplug-and-play\u201D experience when implementing modifications. Learn more on the project\u2019s GitHub page:\r
https://github.com/sergio-santos-group/ProtoSyn.jl`,description:`The ever-increasing expansion in computer power felt in the last few decades has fuelled a revolution in the way we make science. Modern labs are empowered by large databases, efficient collaboration tools and fast molecular simulation software packages that save both time and money. Preliminary screening of new drug targets or protein designs are just some examples of recent applications of such tools. However, in this field, users have been experiencing a wider gap between expectations and the available technology: existing solutions are quickly becoming outdated, with legacy code and poor documentation.\r
On the scope of protein design, for example, the Rosetta software (and its Python wrap, PyRosetta) have become ubiquitous in any modern lab, despite suffering from the two-language problem and being virtually opaque to any attempt to modify or improve the source code. Such impediment has caused a severe lag in implementing new and modern solutions, such as GPU usage, cloud-based distributed computing or even molecular energy/forces calculations using machine learning models. Implementations are eventually added as single in-house scripts or patch code that lacks cohesion and proper documentation, steepening the learning curve to inexperienced users. Despite Rosetta\u2019s massive and warranted success, there\u2019s room for improvement. \r
	ProtoSyn.jl, taking advantage of the growing Julia programming language and community, intends to provide an open-source, robust and simple to use package for molecular manipulation and simulation. Some of its functionalities include a complete set of molecular manipulation tools (add, remove and mutate residues, apply dihedral rotations and/or rotamers, apply secondary structures, copy and paste fragments, loops and other structures, include non-canonical aminoacids, post-translational modifications and even ramified polymers structures, such as glycoproteins or polysaccharides, among others), common simulation algorithms (such as Monte-Carlo or Steepest Descent), custom energy functions, etc. Much like setting up a puzzle, ProtoSyn.jl offers blocks of functions that can be mixed and matched to produce arbitrarily complex simulation algorithms. Capitalizing on recent advances, ProtoSyn.jl delivers a \u201Cplug-and-play\u201D experience: users are encouraged to include novel applications, such as machine learning models for energy/forces calculations, by following clean documentation guides, complete with examples and tutorials. Enjoying the advantages Julia, ProtoSyn.jl can perform calculations on the GPU (using CUDA.jl), employ SIMD technology (using SIMD.jl), carry out distributed computing tasks (using Distributed.jl) and even directly call Python code (using PyCall.jl).\r
	In a nutshell, ProtoSyn.jl intends to be an open-source alternative to molecular manipulation and simulations software\u2019s, focusing on modularity and proper documentation, and offering a clean canvas where new protocols, algorithms and models can be tested, benchmarked and shared. Learn more on the project\u2019s GitHub page:\r
https://github.com/sergio-santos-group/ProtoSyn.jl`,recording_license:"",do_not_record:!1,persons:[{id:10289,code:"YK78JV",public_name:"Jos\xE9 Pereira",biography:"Jos\xE9 M. S. Pereira is a Biochemistry PhD student at CICECO-University of Aveiro Institute of Materials since 2018. He finished his Master\u2019s on Biotechnology in the University of Aveiro, where the focus of his thesis was on the subject of bioremediation of waste water sources by filtration with activated bio-carbons. As a product of his Master\u2019s thesis, Jos\xE9 Pereira developed http://carbgen.web.ua.pt/, a peer-reviewed online tool for the design of atomic carbon models. Starting his PhD, Jos\xE9 Pereira shifted his focus for the computational design of peptides, while continuing to pursue scientific software development. He participated in the Board of European Students of Technology 2017 Winter Course, in Paris, France, was awarded a Fulbright scholarship for a 4-month student exchange at Rutgers University, New Jersey, USA, and won the TOP3 award at European Innovation Academy 2021 for his work on ProtoSyn (https://github.com/sergio-santos-group/ProtoSyn.jl), the developed software on the scope of his PhD thesis. He authored 2 peer-reviewed papers and participated in over 20 conferences.",answers:[]}],links:[],attachments:[],answers:[]},{id:17255,guid:"bb7f2713-6a72-5d73-b4c3-d9559d4b9145",logo:"/media/juliacon-2022/submissions/A9SRVU/JuliaPlanners_ignaBTJ.png",date:"2022-07-27T13:10:00+00:00",start:"13:10",duration:"00:10",room:"Green",slug:"juliacon-2022-17255-pddl-jl-a-fast-and-flexible-interface-for-automated-planning",url:"https://pretalx.com/juliacon-2022/talk/A9SRVU/",title:"PDDL.jl: A fast and flexible interface for automated planning",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"The Planning Domain Definition Language (PDDL) is a formal specification language for symbolic planning problems and domains that is widely used by the AI planning community. This talk presents PDDL.jl, a fast and flexible interface for planning over PDDL domains. It aims to be what PyTorch is to deep learning, or what PPLs are to Bayesian inference: A general high-performance platform for contemporary AI applications and research programs that leverage automated symbolic planning.",description:`The [Planning Domain Definition Language (PDDL)](https://en.wikipedia.org/wiki/Planning_Domain_Definition_Language) is a formal specification language for symbolic planning problems and domains that is widely used by the AI planning community. However, most implementations of PDDL are closely tied to particular planning systems and algorithms, and are not designed for interoperability or modular use within larger AI systems. This limitation makes it difficult to support extensions to PDDL without implementing a dedicated planner for that extension, inhibiting the generality, reach, and adoption of automated planning.\r
\r
To address these limitations, we present [**PDDL.jl**](https://github.com/JuliaPlanners/PDDL.jl), an extensible parser, interpreter, and compiler interface for fast and flexible AI planning. PDDL.jl exposes the semantics of planning domains through a common interface for executing actions, querying state variables, and other basic operations used within AI planning applications. PDDL.jl also supports the extension of PDDL semantics (e.g. to stochastic and continuous domains), domain abstraction for generalized heuristic search (via abstract interpretation), and domain compilation for efficient planning, enabling speed and flexibility for PDDL and its many descendants.\r
\r
Collectively, these features allow PDDL.jl to serve as a general high-performance platform for AI applications and research programs that leverage the integration of symbolic planning with other AI technologies, such as neuro-symbolic reinforcement learning, probabilistic programming, and Bayesian inverse planning for value learning and goal inference.`,recording_license:"",do_not_record:!1,persons:[{id:10333,code:"CFLQJP",public_name:"Xuan (Tan Zhi Xuan)",biography:"PhD student studying AI, cognitive science, automated planning, and probabilistic programming.",answers:[]}],links:[],attachments:[],answers:[]},{id:17942,guid:"407b08fc-9a96-536c-8053-a1ad632d0014",logo:"",date:"2022-07-27T13:20:00+00:00",start:"13:20",duration:"00:10",room:"Green",slug:"juliacon-2022-17942-real-time-i-o-and-multitasking-julia-for-medical-imaging",url:"https://pretalx.com/juliacon-2022/talk/ZPVDSR/",title:"Real-Time, I/O, and Multitasking: Julia for Medical Imaging",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"In this talk, we show how to use Julia to build the system software for a medical imaging device. Such a device is a distributed system that has to coordinate the handling of real-time signals and asynchronous tasks. The talk will highlight the key parts and design patterns of our software stack. We show how we used a variety of Julia features to implement the control logic of the entire imaging device and the coordination and communication with the large number of sub-devices it controls.",description:`Medical imaging devices are complex distributed systems that can feature a large variety of different parts from power amplifiers and circuitry for safety and control to robots, motors and pumps to signal generation and acquisition units. During measurements all these heterogeneous devices need to be coordinated to produce the data from which a tomographic image can be reconstructed. A central part of a measurement is the synchronous multi-channel acquisition and generation of signals. Contrary to other parts of the measurement process, hard real-time requirements typically apply here.\r
\r
In this talk, we showcase a Julia software stack for the new tomographic imaging modality Magnetic Particle Imaging (MPI). Our software stack is composed of the MPIMeasurements.jl package and a Julia client library from the RedPitayaDAQServer project. The resulting system is a framework that allows us to load different device combinations from configuration files and and perform different measurements with them. In particular, the talk will outline two of the main challenges we faced during development and how they have been resolved using several of Julia's features.\r
 \r
The first challenge is the coordination of a varying number of heterogenous devices in a maintainable and extendable manner. This is especially important for MPI, as a very common approach to image reconstruction requires a very time-intensive calibration process, where a quick and intertwined coordination of devices could save hours of invaluable scan time. Julia tasks and multi-threading with threads dedicated to specific tasks allowed us implement a very flexible architecture for managing all the devices.\r
 \r
The second challenge is the configuration of a cluster of data acquisition boards and the transmission of real-time signals from this cluster. The cluster is realized using the low-cost RedPitaya STEMlab hardware and open-source software components provided in our RedPitayaDAQServer project, which include a Julia client library. To achieve real-time signal transmission, the Julia client needs to communicate with the servers running on each data acquisition board of the homogenous cluster and maintain consistent high network performance to ensure that no data loss occurs. Our solutions here involve Julia tasks, channels, metaprogramming and multiple-dispatch to implement an interface to our data acquisition boards that allows for batch execution of commands and high performance continuous data transmission.\r
\r
Core packages being presented:\r
    \u2022 https://github.com/MagneticParticleImaging/MPIMeasurements.jl\r
    \u2022 https://github.com/tknopp/RedPitayaDAQServer`,recording_license:"",do_not_record:!1,persons:[{id:18353,code:"NXJKDH",public_name:"Niklas Hackelberg",biography:"I'm a PHD student working on Magnetic Particle Imaging at the Institute for Biomedical Imaging at the University Medical Center Hamburg-Eppendorf and the Hamburg University of Technology in Germany.",answers:[]}],links:[],attachments:[],answers:[]},{id:17065,guid:"2cb90936-874e-585a-b68a-fae5dcee6725",logo:"",date:"2022-07-27T13:30:00+00:00",start:"13:30",duration:"00:10",room:"Green",slug:"juliacon-2022-17065-build-an-extensible-gallery-of-examples",url:"https://pretalx.com/juliacon-2022/talk/ZFUAHG/",title:"Build an extensible gallery of examples",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"Examples are an essential part of the package documentation. In this talk, I'll introduce DemoCards.jl as a plugin package for Documenter to manage your demo files. I'll explain its design and show how it is used to build the demos in JuliaImages and JuliaPlots. Package authors and document writers are potential users of this package.",description:"",recording_license:"",do_not_record:!1,persons:[{id:17985,code:"G3HPCS",public_name:"Johnny Chen",biography:"I'm a Ph.D. student in East China Normal University, I also maintain the JuliaImages ecosystem and the JuliaCN community. More details on GitHub @johnnychen94.",answers:[]}],links:[],attachments:[],answers:[]},{id:18053,guid:"504f28d6-0bee-5ee4-8ca1-ca0c3164d95e",logo:"",date:"2022-07-27T14:30:00+00:00",start:"14:30",duration:"00:10",room:"Green",slug:"juliacon-2022-18053-comrade-high-performance-black-hole-imaging",url:"https://pretalx.com/juliacon-2022/talk/3LHDTD/",title:"Comrade: High-Performance Black Hole Imaging",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"In 2019 the Event Horizon Telescope (EHT) Collaboration produced the first image of a black hole. This talk details how Julia has been an essential tool for EHT black hole imaging and the advancement of black hole science. I will demonstrate how Julia\u2019s features such as multiple dispatch, differentiable programming, and composability have enabled orders of magnitude performance improvement, moving black hole imaging from clusters to a single laptop.",description:`In 2019 the global Event Horizon Telescope (EHT) made history by producing the first-ever image of a black hole on horizon scales. However, imaging a black hole is a complicated task. The EHT is a radio interferometer and does not directly produce the on-sky image. Instead, it measures the Fourier transform of the image. Furthermore, the telescope only samples the image at a handful of points in the Fourier domain. As a result of the incomplete Fourier sampling, infinitely many images are consistent with the EHT observations. Quantifying this uncertainty is imperative for any EHT analyses and black hole science as a whole. \r
\r
Bayesian inference provides a natural avenue to quantify image uncertainty. However, this approach is computationally demanding. Due to computational complexity, low-level languages (e.g., C++) are required to make the calculation feasible. On the other hand, interactivity is critical when modeling, as the usual workflow involves choosing an image structure, applying it to the data, and graphically assessing the results. Incorporating interactivity into the modeling pipeline requires a second package written in Python. Historically, this separation has increased the learning curve and limited the adoption of Bayesian methods. \r
\r
In the first part of the talk, I will introduce Comrade. Comrade is a Julia Bayesian black hole imaging package geared towards EHT and next-generation EHT (ngEHT) analyses. This package aims to be highly flexible, including many image models such as geometric, imaging, and physical accretion models. Additionally, Comrade is fast. In fact, it is over 100x faster than other EHT modeling packages while using far fewer resources. This drastic speed increase was due to Julia\u2019s excellent introspection, package management, and auto differentiation libraries. \r
\r
In the second part of my talk, I will detail how this performance increase has enabled novel black hole research and will be vital for future black hole science. Within the next decade, the ngEHT will increase its number of observations and its data volume per observation by an order of magnitude to produce higher-quality images. As a result of this significant increase in data, the ngEHT will require new tools. I will explain how Julia can play a vital role in next-generation black hole science and what additional language features are needed.`,recording_license:"",do_not_record:!1,persons:[{id:17397,code:"KWBFEW",public_name:"Paul Tiede",biography:'Paul Tiede obtained his Ph.D. degree at the University of Waterloo and Perimeter Institute in 2021. Afterward, he joined the Harvard & Smithsonian | Center for Astrophysics and the Black Hole Initiative. He is interested in the intersection of accretion modeling and statistical modeling. As a member of the Event Horizon Telescope, he has developed modeling and simulation techniques for analyzing time-variable emission or "flares" that could enable high-precision measurements of gravity. Additionally, he is a core developer of numerous software packages for the EHT written in Julia, C++, and Python.',answers:[]}],links:[],attachments:[],answers:[]},{id:18140,guid:"139a3eef-94e3-5589-855e-a2fd13bca151",logo:"",date:"2022-07-27T14:40:00+00:00",start:"14:40",duration:"00:10",room:"Green",slug:"juliacon-2022-18140-reaction-rates-and-phase-diagrams-in-electrochemicalkinetics-jl",url:"https://pretalx.com/juliacon-2022/talk/LJYRGJ/",title:"Reaction rates and phase diagrams in ElectrochemicalKinetics.jl",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"I will introduce ElectrochemicalKinetics.jl, a package that implements a variety of models for electrochemical reaction rates (such as Butler-Volmer or Marcus-Hush-Chidsey). It can also fit model parameters and construct nonequilibrium phase diagrams. While the package has already been of great use in electrochemical research applications, I will focus more on the design choices as well as the challenges that have come up in implementing automatic differentiation support.",description:"In electrochemical reaction modeling, there are a variety of mathematical models (such as Butler-Volmer, Marcus, or Marcus-Hush-Chidsey kinetics) used to describe the relationship between the overpotential and the reaction rate (or electric current). Another important entity is the inverse of this function, i.e. given a current, what overpotential would be needed to drive it? Most of the models used do not have analytical inverses, so inverting them requires an optimization problem to be solved.\r\n\r\nIn ElectrochemicalKinetics.jl, I created a generic interface for computing these reaction rates and overpotentials, as well as using these quantities for other analyses such as fitting model parameters or constructing nonequilibrium phase diagrams, important for predicting, for example, behavior of a battery under fast charge or discharge conditions. Given a `KineticModel` object `m` we can always compute the rate constant at a given overpotential with the same syntax, no matter if `m isa ButlerVolmer` or `m isa Marcus` or any other implemented model type. This allows for easy comparison between these models, including when analyzing real data.\r\n\r\nWe can also construct nonequilibrium phase diagrams, to, for example, understand and predict lithium intercalation behavior in a battery at various charge or discharge rates. Building these phase diagrams requires calling the inverse function mentioned above and using it within another optimization (to satisfy the thermodynamic common-tangent condition), making automatic differentiation challenging. I will also discuss some of these challenges and the solutions I have found for them so far.",recording_license:"",do_not_record:!1,persons:[{id:9646,code:"BKJLVX",public_name:"Rachel Kurchin",biography:"rkurchin.github.io",answers:[]}],links:[],attachments:[],answers:[]},{id:17683,guid:"853cdbbf-8cf0-5a89-a40d-bf897eafc1c8",logo:"/media/juliacon-2022/submissions/BLBKZM/71478307_RzFeKVm.png",date:"2022-07-27T14:50:00+00:00",start:"14:50",duration:"00:10",room:"Green",slug:"juliacon-2022-17683-rvspectml-precision-velocities-from-spectroscopic-time-series",url:"https://pretalx.com/juliacon-2022/talk/BLBKZM/",title:"RVSpectML:  Precision Velocities from Spectroscopic Time Series",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Astronomers have detected nearly a thousand exoplanets by precisely charting the radial velocity (RV) wobble of their host stars.  The [RVSpectML](https://rvspectml.github.io/RvSpectML-Overview/) family of packages is a new, open-source, modular and performant pipeline for measuring radial velocities and stellar variability indicators from spectroscopic time-series.   This talk aims to give potential users and/or developers an overview of the component packages and their status.",description:`*Purpose:* \u200BThe RVSpectML family of packages provides performant implementations of both traditional methods for measuring precise radial velocities (e.g., computing RVs from CCFs or template matching) and a variety of physics-informed machine learning-based approaches to mitigating stellar variability (e.g., Doppler-constrained PCA, Scalpels, custom line lists, Gaussian process latent variable models).  It aims to make it practical for researchers to experiment with new approaches.  Additionally, it aims to help astronomers improve the robustness of exoplanet discoveries by exploring the sensitivity of their results to choice of data analysis algorithm.\u200B\r
\r
*Context:*  Recently, NASA and NSF chartered the [Extreme Precision Radial Velocity Working Group](https://exoplanets.nasa.gov/exep/NNExplore/EPRV/) to recommend a plan for detecting potentially Earth-like planets around other stars.  Their recommendations included developing a modular, customizable, and open-source pipeline for analyzing spectroscopic timeseries data from multiple instruments.  The [RVSpectML](https://rvspectml.github.io/RvSpectML-Overview/) family of packages directly addresses this need.`,recording_license:"",do_not_record:!1,persons:[{id:17130,code:"VFFPB7",public_name:"Eric B. Ford",biography:'<a href="https://personal.psu.edu/~ebf11">Eric Ford</a> is a Professor of <a href="http://astro.psu.edu/">Astronomy & Astrophysics</a> at the Pennsylvania State University, where he is active in its <a href="https://www.icds.psu.edu/">Institute for Computational & Data Sciences</a>, <a href="https://astrostatistics.psu.edu/">Center for Astrostatistics</a>, and <a href="https://exoplanets.psu.edu/">Center for Exoplanets & Habitable Worlds</a>.  Ford\u2019s research focuses on detecting and characterizing planetary systems around other stars.  This often involves using Julia to apply modern Bayesian methods to improve the interpretation of exoplanet observations.  Ford has taught a graduate-level class on <a href="https://psuastro528.github.io/">High-Performance Computing for Astrophysics</a> using Julia since 2014.',answers:[]}],links:[],attachments:[],answers:[]},{id:18144,guid:"cc3bb9e0-4213-5ed1-bbf3-6c470cef4f9e",logo:"",date:"2022-07-27T15:00:00+00:00",start:"15:00",duration:"00:10",room:"Green",slug:"juliacon-2022-18144-state-of-juliageo",url:"https://pretalx.com/juliacon-2022/talk/WCKJQB/",title:"State of JuliaGeo",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"[JuliaGeo](https://juliageo.org) is a community that contains several related Julia packages for manipulating, querying, and processing geospatial geometry data. We aim to provide a common interface between geospatial packages. In 2022 there has been a big push to have parity with the Python geospatial packages, such as rasterio and geopandas. In this 10 minute talk, we'd like to show these improvements---both in code and documentation---during a tour of the geospatial ecosystem.",description:`[JuliaGeo](https://juliageo.org) is a community that contains several related Julia packages for manipulating, querying, and processing geospatial geometry data. We aim to provide a common interface between geospatial packages. In 2022 there has been a big push to have parity with the Python geospatial packages, such as rasterio and geopandas. In this 10 minute talk, we'd like to show these improvements---both in code and documentation---during a tour of the geospatial ecosystem. \r
\r
We'll showcase the new traits-based release of GeoInterface.jl and work on GeoDataFrames.jl, GeoArrays.jl and Rasters.jl. It includes new packages like GeoFormatTypes, Extents.jl and GeoAcceleratedArrays.jl. We will conclude with future plans, such as enabling geospatial operations in DTables using Dagger.jl.\r
\r
Links to the [slides](https://app.box.com/s/7dysp78eqlo2b201nx795f0efaci2il6) and [demo](https://app.box.com/s/r5ulbktmqinl732ixjw5h9xyxy6h0mus).`,recording_license:"",do_not_record:!1,persons:[{id:9652,code:"Q33DZA",public_name:"Maarten Pronk",biography:"GeoData Scientist working on elevation modelling @Deltares. External PhD candidate at @tudelft3d",answers:[]},{id:1020,code:"3JXPXF",public_name:"Josh Day",biography:"Dr. Josh Day (PhD Statistics, NC State) is a Senior Research Scientist at Julia Computing where he develops technical R&D software.  He's motivated by unsolved problems and his research interests are on-line algorithms (OnlineStats.jl), numerical optimization, and data visualization.  He maintains many Julia packages which can be viewed on [Github](https://github.com/joshday).",answers:[]},{id:3779,code:"LVYSRF",public_name:"Rafael Schouten",biography:null,answers:[]}],links:[],attachments:[],answers:[]},{id:16944,guid:"2a27873f-c4ff-5663-ac91-0abe3ff5b0d1",logo:"",date:"2022-07-27T15:10:00+00:00",start:"15:10",duration:"00:30",room:"Green",slug:"juliacon-2022-16944-towards-using-julia-for-real-time-applications-in-asml",url:"https://pretalx.com/juliacon-2022/talk/GUQBSE/",title:"Towards Using Julia for Real-Time applications in ASML",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"ASML is a 30.000+ employee company which is the world leader on photo-lithographic systems that are crucial for semiconductor manufacturing. During the last two years a community of Julia enthusiasts has been running pilot projects to assess opportunities offered by Julia for rapid development of early Proof-of-Concepts and, subsequent, rapid deployment in prototypes and, whether possible, actual products. Similar to other robotic systems, ASML lithography systems have hard real-time....",description:`... requirements, which means that software execution must be highly performant & deterministic (i.e., predictable and reproducible). As such, design engineers must look at various aspects when developing software, like fine control of memory, optimal design of data types and modeling algorithms, as well as efficient CPU cache utilization.\r
\r
User controlled garbage collection (or memory management) and system image binary contents(e.g., absence of JiT, removal of metadata etc.) revealed to be essential aspects to consider making Julia accepted as a language of choice in such a complex domain, compared to more (low level) established languages like C and C++. The goal of this talk is to discuss the strategies and techniques that we explored to enable us using Julia in the on-line execution of lithography models.\r
\r
We believe that this work will provide new insights about Julia future, by giving new opportunities for further adoption of Julia in complex industrial software systems`,recording_license:"",do_not_record:!1,persons:[{id:17876,code:"DADE9R",public_name:"Francesco Fucci",biography:"Lead software-engineer @ ASML, passionate about algorithm design, software engineering and programming languages. Besides, I love to make electronic music and experiment with sound-design.",answers:[]}],links:[],attachments:[],answers:[]},{id:21373,guid:"0717cf37-03d0-5e53-9c00-b0f9dae84ba6",logo:"",date:"2022-07-27T16:30:00+00:00",start:"16:30",duration:"00:10",room:"Green",slug:"juliacon-2022-21373-opening-remarks",url:"https://pretalx.com/juliacon-2022/talk/YN8QPM/",title:"Opening remarks",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"Opening remarks",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:21232,guid:"620aad8a-7384-5b6b-b5b5-56f536e963d9",logo:"",date:"2022-07-27T16:40:00+00:00",start:"16:40",duration:"00:45",room:"Green",slug:"juliacon-2022-21232-keynote-erin-ledell",url:"https://pretalx.com/juliacon-2022/talk/NPPKUW/",title:"Keynote- Erin LeDell",subtitle:"",track:"JuliaCon",type:"Keynote",language:"en",abstract:"Keynote- Erin LeDell",description:"Keynote- Erin LeDell",recording_license:"",do_not_record:!1,persons:[{id:21355,code:"CZATPB",public_name:"Erin LeDell",biography:`Dr. Erin LeDell is the Chief Machine Learning Scientist at H2O.ai, where she develops the open source, distributed machine learning platform, H2O, and is the founder of the H2O AutoML project. She has a Ph.D. in Biostatistics with a Designated Emphasis in Computational Science and Engineering from University of California, Berkeley. Her research focuses on automatic machine learning, ensemble machine learning and statistical computing. She also holds a B.S. and M.A. in Mathematics.\r
\r
Before joining H2O.ai, she was the Principal Data Scientist at Wise.io and Marvin Mobile Security, and the founder of DataScientific, Inc. She is also founder of the Women in Machine Learning and Data Science (WiMLDS) organization (wimlds.org) and co-founder of R-Ladies Global (rladies.org).`,answers:[]}],links:[],attachments:[],answers:[]},{id:21235,guid:"e995dc8c-4a36-5713-8597-39194c839860",logo:"",date:"2022-07-27T17:25:00+00:00",start:"17:25",duration:"00:15",room:"Green",slug:"juliacon-2022-21235-julia-computing-sponsored-talk",url:"https://pretalx.com/juliacon-2022/talk/AL8VGC/",title:"Julia Computing Sponsored Talk",subtitle:"",track:"JuliaCon",type:"Platinum sponsor talk",language:"en",abstract:"Julia Computing's mission is to develop products that bring Julia's superpowers to its customers. Julia Computing's flagship product is JuliaHub, a secure, software-as-a-service platform for developing Julia programs, deploying them, and scaling to thousands of nodes.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:21507,guid:"a44aea12-83a9-539e-b148-d2b0b6cd0cd7",logo:"",date:"2022-07-27T17:40:00+00:00",start:"17:40",duration:"00:10",room:"Green",slug:"juliacon-2022-21507-aws-sponsor-talk",url:"https://pretalx.com/juliacon-2022/talk/R7AYWY/",title:"AWS Sponsor Talk",subtitle:"",track:"JuliaCon",type:"Gold sponsor talk",language:"en",abstract:"Amazon Web Services sponsor Talk",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:18007,guid:"80fbe60f-f5e3-5b48-b0f9-07afcc9413ed",logo:"",date:"2022-07-27T19:10:00+00:00",start:"19:10",duration:"00:10",room:"Green",slug:"juliacon-2022-18007-optimization-of-bike-manufacturing-and-distribution-use-case-",url:"https://pretalx.com/juliacon-2022/talk/DBS3SS/",title:"Optimization of bike manufacturing and distribution (use-case)",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"This is a use-case scenario of using Julia for planning and optimization of production in one of the largest bicycle manufacturing plants in Europe. The optimization model has been implemented utilizing JuMP and custom made heuristics.  The Julia solution has increased profitability of the manufacturing plant over 10% (compared to the previous approach) and the optimal part allocation made it possible to increase the bike production volume by 25%.",description:"Kross S.A. (https://kross.eu/) is one of the largest bicycle manufacturers in Europe with a production capacity of up to 1 million bikes a year. The company is also exporting their products to over 50 countries around the globe. The problem that currently the entire bicycle manufacturing industry is facing is the shortage of various key bike components due to the COVID-19 logistic chain disturbances. The goal of the company is to maximize customer (retailer) satisfaction by simultaneously meeting all business constraints with regard to production (part availability, assembly line capacity) and the observed demand for bikes (taking into consideration possible bike substitution, pricing and discount policies) In order to optimize the bicycle production and optimize the distribution plan we have built a mathematical model of the manufacturing plant. The basic model formaulation includes an NP-hard Mixed Linear Integer Programming optimization problem with 4,000,000 decision variables and over 100,000,000 business constraints. The mathematical model has been implemented in Julia programming language using the JuMP package along with Julia linear algebra features and several heuristics and algebra transformations. The model has been subsequently solved using a custom designed heuristics as well as solver packages. This data science project had an overall huge effect on the business of the customer. The computational model made it possible to manufacture 25% more bikes and yields a 10% higher total profitability of the bike factory compared to the best recommendations by a leading ERP solution that has been previously used by the company for production planning.",recording_license:"",do_not_record:!1,persons:[{id:1089,code:"HNA89P",public_name:"Przemys\u0142aw Szufel",biography:"Przemys\u0142aw Szufel is an Assistant Professor at SGH Warsaw School of Economics, Adjunct Professor at Ryerson University, Toronto, co-owner at  StatXplorer.com - company offering custom made optimization and machine learning models and Founding Partner of Nunatak Capital - a VC fund that specializes in investing in startups that build their value on data analytics. His main research focus is applying advanced analytics methods, and in particular, machine learning, simulation and optimization in modelling in bringing new value to business processes. He is a co-author of several tools and algorithms for optimal and cost efficient collection and analysis of large data sets in the cloud. He is a co-author of over 40 publications, including handbooks and journal papers, in the area of applying advanced analytics, machine learning and simulation methods to making optimal business decisions. He is an active member of the Julia language community - maintains 3 official Julia packages and has 3rd place in the world answering Julia-related questions on StackOverflow. He is a co-author of book \u201CJulia 1.0 Programming Cookbook: Over 100 numerical and distributed computing recipes for your daily data science workflow\u201D. Przemy\u0142aw is also co-managing SilverDecisions.pl project (that aims for representing and supporting business decisions), which has been elected by the European Commission to the Innovation Radar programe, grouping the best innovations financed by the EU funds. Przemyslaw has been awarded by the Polish Ministry of Science and Higher Education for implementing data science innovations to business environment. Recently, in a survey by SGH Student Council he has been selected the best teaching professor at SGH Warsaw School of Economics scoring the highest number of student votes among the entire faculty.",answers:[]}],links:[],attachments:[],answers:[]},{id:18147,guid:"0ea5ff5d-d869-50c4-9c91-ca8689488d82",logo:"",date:"2022-07-27T19:20:00+00:00",start:"19:20",duration:"00:10",room:"Green",slug:"juliacon-2022-18147-tintinet-jl-a-language-model-for-protein-1d-property-estimation",url:"https://pretalx.com/juliacon-2022/talk/PMAYRF/",title:"TintiNet.jl: a language model for protein 1D property estimation",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"AI has inaugurated a new era in Bioinformatics, to the point where contemporary language models can extract structural information from processing single protein sequences. Contributing to this field, we built TintiNet.jl, a 100% open-source, open-data and Julia-based portable language model to predict 1D protein structural properties. Our model achieves top performance - computational and predictive -, when compared to other modern algorithms, with only a fraction of the parameter count.",description:`The objective of TintiNet.jl is to improve the current state of single-sequence-based prediction of 1D protein structural properties by drastically reducing the size of the models employed while preserving or improving their raw predictive power.\r
\r
Our main design principles were to avoid intra-serialized processing layers (such as recurrent neural networks) and to employ encoding layers that could grow deeper without a steep increase in computational complexity. Our solution was to develop a hybrid convolutional-transformer architecture, employing the Julia Language, The Flux.jl framework and the Transformers.jl contributed layers to Flux.jl, as well as some BioJulia packages (BioSequences.jl, BioStructures.jl, BioAlignments.jl and FASTX.jl). The project is 100% open-source and open-data, and scripts and procedures to implement the methodology presented are available at https://github.com/hugemiler/TintiNet.jl.\r
\r
By training and evaluating our model in an extensive collection of over 30000 protein sequences, we demonstrate that this architecture can achieve a similar degree of merit (classification accuracy and regression error) when compared to the three most modern, state-of-the-art models. Since it has a much reduced number of parameters compared to its alternatives, it occupies much less memory and generates predictions up to 10 times faster.`,recording_license:"",do_not_record:!1,persons:[{id:16731,code:"ATAGTB",public_name:"Guilherme Fahur Bottino",biography:"Computational Chemist (Ph.D. Candidate) @ University of Campinas, Brazil; incoming Postdoc Researcher @ Wellesley College, USA. Chemistry teacher, Julia developer, Scientific Computing and Machine Learning enthusiast, casual MMORPG gamer, bartender and home cook. Programming makes Science even cooler! (He/Him/His)",answers:[]}],links:[],attachments:[],answers:[]},{id:16929,guid:"0792200a-d182-53db-8ea8-644c748f8ffd",logo:"",date:"2022-07-27T19:30:00+00:00",start:"19:30",duration:"00:10",room:"Green",slug:"juliacon-2022-16929-ptylab-jl-ptychography-reconstruction",url:"https://pretalx.com/juliacon-2022/talk/YUYXMM/",title:"PtyLab.jl - Ptychography Reconstruction",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`Conventional Ptychography is a lensless imaging technique which captures a sequence of light diffraction patterns to solve the optical phase problem. The resulting datasets are large and can typically not directly be solved. Instead, iterative reconstruction algorithms with low runtime memory footprint are employed.\r
Here we present PtyLab.jl, a software for ptychographic data analysis and demonstrate how a functional programming style in Julia allows for performant iterative algorithms.`,description:`Conventional Ptychography is a powerful technique since it can retrieve phase and amplitude of an object which is usually not accessible by most common imaging techniques.\r
The drawback of this method is that it requires a stack of images taken at different displacements of an object with respect to a probe laser beam (such as a Gaussian laser beam).\r
The recorded images are the intensity of the diffraction pattern of the object illuminated with the probe.\r
Via iterative reconstruction algorithms one can retrieve amplitude and phase of both the probe and the object. To achieve reasonable runtimes, the algorithms require low memory consumption.\r
In PtyLab.jl we achieve that with a functional style of programming where buffers are implicitly stored at the beginning of the reconstruction in different functions.\r
Furthermore, we could demonstrate that this style combined with Julia could achieve reasonable speed-ups in comparison to Matlab and Python.`,recording_license:"",do_not_record:!1,persons:[{id:9921,code:"U3YH9P",public_name:"Felix Wechsler",biography:`[Felix Wechsler](https://felixwechsler.science/) is a PhD student at the Leibniz Institute of Photonic Technology and the Friedrich Schiller University of Jena. Before that, Felix obtained Bachelor degrees in physics and informatics where he worked on Light Field Microscopy and Schlieren Imaging.\r
In his master thesis, he developed a novel kaleidoscopic microscope, the Kaleidomicroscope.\r
His recent work is implemented in Julia Lang and he is maintainer of several microscopy related packages written in Julia Lang.`,answers:[]},{id:18060,code:"SKXKYP",public_name:"Lars Loetgering",biography:null,answers:[]}],links:[],attachments:[],answers:[]},{id:18176,guid:"659e0699-6d77-54bf-9227-6dbd5c0c72d6",logo:"",date:"2022-07-27T19:40:00+00:00",start:"19:40",duration:"00:10",room:"Green",slug:"juliacon-2022-18176-cropbox-jl-a-declarative-crop-modeling-framework",url:"https://pretalx.com/juliacon-2022/talk/ET78DS/",title:"Cropbox.jl: A Declarative Crop Modeling Framework",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"[Cropbox.jl](https://github.com/cropbox/Cropbox.jl) provides a domain specific language for developing crop models.",description:`Crop models describe how agricultural crops grow under dynamic environmental conditions and management practices. The models have many applications in agricultural science including, but not limited to, predicting yields of the crops under climate change scenarios and finding an optimal strategy for maximizing the yield. Crop modeling can encompass multiple aspects of research activities, but practically speaking, it is a task of formulating quantitative knowledge about the crops and translating them into a computer program.\r
\r
Many crop models were traditionally developed in imperative programming languages where unrestricted control flows and state mutations could easily lead to error-prone code and inevitable technical debts. Also model developers and model users were often left behind in two disconnected workflows due to the lack of interactive programming environment.\r
\r
Cropbox is a new modeling framework to bring a declarative approach towards the crop modeling and to consolidate the model development and use in a streamlined workflow implemented on Julia ecosystem. With an insight that the crop model is essentially an integrated network of generalized state variables, the modelers can write down a high-level specification of the model *system* represented by a collection of *variables* with specific behaviors associated. The framework then analyzes the specification and automatically generates lower-level Julia code that works with regular functions implementing common features like simulation running, configuration management, evaluation with common metrics, calibration of parameters, visualization of the result, and manipulation of interactive plots.\r
\r
In this talk, I will briefly introduce the design and implementation of Cropbox and demonstrate some modeling applications such as a coupled leaf gas-exchange model ([LeafGasExchange.jl](https://github.com/cropbox/LeafGasExchange.jl)), a whole-plant garlic growth model ([Garlic.jl](https://github.com/cropbox/Garlic.jl)), and a 3D root structure growth model ([CropRootBox.jl](https://github.com/cropbox/CropRootBox.jl)).`,recording_license:"",do_not_record:!1,persons:[{id:18487,code:"XNUQVQ",public_name:"Kyungdahm Yun",biography:"Postdoctoral scholar at the University of Washington in Seattle.",answers:[]}],links:[],attachments:[],answers:[]},{id:18055,guid:"63d78df9-082c-524e-90e3-bb47d7fafe17",logo:"/media/juliacon-2022/submissions/CJ3XLV/png_20220411_082238_0000_i24wbob.png",date:"2022-07-27T19:50:00+00:00",start:"19:50",duration:"00:10",room:"Green",slug:"juliacon-2022-18055-gaptrain-a-faster-and-automated-way-to-generate-ga-potentials",url:"https://pretalx.com/juliacon-2022/talk/CJ3XLV/",title:"GapTrain: a faster and automated way to generate GA potentials",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Chemical predictions have gained ground in the last decade as a way to automate the streamlining of chemical reactivity of multiple substrates. This procedure requires the modeling of interatomic potentials, which can be done by fitting these potentials to data obtained at the quantum-mechanical level. Therefore, the aim of this work is to propose GapTrain.jl, a fast, automatic and broad model to develop the Gaussian approximation potential based on a hundred or thousand data.",description:`## Introduction\r
<div align=justify> \r
Molecular simulations are a key point in computational chemistry for reproducing experimental reality. The accuracy of these models involves a number of elements, such as the inclusion of the solvation medium. Thus, interatomic potentials combined with molecular dynamics and Monte Carlo (MC) has been widely applied to surface potential energy. Moreover, most of these potentials are\r
parameterised for isolated entities with fixed connectivity and thus unable to describe bond breaking/forming  processes.\r
\r
Machine learning approaches have revolutionized force field-based simulations and can be implemented for the entire periodic table. Within small chemical subspaces, models can be achieved using neural networks (NNs), kernel-based methods such as the Gaussian Approximation Potential (GAP) framework or gradient-domain machine learning (GDML), and linear fitting with properly chosen basis functions, each with different data requirements and transferability. GAPs have been used to study a range of elemental, multicomponent inorganic, gas-phase organic molecular, and more recently condensed-phase systems, such as methane and phosphorus. These potentials, while accurate, have required\r
considerable computational effort and human oversight.\r
Indeed, condensed-phase NN and GAP fitting approaches typically require several thousand reference (\u201Cground truth\u201D) evaluations.\r
\r
In the present work \u2013 with a view to developing potentials to\r
simulate solution phase reactions \u2013 we consider bulk water as\r
a test case and develop a strategy which requires just hundreds\r
of total ground truth evaluations and no a priori knowledge of\r
the system, apart from the molecular composition. We show\r
how this methodology is directly transferable to different\r
chemical systems in the gas phase as well as in implicit and\r
explicit solvent, focusing on the applicability to a range of\r
scenarios that are relevant in computational chemistry.\r
</div>\r
\r
## References\r
\r
**1** D. Frenkel and B. Smit, Understanding Molecular Simulation:\r
From Algorithms to Applications, Academic Press,\r
Cambridge, Massachusetts, 2nd edn, 2002.\r
\r
**2** K. Lindorff-Larsen, P. Maragakis, S. Piana, M. P. Eastwood,\r
R. O. Dror and D. E. Shaw, PLoS One, 2012, 7, e32131.\r
\r
**3** R. Iimie, P. Minary and M. E. Tuckerman, Proc. Natl. Acad.\r
Sci. U. S. A., 2005, 102, 6654\u20136659.\r
\r
**4** F. No \u0301e, A. Tkatchenko, K.-R. M \u0308uller and C. Clementi, Annu.\r
Rev. Phys. Chem., 2020, 71, 361\u2013390.\r
\r
**5** T. Mueller, A. Hernandez and C. Wang, J. Chem. Phys., 2020,\r
152, 050902.\r
\r
**6** O. T. Unke, D. Koner, S. Patra, S. K \u0308aser and M. Meuwly,\r
Mach. Learn. Sci. Technol., 2020, 1, 013001.\r
\r
**7** R. Z. Khaliullin, H. Eshet, T. D. K \u0308uhne, J. Behler and\r
M. Parrinello, Nat. Mater., 2011, 10, 693\u2013697.\r
\r
**8** G. C. Sosso, G. Miceli, S. Caravati, F. Giberti, J. Behler and\r
M. Bernasconi, J. Phys. Chem. Lett., 2013, 4, 4241\u20134246.\r
\r
**9** H. Niu, L. Bonati, P. M. Piaggi and M. Parrinello, Nat.\r
Commun., 2020, 11, 2654.`,recording_license:"",do_not_record:!1,persons:[{id:16723,code:"U3WPAA",public_name:"Let\xEDcia Madureira",biography:`I'm Let\xEDcia Maria (she/her/hers), a final year Chemistry student in Brazil (@geem-lab). Currently, I work with projects involving the development of graphical interfaces, linear and polynomial algebra tools for quantum calculations of molecular electronic structure. I also implement tools for kinetic analysis of chemical reactions (@JuliaChemicalReactions). My main programming language is Julia, but I also program in Python, Rust and JavaScript (depends on the occasion and the project). I advocate free, open and clean code.\r
\r
Incoming PhD student at CMU in Fall 2022 (@gomesgroup)`,answers:[]}],links:[],attachments:[],answers:[]},{id:18161,guid:"35793573-94db-532e-9bf6-f2b14eb7dcee",logo:"",date:"2022-07-27T20:00:00+00:00",start:"20:00",duration:"00:10",room:"Green",slug:"juliacon-2022-18161-using-julia-for-observational-health-research",url:"https://pretalx.com/juliacon-2022/talk/CPS73H/",title:"Using Julia for Observational Health Research",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:'Observational health research is a domain of health informatics centered around the use of what is known as "Real World Data". This data comes in several different modalities, standards, and levels of quality. Through efforts done in JuliaHealth, JuliaInterop, and associated communities, the ability to work with this data is now fully realized. Through this talk, viewers will see how an observational health study can be conducted with Julia and how similar tools can be adapted to their research.',description:`One patient encounter to a health care provider can produce an enormous amount of Real World Data (RWD). Per the United States Food and Drug Administration, RWD, "relates to patient health status and/or the delivery of health care routinely collected from a variety of sources." Some examples of RWD are electronic health records, medical claims, or mobile device data. Julia is primed to handle the computation required to generate clinical significance from RWD in the domain of observational health research. \r
\r
Historically however, Julia's ecosystem has not been mature enough to participate directly in observational health research concerning large amounts of RWD. In the past, to effectively utilize this data the open science community, OHDSI (Observational Health Data Sciences and Informatics), was formed. The core standard that OHDSI has developed and is being rapidly adopted worldwide for handling RWD is the Observational Medical Outcomes Partnership Common Data Model - commonly referred to the OMOP CDM. Traditionally the tools built by OHDSI to interact with the OMOP CDM to extract and analyze patient information have been built in the R programming language. As a result, this has precluded other research communities from participating directly in this space.\r
\r
I am pleased to announce in this talk that the Julia ecosystem has now reached a level of maturity to bridge to observational health research communities such as OHDSI to enable future observational health researchers to leverage the benefits of Julia. In this talk, I will provide a gentle introduction to observational health research and popular Common Data Models such as OMOP. This will lead into a discussion on lessons learned from an observational health study I performed called "Assessing Health Equity in Mental Healthcare Delivery Using a Federated Network Research Model" which used Julia as its main driving engine. Finally, tools available in the Julia ecosystem from JuliaHealth, JuliaInterop, and others that enable bridging between these two communities will be highlighted. \r
\r
By the end of this talk, it should be made clear to potential researchers from the Julia community that the Julia ecosystem is matured enough to participate in observational health research endeavors. Furthermore, through the lessons I share through this talk, potential researchers can take inspirations on methods I used for their own work. My end goal for this talk is that by showing how these communities can be bridged, novel collaborations can be made and the benefits of using Julia can be easily accessed in observational health research.`,recording_license:"",do_not_record:!1,persons:[{id:9292,code:"WNALCB",public_name:"Jacob Zelko",biography:"I am a graduate of Georgia Institute of Technology with a BS in biomedical engineering. I currently work at Georgia Tech Research Institute in the Health Emerging and Advanced Technologies division (HEAT-D) as a Health Data Analytics and Informatics Researcher as well as being a Contractor for the Centers for Disease Control.",answers:[]}],links:[],attachments:[],answers:[]},{id:18240,guid:"4a031afc-01ff-5203-85d0-898da00f3b23",logo:"/media/juliacon-2022/submissions/ML8N7S/dm_Bwyfr56.png",date:"2022-07-27T20:10:00+00:00",start:"20:10",duration:"00:10",room:"Green",slug:"juliacon-2022-18240-finding-fast-radio-bursts-faster",url:"https://pretalx.com/juliacon-2022/talk/ML8N7S/",title:"Finding Fast Radio Bursts, Faster",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`In radio astronomy, "Fast Radio Bursts" are short, high-energy signals of unknown origin. So far, relatively few have been discovered as many telescopes weren't designed to observe radio transients. Additionally, searching real-time spectral data is an expensive task, for which there are only a few aging packages to automate. In this talk, we'll look at using CUDA.jl and the Julia ecosystem to accelerate the hunt for these mysterious sources and the integration into an FRB detection pipeline.`,description:`One of the main bottlenecks in a fast radio burst detection pipeline is a first pass pulse detection. FRBs, pulsars, airplane radars, and microwaves opened prematurely can all produce pulse-like profiles. Processing the dynamic spectral data in real-time to limit the search space and produce a list of possible candidates is an important first step.\r
\r
When wideband radio pulses travel through space, ionized interstellar media disperses the pulse in time. This results in a received spectrum with a peak descending in frequency as a function of time instead of receiving all of the frequencies at once. For a given received time/frequency data point, the pulse signature may be buried under noise. As we don't know the amount of dispersion of an arbitrary pulse a priori, we have to integrate all possible dispersion curves for every start time to find a possible correlation.\r
\r
Using both hand-written CUDA.jl kernels and Julia's GPU-array abstractions, we can implement a performant divide and conquer approach to search for these pulses. Then, leveraging the Julia ecosystem, we can embed this transformation into a modern, integrated FRB detection pipeline.`,recording_license:"",do_not_record:!1,persons:[{id:18578,code:"GQNRFP",public_name:"Kiran Shila",biography:"Kiran received the B.S. and M.S degrees in electrical engineering from the University of South Florida, Tampa, FL in 2018 and 2020, respectively. He is currently a Ph.D. student in the electrical engineering department at the California Institute of Technology (Caltech) in Pasadena with a research appointment in the department of astronomy. His current research interests include radio astronomy instrumentation, room-temperature and cryogenic low noise amplifiers, and radio astronomy software. In his free time, he plays the jazz vibraphone, bikes around LA, and contributes to open source software.",answers:[]}],links:[],attachments:[],answers:[]},{id:18042,guid:"9eec785a-7232-533a-8484-d0a1a64ce33f",logo:"",date:"2022-07-27T20:20:00+00:00",start:"20:20",duration:"00:10",room:"Green",slug:"juliacon-2022-18042-using-contexts-and-capabilities-to-provide-privacy-protection",url:"https://pretalx.com/juliacon-2022/talk/RTBE9E/",title:"Using contexts and capabilities to provide privacy protection",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Privacy is an important aspect of the internet today. Providing privacy protection, however, is a difficult problem especially when you work with many data processes and systems. To solve this problem holistically, privacy needs to be a built-in feature, not an after-thought. I will talk about how to solve this problem with the idea of context and capabilities.",description:`Privacy is an important aspect of the internet today. When you need to use a particular service, you often need to hand over some personal information. The service provider typically provides some protection about the use of your personal information based upon its privacy policy.\r
\r
From the service provider\u2019s perspective, this is not a simple task. Suppose that you have collected your users\u2019 email addresses and made the promise that you do not share them with any third party vendor. In a large company, there could be many systems and processes that make use of email addresses. How do you ensure that none of your code leaks information to any third party vendors?\r
\r
The problem can be solved with contexts and capabilities. Contexts are environmental information that tracks the purpose of your code. Capabilities represent a set of purposes that your code can be used for. As an example, bar is a function that writes sensitive information, such as email address, to a user database and it has the capability of \u201Cuser-management\u201D. Then, when a function foo() calls bar(), it is allowed as long as foo\u2018s stated capabilities also include \u201Cuser-management\u201D.\r
\r
This talk will cover more about the why\u2019s and the general mechanics of context and capabilities. I will also present a prototype that provides some basic functionalities of tracking contexts, defining capabilities and validating capabilities at runtime.\r
\r
Context is also known as coeffects. You can find more information about the theory of context-aware programming languages at http://tomasp.net/coeffects/.\r
\r
More information about context and capabilities can be found at this Hack language\u2019s documentation: https://docs.hhvm.com/hack/contexts-and-capabilities/introduction.`,recording_license:"",do_not_record:!1,persons:[{id:1226,code:"ZVXXQA",public_name:"Tom Kwong",biography:"Tom Kwong currently works at Meta. He is an experienced software engineer with almost 30 years of industry programming experience. In 2017, he discovered the Julia language and started working on several open-source projects such as SASLib.jl, BinaryTraits.jl and ContextTracking.jl. He has an MS Computer Science degree from University of California, Santa Barbara.",answers:[]}],links:[],attachments:[],answers:[]},{id:21379,guid:"c993d461-ed0b-5f2b-a6ce-cd0cb07199ea",logo:"",date:"2022-07-27T20:30:00+00:00",start:"20:30",duration:"01:00",room:"Green",slug:"juliacon-2022-21379-gathertown-social-break",url:"https://pretalx.com/juliacon-2022/talk/J3VNLN/",title:"GatherTown -- Social break",subtitle:"",track:null,type:"Social hour",language:"en",abstract:"Join us on [Gather.town](http://gather.town/) for a social hour.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]}],Red:[{id:17227,guid:"d13860ba-2cec-529c-9b85-a5a8e3e450db",logo:"/media/juliacon-2022/submissions/YSLKZJ/witch_simu_kaquJtz.png",date:"2022-07-27T12:30:00+00:00",start:"12:30",duration:"00:30",room:"Red",slug:"juliacon-2022-17227-from-mesh-generation-to-adaptive-simulation-a-journey-in-julia",url:"https://pretalx.com/juliacon-2022/talk/YSLKZJ/",title:"From Mesh Generation to Adaptive Simulation: A Journey in Julia",subtitle:"",track:null,type:"Talk",language:"en",abstract:"We present a Julia toolchain for the adaptive simulation of hyperbolic PDEs such as flow equations on complex domains. It begins with HOHQMesh.jl to create a curved, unstructured mesh. This mesh is then used in Trixi.jl, a numerical simulation framework for conservation laws. We visualize the results using Julia\u2019s plotting packages. We highlight select features in Trixi.jl, like adaptive mesh refinement (AMR) or shock capturing, useful for practical applications with complex transient behavior.",description:`Applications of interest in computational fluid mechanics typically occur on domains with curved boundaries. Further, the solution of a non-linear physical model can develop complex phenomena such as discontinuities, singularities, and turbulence.\r
\r
Attacking such complex flow problems may seem daunting. In this talk, however, we present a toolchain with components entirely available in the Julia ecosystem to do just that. In broad strokes the workflow is:\r
\r
1. Use HOHQMesh.jl to interactively prototype and visualize a domain with curved boundaries.\r
2. HOHQMesh.jl then generates an all quadrilateral mesh amenable for high-order numerical methods.\r
3. The mesh file is passed to Trixi.jl, a numerical simulation framework for conservation laws.\r
4. Solution-adaptive refinement of the mesh within Trixi.jl is handled by P4est.jl.\r
5. After the simulation, a first visualization is made using either Plots.jl or Makie.jl.\r
6. Solution data can also be exported with Trixi2Vtk.jl for visualization in external software like ParaView.\r
\r
The strength and simplicity of this workflow is through the combination of several packages either originally written in Julia, like Trixi.jl, or wrappers, like P4est.jl or HOHQMesh.jl, that provide Julia users access to powerful, well-developed numerical libraries and tools written in other programming languages.`,recording_license:"",do_not_record:!1,persons:[{id:18064,code:"LBHDJ9",public_name:"Andrew Winters",biography:"I am an Assistant Professor in the Department of Mathematics, Division of Applied Mathematics at Link\xF6ping University in Link\xF6ping, Sweden.",answers:[]}],links:[],attachments:[],answers:[]},{id:17971,guid:"708d573d-fca1-5e41-b615-b61618b11ef6",logo:"/media/juliacon-2022/submissions/9J3PGX/Screenshot_2022-04-08_112117_v59cwuh.png",date:"2022-07-27T13:00:00+00:00",start:"13:00",duration:"00:30",room:"Red",slug:"juliacon-2022-17971-cupoftea-versioned-analysis-and-visualization-of-land-science",url:"https://pretalx.com/juliacon-2022/talk/9J3PGX/",title:"CUPofTEA, versioned analysis and visualization of land science",subtitle:"",track:null,type:"Talk",language:"en",abstract:"We present a GitHub organization, CUPofTEAproject, hosting a Franklin.jl website, cupoftea.earth, and a suite of Julia packages. The organization goal is to host versioned analysis and web interactive visualization (using WGLMakie.jl) of science studies about exchanges between terrestrial ecosystems and the atmosphere.",description:"Terrestrial ecosystems (i.e., not ocean) have been absorbing about a third of human CO2 emissions, mitigating climate change as atmospheric carbon goes into biomass or soil organic matter. However, it is unclear if this carbon sink will continue in the future. The scientific community uses measurements from field site and satellite remote sensing to understand mechanisms regulating this behavior and create models to make predictions. However, efforts are segmented into specific disciplines (e.g., field experimentalists, modelers, plant ecologists, hydrologists) that rarely collaborate. This is due to using different programming languages (i.e., experimentalists using scripting language such as Python or R, and modelers using fast languages such as Fortran), or the nature of scientific publications encouraging small teams. In recent decades, global standardized databases are being created, as well as community open-source research tools, and Julia, a scripting language as fast as Fortran. This opens the door for collaboration in land-atmosphere exchange science. We use Julia, GitHub, and packages such as Franklin.jl and WGLMakie.jl to create CUPofTEA, a community platform to host versioned analysis and visualizations of land-atmosphere exchange science across fields. We demonstrate the workflow with DAMMmodel.jl, a package to analyze and visualize the response of CO2 emission from ecosystems to soil moisture and temperature, and global database of ecosystem (FLUXNET) and soil (COSORE) fluxes.",recording_license:"",do_not_record:!1,persons:[{id:18382,code:"HSXEX3",public_name:"Alexandre A. Renchon",biography:"Alexandre A. Renchon, currently postdoctoral appointee at Argonne National Laboratory, has a PhD in Terrestrial Ecology (2019, Western Syndey University), and Master degree in Bioengineering, Environmental Sciences and Technology (2013, Liege University). Alexandre is a multidisciplinary scientists with experience as an empiricist, modeler, and programmer. His interests are to understand how climate change will impact terrestrial ecosystems.",answers:[]}],links:[],attachments:[],answers:[]},{id:17876,guid:"cd6a68e8-90d0-56dc-b557-5a18eccbfed7",logo:"",date:"2022-07-27T14:30:00+00:00",start:"14:30",duration:"00:10",room:"Red",slug:"juliacon-2022-17876-decision-trees-meet-modal-logics",url:"https://pretalx.com/juliacon-2022/talk/RQP9TG/",title:"Decision Trees, meet Modal Logics",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"ModalDecisionTrees.jl offers a set of symbolic machine learning algorithms that extend classical decision tree learning algorithms, and are able to natively handle time series and image data. *Modal Decision Trees* leverage *modal logics* to perform a primitive-but-powerful form of entity-relation reasoning; this allows them to capture temporal and spatial patterns, and makes them suitable to natively deal (= no need for feature extraction) with data such as multivariate time-series and images.",description:`Symbolic learning provides *transparent* (or *interpretable*) models, and is becoming increasingly popular as AI permeates more and more aspects of our lives, while simultaneously raising ethical concerns. Mainly based on decision trees and rule-based models, symbolic modeling have been largely studied with either propositional or first-order logic as the underlying logical formalism. These logics are two extremes in terms of *expressive power* and *computational tractability*: on one hand, propositional logic can only express a simple form of reasoning, which makes classical decision trees easy to learn but also unable to deal with non-tabular data; on the other hand, first-order logics can express complex sentences in terms of entities and relations, but at the cost of higher computational complexities. A middle point between the two has been overlooked: modal logic.\r
ModalDecisionTrees.jl offers a set of symbolic machine learning methods based on extensions of classical decision tree learning algorithms (CART and C4.5), that leverage modal logics to perform a rather simple (but powerful) form of entity-relation reasoning; this allows *"Modal Decision Trees"* (MDTs) to capture temporal, spatial, and spatio-temporal patterns, and makes them suitable to natively deal (= no need for feature extraction) with data such as multivariate time-series and image data.\r
To fix the ideas, consider the case of time-series classification. While classical trees can only make decisions based on scalar values, and thus can only deal with time-series when they are priorly *flattenedly described* by a set of scalar descriptors (feature extraction step), a *modal* image classification rule can speak in terms of temporal patterns such as *there exists an interval in the time-series where variable i has a certain property, _containing_ another interval where variable j has another property*.\r
Modal logic can express the existence of entities (for example, a time interval, or an image region) with given properties, and properties can be *local*, such as the value of a variable being always lower than a certain threshold within the time interval, or *relational*, such as one entity being *contained* in, or *overlapping* with another one.\r
This process involves an intermediate step where data samples are represented as graphs (Kripke structures, in logical jargon) representing entities, their local properties, and their relations.\r
Note how rules and patterns can, of course, be as complex as the reality they are trying to capture; however, they can always be straightforwardly translatable into natural language, which represents the essence of the *transparency* of these models, as well as the main reason why one may want to use this package.\r
MDTs have been shown to achieve performances that are higher when compared to classical decision trees, and often comparable to those of functional gradient-based methods (e.g., Neural Networks), in tasks such as multivariate time-series classification (e.g., COVID-19 diagnosis from audio recordings of coughs and breaths) and image classification (e.g., land cover classification).\r
Despite this package being at its infancy, ModalDecisionTrees.jl can be used with the Machine Learning Julia (MLJ) framework, and provides:\r
- support for *bagging* (i.e, forests, ensembles of trees);\r
- support for *multimodal* learning;\r
- tools for inspecting models and analyzing single rules.`,recording_license:"",do_not_record:!1,persons:[{id:18245,code:"LNRHHF",public_name:"Giovanni Pagliarini",biography:`PhD Student in Mathematics, Logic & Computer Science @ University of Ferrara & Parma, Italy.\r
\r
Developing, studying and testing new **symbolic learning** methods.\r
\r
\\#AI, \\#Interpretability, \\#ModalDecisionTrees!`,answers:[]}],links:[],attachments:[],answers:[]},{id:18106,guid:"8788398a-2148-5930-a9ee-6ac9be05e3d5",logo:"",date:"2022-07-27T14:40:00+00:00",start:"14:40",duration:"00:10",room:"Red",slug:"juliacon-2022-18106-multivariate-polynomials-in-julia",url:"https://pretalx.com/juliacon-2022/talk/TRFSJY/",title:"Multivariate polynomials in Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Depending on the applications, the requirement for a multivariate polynomial library may be efficient computation of product, division, substitution, evaluation, gcd or even Gr\xF6bner bases. It is well understood that the concrete representation to use for these polynomials depends on whether they are sparse or not. In this talk, we show that in Julia, the choice of representation also depends on whether to specialize the compilation on the variables.",description:`Multivariate polynomials appear in various applications such as computer algebra systems, homotopy continuation or Sum-of-Squares programming. Different applications have varied requirements for a multivariate polynomial library making it challenging to choose a representation that would be the most efficient for all use cases. It is well understood for instance that the concrete representation to use for these polynomials depends on whether they are sparse or not. Having an abstract interface allows both the application to be independent on the actual representation used but also some lower level operations such as the computation of polynomial division or gcd.\r
\r
In fact, this abstraction is even more important in Julia than other languages because Julia allows yet another aspect to enter into the design of multivariate polynomials. We show in this talk that for basic operations, the Julia compiler can either compile a generic method working for any set of variables or a method specialized to a specific one. This can be achieved in Julia by moving some part of the polynomial description from field values to type parameters, hence also reducing the memory footprint of polynomials. These 2 aspects: sparsity and specialization make up for 4 different representations that all have specific use cases where they are most appropriate. Packages relying on multivariate polynomial computation for which more than one use case can occur should therefore be implemented on an abstract multivariate polynomial interface and require the user to choose the implementation via the type of polynomials given as input.\r
\r
We illustrate this with actual Julia packages implementing these representations: DynamicPolynomials.jl (sparse, non-specialised), TypedPolynomials.jl (sparse, specialized), SIMDPolynomials.jl (sparse, specialized) and TaylorSeries.jl (dense, specialized). We analyze the impact of the choice of representation for these representations in a benchmark for gcd computation. The gcd implementation is written generically thanks to the abstract MultivariatePolynomials.jl interface.`,recording_license:"",do_not_record:!1,persons:[{id:10452,code:"MLJG3F",public_name:"Beno\xEEt Legat",biography:"Beno\xEEt Legat is a postdoc at MIT with Prof. Pablo Parrilo in the Laboratory for Information and Decision Systems (LIDS).",answers:[]},{id:4370,code:"DNZRRM",public_name:"Chris Elrod",biography:"Chris Elrod is a frequent commenter on the Julia Discourse, Slack, and Zulip, as well as a contributor to the ecosystem, known in particular for LoopVectorization.jl and JuliaSIMD.",answers:[]}],links:[],attachments:[],answers:[]},{id:18167,guid:"d8012533-da9b-5236-8774-c93d3b3cd5a7",logo:"",date:"2022-07-27T14:50:00+00:00",start:"14:50",duration:"00:10",room:"Red",slug:"juliacon-2022-18167-phcpack-jl-solving-polynomial-systems-via-homotopy-continuation",url:"https://pretalx.com/juliacon-2022/talk/UL3T8K/",title:"PHCpack.jl: Solving polynomial systems via homotopy continuation",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`PHCpack is a software package for solving polynomial systems via homotopy continuation methods. Our interface exports the functionality of PHCpack either via the executable or the shared object file, via its C interface. The software is free and open source and we have a cloud server that hosts the application at phcpack.org.\r
Our talk will also explore a specific application area in the design of mechanisms.`,description:`Systems of many polynomial equations in several variables occur in various areas of science and engineering, such as mechanism design, Nash equilibria, computer vision, etc. Use cases of PHCpack can be found in more than one hundred scientific papers. In addition to the need in applications, theorems from algebraic geometry have led to efficient algorithms to compute all isolated solutions and to compute the degrees and dimensions of all positive dimensional solution sets.  PHCpack contains many of the first implementations of algorithms in numerical algebraic geometry.\r
\r
PHCpack allows users to provide polynomial systems in a variety of formats to the solver, including symbolically. The Julia Interface to PHCpack obtains the symbolic input from the user and using native Julia Dataframes and Data Structures, processes and returns the results numerically via PHCpack. \r
\r
As one approach, using only the phc executable file, one can call the relevant features of PHCpack from a Julia program. Alternatively, we have compiled a C interface into a shared object, which can be imported into a Julia session.\r
\r
As a use case, we consider the design of a 4-bar mechanism. The 4-bar mechanism traces a curve and given sufficiently many points on the curve that one wants the mechanism to trace, one can compute all necessary parameters of the mechanism. This computation requires the solution of a system of many equations and variables. \r
\r
All the code is available in public github repositories.\r
https://github.com/kviswa5\r
https://github.com/janverschelde/PHCpack/tree/master/src`,recording_license:"",do_not_record:!1,persons:[{id:18498,code:"VEZ8Q3",public_name:"Kylash Viswanathan",biography:"PhD Candidate UIC (Department of Mathematics, Statistics and Computer Science)",answers:[]},{id:18501,code:"SGLNCU",public_name:"Jan Verschelde",biography:"Jan Verschelde obtained his PhD in Computer Science in 1996 at the Katholieke Universiteit Leuven.  After postdoctoral studies at Michigan State University and the Mathematical Sciences Research Institute in Berkeley, he joined the Department of Mathematics, Statistics and Computer Science at the University of Illinois at Chicago, where he teaches courses in symbolic computing, numerical analysis, computational geometry, industrial math & computation, scientific software, and supercomputing.  He is the main developer of PHCpack, a software package to solve polynomial systems by homotopy continuation.",answers:[]}],links:[],attachments:[],answers:[]},{id:18153,guid:"ecb88609-c03c-5bb5-a5b2-788efb5c81ee",logo:"",date:"2022-07-27T15:00:00+00:00",start:"15:00",duration:"00:10",room:"Red",slug:"juliacon-2022-18153-a-tax-benefit-model-for-scotland-in-julia",url:"https://pretalx.com/juliacon-2022/talk/KPRZAM/",title:"A Tax-Benefit model for Scotland in Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"This talk discusses ScotBen, a microsimulation tax-benefit model for Scotland written in Julia. Scotben lets you analyse how changes to the tax system change revenues, inequality and poverty.",description:`A Tax-Benefit model in Julia\r
\r
A tax benefit model is a computer program that calculates the effects of possible changes to the fiscal system on a sample of households. We take each of the households in a household survey dataset, calculate how much tax the household members are liable for under some proposed tax and benefit regime, and how much benefits they are entitled to, and add add up the results. If the sample is representative of the population, and the modelling sufficiently accurate, the model can then tell you, for example, the net costs of the proposals, the numbers who are made better or worse off, the effective tax rates faced by individuals, the numbers taken in and out of poverty by some change, and much else.\r
\r
I want to discuss a new Tax-Benefit model for Scotland written Julia (https://github.com/grahamstark/ScottishTaxBenefitModel.jl). \r
\r
There are currently three web interfaces you can play with:\r
\r
* https://ubi.virtual-worlds.scot/ (Models a Universal Basic Income)\r
* https://stb.virtual-worlds.scot/scotbud (construct a national budget)\r
* https://stb.virtual-worlds.scot/bcd/ (explores the incentive effects of the fiscal system)`,recording_license:"",do_not_record:!1,persons:[{id:18491,code:"Y3TKNE",public_name:"Graham Stark",biography:"Graham teaches economics at the Open University, UK and runs Virtual Worlds Research (http://virtual-worlds.scot) where he builds microsimulation economic models. Previously he worked for 20 years at the Institute for Fiscal Studies (www.ifs.org.uk). He lives in Glasgow, Scotland.",answers:[]}],links:[],attachments:[],answers:[]},{id:18163,guid:"7cbe11b9-1f6f-5b66-b683-75df6a70776e",logo:"",date:"2022-07-27T15:10:00+00:00",start:"15:10",duration:"00:30",room:"Red",slug:"juliacon-2022-18163-bayesian-estimation-of-macroeconomic-models-in-julia",url:"https://pretalx.com/juliacon-2022/talk/Z98GWK/",title:"Bayesian Estimation of Macroeconomic Models in Julia",subtitle:"",track:null,type:"Talk",language:"en",abstract:"Computational efficiency is vital when estimating macroeconomic models for use in policy analysis. We introduce the models contained within DSGE.jl and overview how to estimate them. We provide details on two estimation methods, adaptive Metropolis-Hastings and sequential Monte Carlo, and discuss how they can provide more efficiency during the estimation process.",description:`In this talk, I will discuss how the Federal Reserve Bank of New York (FRBNY) uses Julia for forecasting. I will first present the FRBNY model and the basics of our estimation methods, noting recent adjustments made necessary by the rapid changes in economic conditions over the last two years. During this discussion I will introduce our packages DSGE.jl, SMC.jl, and ModelConstructors.jl, which provide a user-friendly API for creating and estimating a variety of models, including our workhorse DSGE model. \r
\r
I will then discuss how Julia allows us to prototype and test new estimation methods, providing examples through our research into adaptive Metropolis-Hastings and sequential Monte Carlo algorithms. Because DSGE models take significant time to estimate, being able to stay on the cutting edge of Bayesian estimation algorithms allows us to provide results efficiently. Metropolis-Hastings algorithms, a class of random-walk Markov Chain Monte Carlo estimators, use a fixed proposal distribution throughout the estimation process. Adaptive Metropolis-Hastings algorithms update the proposal distribution throughout the estimation process in an attempt to gain efficiency. SMC methods combine MH and importance sampling to create an easily parallelizable sampling algorithm. I will show how these two families of algorithms can speed up the estimation process while illustrating potential pitfalls. \r
\r
This presentation will be useful to anyone who regularly conducts Bayesian estimation, especially in the context of time series and forecasting.\r
\r
Disclaimer: This talk reflects the experience of the author and does not represent an endorsement by the Federal Reserve Bank of New York or the Federal Reserve System of any particular product or service. The views expressed in this talk are those of the author and do not necessarily reflect the position of the Federal Reserve Bank of New York or the Federal Reserve System. Any errors or omissions are the responsibility of the author.`,recording_license:"",do_not_record:!1,persons:[{id:18495,code:"MECLU7",public_name:"Aidan Gleich",biography:"Sr. Research Analyst at NYFRB",answers:[]}],links:[],attachments:[],answers:[]},{id:17715,guid:"ff6cbc71-1afa-5f8c-b761-fdaa4171934f",logo:"",date:"2022-07-27T15:40:00+00:00",start:"15:40",duration:"00:10",room:"Red",slug:"juliacon-2022-17715-a-data-integration-framework-for-microbiome-research",url:"https://pretalx.com/juliacon-2022/talk/QG8VUX/",title:"A Data Integration Framework for Microbiome Research",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Standardized data objects can greatly support the collaborative development of new data science methods. In particular, commonly agreed data standards will provide improved efficiency and reliability in complex data integration tasks. We demonstrate the application of this framework in the context of microbiome research.",description:`Microorganisms shape every aspect of our life: from the soil of our farmland to the human gut, from the ocean to the municipal wastewater of our cities, microorganisms seem to inhabit and even dominate most ecosystems of this planet. As we expand our knowledge on the role that microbes play within and beyond our bodies, the need arises to store and analyze such information in a systematic and reproducible manner. \r
\r
Standardized data objects can greatly support the collaborative development of new data science methods. In particular, commonly agreed data standards will provide improved efficiency and reliability in complex data integration tasks. We implement this approach in microbiome research in the a new Julia package, MicrobiomeAnalysis.jl (MIA), which introduces a new approach for microbiome data integration and analysis based on state-of-the-art data containers designed for robust data integration tasks: SummarizedExperiments.jl (SE) and MultiAssayExperiment.jl (MAE). \r
 \r
Our approach provides a general framework to study complex microbiome profiling data sets. Not only do the data containers make it instinctive to work with abundance assays, but they also integrate those assays with the corresponding metadata into a comprehensive data object. We demonstrate the approach based on common analysis tasks in microbial ecology, including alpha and beta diversity analysis and visualization of microbial community dynamics. The proposed approach is inspired by closely related and active efforts in R/Bioconductor. Developing a similar framework in the Julia language is a promising endeavour that can provide drastic performance improvements in certain computational tasks, such as dimension reduction and time series analysis while taking advantage of a shared conceptual framework. \r
\r
Overall, our environment offers the starting point for developing effective standardized methods for microbiome research. The methodology is general, thus it can be easily applied to other multi-source study designs and data integration tasks.`,recording_license:"",do_not_record:!1,persons:[{id:18170,code:"NDHRNU",public_name:"Giulio Benedetti",biography:"Bioengineering student at Rhine-Waal University, Germany, and former research trainee at Turku University, Finland, where he contributed to FdeSolver.jl and MicrobiomeAnalysis.jl under the supervision of the Turku Data Science Group. Interested in bioinformatics and data science.",answers:[]}],links:[],attachments:[],answers:[]},{id:18105,guid:"99c044eb-7190-5df6-ba1c-a0894d3551f1",logo:"",date:"2022-07-27T19:30:00+00:00",start:"19:30",duration:"00:30",room:"Red",slug:"juliacon-2022-18105-building-workflows-for-materials-modeling-on-hpc-systems",url:"https://pretalx.com/juliacon-2022/talk/E99KP7/",title:"Building workflows for materials modeling on HPC Systems",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Materials computations, especially of the *ab initio* kind, are intrinsically complex. These difficulties have inspired us to develop an extensible, lightweight, high-level workflow framework, `Express.jl`, to automate long and extensive sequences of the *ab initio* calculations. In this talk, we would like to share some experiences that we gained in building a software framework and multifunctional scientific tools with Julia's versatility.",description:'`Express.jl`, together with its "plugins" (such as `QuantumESPRESSOExpress.jl`), are shipped with well-tested workflow templates, including structure optimization, equation of state fitting, lattice dynamics calculation, and thermodynamic property calculation. It is designed to be highly modularized so that its components can be reused across various occasions, and customized workflows can be built on top of that. It helps users in the preparation of inputs, execution of simulations, and analysis of data. Users can also track the status of workflows in real-time and rerun failed jobs thanks to the data lineage feature `Express.jl` provides.\r\n\r\nTo achieve the goals mentioned above, we built several independent packages during the development of `Express.jl`, which are supposed to solve some ordinary problems in the physics, geoscience, and materials science communities, e.g., `EquationsOfStateOfSolids.jl`, `Geotherm.jl`, `Spglib.jl`, `Crystallography.jl`. Of course, as a project aimed to automate mundane operations of the *ab initio* calculations, we wrote a package (`SimpleWorkflows.jl`) to construct workflows from basic jobs and track their execution status. Because the most time-consuming part of the workflows is running external software (like Quantum ESPRESSO), we also built packages to interact with them, e.g., `QuantumESPRESSO.jl` and `Pseudopotentials.jl`. Besides, we discovered many valuable Julia packages and integrated them into our code, such as `Configurations.jl`, `Comonicon.jl`, `Setfield.jl`.  In this talk, we would like to explain how Julia made our complicated codebase possible and share some experiences about when and how we should utilize these wonderful projects.',recording_license:"",do_not_record:!1,persons:[{id:18443,code:"Z7EL3T",public_name:"Ryan",biography:"Ph.D. student in Materials Science at Columbia University in the City of New York",answers:[]}],links:[],attachments:[],answers:[]},{id:17960,guid:"3b04c32f-763c-5908-9f53-bb548c1fcdc9",logo:"",date:"2022-07-27T20:00:00+00:00",start:"20:00",duration:"00:30",room:"Red",slug:"juliacon-2022-17960-modeling-a-crash-simulation-system-with-modelingtoolkit-jl",url:"https://pretalx.com/juliacon-2022/talk/DRLYT8/",title:"Modeling a Crash Simulation System with ModelingToolkit.jl",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Previously traditional modeling tools were used to provide the acausal modeling framework which could be statically compiled and integrated with our distributed software.  But with this comes the dual language problem and friction with model research and development.  With ModelingToolkit.jl the tools needed to transition from traditional modeling frameworks are now available. This talk will cover our approach and success in re-writing our Hydraulic Crash Simulation system model in pure Julia.",description:`Instron's \u201CCatapult\u201D Crash Simulation System releases 2.75MN of energy with micron level control over a fraction of a second to reproduce a recorded crash force signal.  This machine requires a model for many reasons: command signal generation, operational prediction and optimization, and engineering research and development.  Therefore the model should be compilable for software but also flexible for engineering exploration (i.e. scriptable REPL mode).  Julia opens the door to making this more efficient for its solution to the dual language problem but also provides a full featured programming language and modular package system with integrated unit testing that additionally help greatly with model development.  ModelingToolkit offers the tools needed to easily rewrite and move the model from traditional modeling frameworks and provides not just the benefit of modeling in Julia, but a more flexible and open modeling tool.\r
\r
To successfully transition, a few missing features needed to be developed: 1. How to integrate Julia code in software, 2. How to enhance ModelingToolkit with: parameter management, global parameters, algebraic ODE tearing, and static model code generation.  We now have a faster model that is easier and more organized to develop with a testing and benchmarking suite to easily track and publish versioned changes.  There is still work to do but we now have what we need to develop our future products with Julia.`,recording_license:"",do_not_record:!1,persons:[{id:16567,code:"XYB7RA",public_name:"Bradley Carman",biography:"Brad Carman is a Mechanical Engineer at Instron specializing in System Modeling and Thermal Fluids with focus on model and software development for the Crash Simulation and Structural Durability products.",answers:[]}],links:[],attachments:[],answers:[]}],Purple:[{id:18012,guid:"9b0b9c63-c921-57a5-bd33-47d8eb58b7cf",logo:"",date:"2022-07-27T12:30:00+00:00",start:"12:30",duration:"00:30",room:"Purple",slug:"juliacon-2022-18012-automatic-differentiation-for-quantum-electron-structure",url:"https://pretalx.com/juliacon-2022/talk/LGWRV8/",title:"Automatic Differentiation for Quantum Electron Structure",subtitle:"",track:null,type:"Talk",language:"en",abstract:"DFTK.jl is a framework for the quantum-chemical simulation of materials using Density Functional Theory. Many relevant physical properties of materials, such as interatomic forces, stresses or polarizability, depend on the derivatives of quantities of interest with respect to input data. To perform such computations efficiently Automatic Differentiation has been implemented in DFTK using both forward and backward modes of AD.",description:`The quantum-chemical simulation of electronic structures is an established approach in materials research. The desire to tackle even bigger systems and more involved materials, however, keeps posing challenges with respect to physical models, reliability and performance of methods such as Density Functional Theory (DFT). For instance, many relevant physical properties of materials, such as interatomic forces, stresses or polarizability, depend on the derivatives of quantities of interest with respect to some input data. To perform efficiently such computations, Automatic Differentiation has been recently implemented into DFTK (https://dftk.org), a Julia package for DFT, which aims to be fast enough for practical calculations.\r
\r
Automatic Differentiation (AD, also known as Algorithmic Differentiation) allows the efficient and accurate calculation of derivatives of first and higher order of mathematical expressions, implicitly defined by source code.\r
The two most common modes of AD are tangent (forward) and adjoint (reverse) mode.\r
Of special interest is the reverse mode, as it allows to propagate derivative information from the outputs of some computation back to its inputs. This yields a computational complexity which scales with the number of outputs, as opposed to scaling with the number of inputs, like traditional finite differences or tangent AD.\r
In many applications in computational math, engineering, ML and finance the number of outputs is small (e.g. 1 for a least squares cost function), while the number of inputs is bigger by orders of magnitude.\r
\r
Julia is based on the LLVM stack and allows inspection and modification of its own AST, as well as other already optimized code structures  at run time.\r
This promises to combine the strengths of both operator-overloading style AD tools (flexibility, no running out of sync with the primal, coverage of all language features) and source code transformation style AD tools (less memory overhead, generated derivative code can be optimized by compiler).\r
This has spawned a variety of AD tools in the Julia ecosystem (see e.g. https://juliadiff.org for a enumeration of tools), each with its own design goals but also limitations.\r
\r
The need to make these tools work together under a common interface has been identified by the Julia community and led to the development of the ChainRules.jl package.\r
\r
We use Zygote to create automatic source code as much as possible.\r
There are two major reasons Zygote might not be used:\r
- The code to be differentiated uses features not supported by Zygote (e.g. use of mutation) and can not be sensibly refactored to a version conforming to Zygotes generation rules (e.g. due to performance requirements of the primal)\r
- Mathematical insight allows us to more efficiently implement the adjoint pullback by hand (e.g. terms with cancelling derivatives, symbolic differentiation of linear solvers, FFTs, etc.)\r
For both of these use cases we use the ChainRules interface to specify custom rrules.\r
For the performance critical parts of the primal we plan to investigate tools that support mutation (e.g. Enzyme), though we expect this to come with its own challenges.\r
\r
Some of the custom rrules we implemented in ChainRules required mathematical investigation to achieve numerical stability of response properties. In particular, the variation of the ground state density with respect to a perturbative external potential solves a linear system which is ill-conditioned when working with metals. We propose a unified mathematical framework from the literature to enhance stability, via appropriate gauge choices and a Schur complement.\r
\r
We will present our approach to introduce AD into an existing codebase, lessons learned, and what design patterns are suitable to both good performance and good compatibility with existing AD tools.`,recording_license:"",do_not_record:!1,persons:[{id:18406,code:"QHAXTM",public_name:"Markus Towara",biography:"https://github.com/JuliaMolSim/DFTK.jl",answers:[]},{id:18407,code:"ZZGUKJ",public_name:"Niklas Schmitz",biography:"Computer science student in the ML group at TU Berlin. Interested in physics, differentiable programming,  abstractions and programming languages.",answers:[]},{id:18445,code:"NZRHS3",public_name:"Gaspard Kemlin",biography:"I am 3rd year PhD student at CERMICS, ENPC and Inria Paris, team MATHERIALS. I work on numerical analysis of PDEs for quantum chemistry, and in particular electronic structure calculations. Part of my work uses the Density Functional ToolKit (DFTK.jl), a Julia package developed by Michael F. Herbst and Antoine Levitt.",answers:[]}],links:[],attachments:[],answers:[]},{id:17917,guid:"2b1c3bce-cf6d-536a-b2e9-6deffa4c50a5",logo:"",date:"2022-07-27T13:00:00+00:00",start:"13:00",duration:"00:30",room:"Purple",slug:"juliacon-2022-17917-fast-forward-and-reverse-mode-differentiation-via-enzyme-jl",url:"https://pretalx.com/juliacon-2022/talk/X3UUFD/",title:"Fast Forward and Reverse-Mode Differentiation via Enzyme.jl",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Enzyme is a new LLVM-based differentiation framework capable of creating fast derivatives in a variety of languages. In this talk we will showcase improvements in Enzyme.jl, the Julia-language bindings for Enzyme that enable us to differentiate through parallelism (Julia tasks, MPI.jl, etc), mutable memory, JIT-constructs, all while maintaining performance. Moreover we will also showcase Enzyme's new forward mode capabilities in addition to its existing reverse-mode features.",description:"",recording_license:"",do_not_record:!1,persons:[{id:10358,code:"FEJFGM",public_name:"William Moses",biography:"William S. Moses is a Ph.D. Candidate at MIT, where he also received his M.Eng in electrical engineering and computer science (EECS) and B.S. in EECS and physics. William\u2019s research involves creating compilers and program representations that enable performance and use-case portability, thus enabling non-experts to leverage the latest in high-performance computing and ML. He is known as the lead developer of Enzyme (NeurIPS \u201920, SC \u201921), an automatic differentiation tool for LLVM capable of differentiating code in a variety of languages, after optimization, and for a variety of architectures and the lead developer of Polygeist (PACT \u201921), a polyhedral compiler and C++ frontend for MLIR. He has also worked on the Tensor Comprehensions framework for synthesizing high-performance GPU kernels of ML code, the Tapir compiler for parallel programs (best paper at PPoPP \u201917), and compilers that use machine learning to better optimize. He is a recipient of the U.S. Department of Energy Computational Science Graduate Fellowship and the Karl Taylor Compton Prize, MIT\u2019s highest student award.",answers:[]},{id:18332,code:"CPB7FG",public_name:"Ludger Paehler",biography:"Grad Student at TU Munich",answers:[]},{id:18345,code:"9LZBUX",public_name:"Tim Gymnich",biography:"Tim is a postgraduate student at TU Munich, where he is studying for his M.Sc. in Computer Science. His main interests are in compiler optimizations for high performance computing and programming languages.",answers:[]},{id:903,code:"3C7UBC",public_name:"Valentin Churavy",biography:"asads",answers:[]}],links:[],attachments:[],answers:[]},{id:17957,guid:"034ae69d-32f3-58a1-b302-c02d6e4d82b3",logo:"/media/juliacon-2022/submissions/AGW8BR/junction-trees-logo_6CMV6nQ.png",date:"2022-07-27T14:30:00+00:00",start:"14:30",duration:"00:10",room:"Purple",slug:"juliacon-2022-17957-junctiontrees-bayesian-inference-in-discrete-graphical-models",url:"https://pretalx.com/juliacon-2022/talk/AGW8BR/",title:"JunctionTrees: Bayesian inference in discrete graphical models",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"JunctionTrees.jl implements the junction tree algorithm: an efficient method to perform Bayesian inference in discrete probabilistic graphical models. It exploits Julia's metaprogramming capabilities to separate the algorithm into a compilation and a runtime phase. This opens a wide range of optimization possibilities in the compilation stage. The non-optimized runtime performance of JunctionTrees.jl is similar to those of analog C++ libraries such as libdai and Merlin.",description:`GitHub repo: https://github.com/mroavi/JunctionTrees.jl\r
Docs: https://mroavi.github.io/JunctionTrees.jl\r
\r
JunctionTrees.jl encapsulates the result of the research we have been conducting in the context of improving the efficiency of Bayesian inference in probabilistic graphical models.\r
\r
The junction tree algorithm is a core component of discrete inference in probabilistic graphical models. It lies at the heart of many courses that are taught at different universities around the world including MIT, Berkeley, and Stanford. Moreover, it serves as the backbone of successful commercial software, such as Hugin Expert, that aims to discover insight and provide predictive capabilities to effectively combat fraud and risk.\r
\r
JunctionTrees.jl is mainly tailored towards students and researchers. This library offers a great starting point for understanding the implementation details of this algorithm thanks to the intrinsic readability of the Julia language and the thoroughly commented codebase. Moreover, this package constitutes an optimization framework that other researchers can make use of to experiment with different ideas to improve the performance of runtime Bayesian inference.`,recording_license:"",do_not_record:!1,persons:[{id:17892,code:"GFMR8R",public_name:"Martin Roa Villescas",biography:"Martin Roa-Villescas received his B.Sc. degree in Electronic Engineering from the National University of Colombia, Manizales, Colombia in 2010, and his M.Sc. degree in Embedded Systems from the Eindhoven University of Technology (TU/e), Eindhoven, The Netherlands, in 2013. He is currently pursuing a Ph.D. degree in Bayesian Machine Learning with a special track in education at TU/e. From 2013 to 2018, he worked as an embedded software designer in Philips Research, Eindhoven, The Netherlands. His research interests include probabilistic graphical models, probabilistic programming, and embedded systems.",answers:[]}],links:[],attachments:[],answers:[]},{id:18056,guid:"a90c6009-6a91-5df2-bef3-be678d1d1143",logo:"",date:"2022-07-27T14:40:00+00:00",start:"14:40",duration:"00:10",room:"Purple",slug:"juliacon-2022-18056-automated-finite-elements-a-comparison-between-julia-and-c-",url:"https://pretalx.com/juliacon-2022/talk/FPZVML/",title:"Automated Finite Elements: a comparison between Julia and C++",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:'With Gridap, Julia has a Finite Element package that allows writing expressions that closely mimic the mathematical notation of the weak form of an equation and automate the assembly of the linear system from there. Rather than using macros, the equations are interpreted as regular Julia expressions. This approach is similar to what has been done in C++, e.g. in the Coolfluid 3 CFD code. In this talk, both methods will be compared, showing how Julia really is "C++ done right" for this use case.',description:`This talk will be about comparing the implementation of the stabilized Navier-Stokes equations for incompressible flow, both using the [Gridap](https://github.com/gridap/Gridap.jl) package in Julia and using a [Boost.Proto](https://www.boost.org/doc/libs/1_78_0/doc/html/proto.html) based C++ code. The concrete C++ implementation can be found [here](https://github.com/barche/coolfluid3/blob/688173daa1a7cf32929b43fc1a0d9c0655e20660/plugins/UFEM/src/UFEM/NavierStokesAssembly.hpp#L57-L65), while the equivalent Gridap code is [here](https://github.com/barche/Channel_flow/blob/94aeb2982e01b08ff41848091a3b5d0b7b2a3983/Channel_2d_3d.jl#L104-L110). Aside from the obvious differences due to the use of unicode and the fact that Gridap operates at a higher level of abstraction, there are also some striking similarities in both approaches. The main point is that both packages operate on expressions that are valid code in the programming language that is used (i.e. Julia for Gridap, C++ for [Coolfluid 3](https://github.com/barche/coolfluid3)). This is possible because both languages offer a lot of flexibility in terms of operator overloading and strong typing. In the case of C++, the Boost.Proto library helps with building a structured framework for the interpretation of the expressions, based on the idea of expression templates and thus avoiding runtime overhead of inheritance in C++. In Julia, this step is taken care of using the built-in type system and generated functions.\r
\r
The whole objective of this type of machinery is to offer a simple interface to the user, but end up with a finite element assembly loop that is as fast as possible. To this end, information such as the size of element matrices and vector dimensions must be known to the compiler. We will show that both systems indeed achieve this, and result in good performance for the assembly loop.\r
\r
Due to the similarity in approach, the experience visible to the end user is also similar: both systems exhibit long compilation times and long error messages in case of user errors such as mixing up incompatible matrix dimensions. This will be illustrated using examples.\r
\r
Finally, more advanced numerical techniques, such as the stabilized methods used in fluid simulations, require the user to be able to define custom functions that are used during assembly, e.g. to calculate the value of stabilization coefficients. This is where Julia really shines, as it is possible to simply define a normal function, while in C++ some extensive boilerplate code is required, as will be shown.\r
\r
The conclusion is that Gridap has reached a level of maturity that makes it very attractive to use Julia for this kind of work. Even if some performance optimization may still be needed, development of and experimenting with new numerical methods is much easier than in a complicated C++ code.`,recording_license:"",do_not_record:!1,persons:[{id:4225,code:"H3TNC7",public_name:"Bart Janssens",biography:"Bart Janssens is a military associate professor at the mechanics department of the [Royal Military Academy](https://www.rma.ac.be), with a passion for computer graphics, high performance computing and fluid mechanics. For performance reasons, he used C++ until being introduced to Julia. His current work focuses on stabilized finite element methods, and he recently started a new study on the topic where for the first time the main focus will be on using Julia and Gridap rather than the legacy C++ code.",answers:[]}],links:[],attachments:[],answers:[]},{id:16947,guid:"ef208143-9839-5b0a-856d-550d255f164d",logo:"",date:"2022-07-27T14:50:00+00:00",start:"14:50",duration:"00:10",room:"Purple",slug:"juliacon-2022-16947-distributed-automl-pipeline-search-in-pc-raspi-k8s-cluster",url:"https://pretalx.com/juliacon-2022/talk/K7VNZJ/",title:"Distributed AutoML Pipeline Search in PC/RasPi K8s Cluster",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"In this lightning talk, I will present an example workflow in leveraging the Kubernetes cluster of RaspberryPis to perform parallel search in finding the best AutoML pipeline in a given classification task. While many applications of RasPis are targeted for IOT usage, a K8s cluster of RasPis running Julia can be targeted to solve more complex problems and I will provide examples of the cluster performance running AutoMLPipeline applications.",description:"There is a growing need for low-power computing devices due to their minimal thermal and energy footprint to be used in many HPC applications such as weather forecasting, ocean engineering, smarthome computing, biocomputing, AI modeling, etc.  ARM-based processors such RasPis provide an attractive solution because they are cheap, versatile, and has great Linux hardware support as well as stable Julia releases. Due to its full Linux compatibility, making a K8s cluster from a bunch of RasPis become a trivial exercise as well as running Julia's cluster manager on top of K8s. This talk will provide an overview and an example walk-through how to leverage Julia+Raspis+K8s combinations to solve certain ML pipeline optimization tasks.",recording_license:"",do_not_record:!1,persons:[{id:1072,code:"3EKCYY",public_name:"Paulito Palmes",biography:`I am a research scientist at the IBM Research Europe (Dublin Research Lab) working in the areas of analytics, datamining, machine learning, reinforcement learning, automated decisions, and AI.\r
\r
I finished my Doctor of Engineering degree from the Toyohashi University of Technology in Japan (2005). I have a Master's degree in Computer Science majoring in Artificial Intelligence (Ateneo de Manila University, 1995) and a Bachelor's degree in Applied Mathematics (cum laude, valedictorian) at the University of the Philippines in the Visayas (1991).\r
\r
I created and maintain the following Julia packages:\r
- [AutoMLPipeline (Automated Machine Learning Pipeline)](https://github.com/IBM/AutoMLPipeline.jl)\r
- [TSML (Time Series Machine Learning)](https://github.com/IBM/TSML.jl)\r
- [Julia wrapper for Lale in Python](https://github.com/IBM/Lale.jl)`,answers:[]}],links:[],attachments:[],answers:[]},{id:16301,guid:"0f849e15-08e7-5c78-9f54-cf256b91bf19",logo:"",date:"2022-07-27T15:00:00+00:00",start:"15:00",duration:"00:10",room:"Purple",slug:"juliacon-2022-16301-comonicon-a-full-stack-solution-for-building-cli-applications",url:"https://pretalx.com/juliacon-2022/talk/VME3D8/",title:"Comonicon, a full stack solution for building CLI applications",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"In this talk, I will introduce Comonicon. Comonicon is a CLI generator designed for Julia, unlike other CLI generators such as Fire, ArgParse, and so on, Comonicon does not only parse command-line arguments but also provide a full solution for building CLI application (via PackageCompiler), packing tarballs, generating shell auto-completion, CLI application installation, mitigating CLI latencies. I'll also talk about ideas arise from development about the future official Julia application.",description:`[Comonicon](https://github.com/comonicon/Comonicon.jl) is a CLI generator that aims to provide a full solution for CLI applications, this includes\r
\r
### Clean and Julian syntax\r
\r
the interface only has \`@main\` and \`@cast\` that will collect all the information from docstring to function signature to create the CLI. The usage is extremely simple, just put \`@main\` or \`@cast\` in front of the functions or modules you would like to convert to a CLI node. It has proven to have a very intuitive and user-friendly experience in the past 2 years. \r
\r
### Powerful and extensible code generators\r
\r
Comonicon is built around an intermediate representation for CLIs. This means the Comonicon frontend is decoupled with its backend, one can also directly construct the IR to generate their CLI as a more advanced feature. Then different backends will generate corresponding backend code like a standard compiler codegen. This currently includes:\r
\r
- a zero dependency command line arguments parsing function in Julia\r
- shell autocompletion (only ZSH is supported at the moment)\r
\r
and this can be easily extended to generate code for other interfaces, one very experimental work is [generating GUI directly from the Comonicon IR](https://github.com/comonicon/ComoniconGUI.jl).\r
\r
### Mitigating startup latencies\r
\r
Most Julia CLI generators suffer from startup latencies in Julia because of the JIT compilation, we have put a relatively large effort into mitigating this latency caused by the CLI generators. And because Comonicon is able to generate a zero-dependency function \`command_main\` that parses the CLI arguments, in extreme cases, one can completely get rid of \`Comonicon\` and use the generated code directly to reach the most ideal latency achievable in current Julia.\r
\r
### Build System\r
\r
Comonicon provides a full build system for shipping your CLIs to other people. This means Comonicon can handle the installation of a Julia CLI application that guarantees its reproducibility by handling the corresponding project environment correctly. Or build the CLI application into binaries via PackageCompiler then package the application as tarball. A glance at its build CLI\r
\r
\`\`\`\r
Comonicon - Builder CLI.\r
\r
Builder CLI for Comonicon Applications. If not sepcified, run the command install by default.\r
\r
USAGE\r
\r
    julia --project deps/build.jl [command]\r
\r
COMMAND\r
\r
    install                     install the CLI locally.\r
\r
    app [tarball]               build the application, optionally make a tarball.\r
\r
    sysimg [tarball]            build the system image, optionally make a tarball.\r
\r
    tarball                     build application and system image then make tarballs\r
                                for them.\r
\r
EXAMPLE\r
\r
    julia --project deps/build.jl install\r
\r
    install the CLI to ~/.julia/bin.\r
\r
\r
    julia --project deps/build.jl sysimg\r
\r
    build the system image in the path defined by Comonicon.toml or in deps by default.\r
\r
\r
    julia --project deps/build.jl sysimg tarball\r
\r
    build the system image then make a tarball on this system image.\r
\r
\r
    julia --project deps/build.jl app tarball\r
\r
    build the application based on Comonicon.toml and make a tarball from it.\r
\r
\`\`\`\r
\r
### Configurable\r
\r
The generated CLI application, the build options are all configurable via a \`Comonicon.toml\` file, one can easily change various default options directly from the configuration file to create your favorite CLI:\r
\r
- enable/disable colorful help message\r
- set Julia compile options\r
- bundle custom assets\r
- installation options\r
- ...\r
\r
### Summary\r
\r
Comonicon is currently the only CLI generator designed for Julia and handles the entire workflow of creating a serious CLI application and shipping it to users. It still has a few directions to improve and in the future Julia versions, we hope with the progress of static compilation we will eventually be able to build small binaries and ship them to all platforms in a simple workflow via Comonicon so that one day Julia can also do what go/rust/cpp/... can do in CLI application development.`,recording_license:"",do_not_record:!1,persons:[{id:917,code:"VRCN8Y",public_name:"Roger Luo",biography:"https://rogerluo.dev",answers:[]}],links:[],attachments:[],answers:[]},{id:17953,guid:"b2e03288-3458-5f49-8f19-af44a41eb6bb",logo:"/media/juliacon-2022/submissions/ZSARJD/image_OpGztQg.PNG",date:"2022-07-27T15:10:00+00:00",start:"15:10",duration:"00:10",room:"Purple",slug:"juliacon-2022-17953-cycles-and-julia-sets-novel-algorithms-for-numerical-analysis",url:"https://pretalx.com/juliacon-2022/talk/ZSARJD/",title:"Cycles and Julia Sets: Novel algorithms for Numerical Analysis",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"We present a new collection of algorithms dedicated to compute the basins of attraction of any complex rational map. This is a relevant matter in Holomorphic Dynamics, and also a way to visualize and study amazing fractal objects like Julia Sets. These algorithms solve many computational problems that often arise in Numerical Analysis, like overflows or mathematical indeterminations, and provide more information about the dynamics of the system than traditional algorithms generally do.",description:`In this talk we will present a new collection of algorithms dedicated to compute the basins of attraction of any complex rational map, and to study the dynamical behaviour of its fixed points and attracting n-cycles. By doing this, one can visualize and study amazingly beautiful and complex fractal objects like Julia Sets. The study of the basins of attraction of a dynamical system is a very relevant matter not only in Numerical Analysis and Holomorphic Dynamics, but also in other fields like Physics or Mechanical Engineering.\r
\r
We are going to describe the methods implemented in the Lyapunov Cycle Detector module, available in the following GitHub repository: https://github.com/valvarezapa/LCD. In it you will find the code itself, several explanations of how does the methods work, what do they do, a lot of practical examples and even a User Guide. \r
\r
Our work is based in very relevant theorems of Complex Dynamics, like the Ergodic Theorem, and is motivated by Sullivan's work on Dynamical Systems, recently awarded with the Abel prize. However, no previous knowledge about any of these topics is required, since we will focus on the algorithms and the implementation of the code. The graphics we will be able to generate are both rich and beautiful, and the concepts behind them are easy to grasp. Everyone interested in the mathematical framework or in any specific technicalities behind these algorithms can consult our paper "Algorithms for computing attraction basins of a self-map of the Hopf fibration based on Lyapunov functions" (currently on preprint).\r
\r
From a scientific computing point of view, this new collection of algorithms solve most of the computational problems that often arise in Numerical Analysis, like overflows or mathematical indeterminations. We achieve this by considering the Hopf endomorphism induced by the given rational map, and iterating it over the complex projective line (P^1(C)). This approach also allows us to easily work with the infinity point. Since this kind of calculations often have high computational cost, we benefit from Julia\u2019s efficiency and some built-in multi-threading macros in order to be able to visualize the results in a reasonable amount of time.\r
\r
From a mathematical perspective, we will be considering a discrete-time dynamical system given by a complex rational map. The techniques we use to compute the basins of attraction are based on Lyapunov functions and Lyapunov coefficients (which are closely related to Lyapunov exponents; a very powerful and commonly used concept in dynamical systems). The Lyapunov function we define is constant in each basin of attraction, and depends on the notion of spherical derivative of the given rational map. This way, we can divide the Riemann Sphere (the plane of complex numbers adding the infinity point) into the different basins of attraction (each one with an associated constant) and the Julia set. Most famous Julia sets can be computed and visualized this way. Also, our algorithms provide more information about the dynamics of the system than most traditional algorithms on this topic generally do. Our methods are focused on detecting the attracting n-cycles of the given rational map and its basins. Note that fixed points are just the particular case of 1-cycles. In addition, by using Lyapunov coefficients we are able to measure how much attracting is every n-cycle.`,recording_license:"",do_not_record:!1,persons:[{id:18369,code:"KF3NEC",public_name:"V\xEDctor \xC1lvarez Aparicio",biography:`Hi! I'm V\xEDctor \xC1lvarez Aparicio, math and scientific programming enthusiast. I'm currently working as a research fellow in University of La Rioja (Spain), studying applications of Topology in the field of Iteration of Rational Maps and Complex Dynamics. My colleagues and I mainly develop our algorithms in Julia Language.\r
\r
My interests are Algebraic Topology, Differential Topology, Complex Dynamics and Ergodic Theory, Iterative Proccesses, Scientific Programming, Julia Language, TDA (Topological Data Analysis), among others. I'm really glad and excited to join this community and to share our contributions with everyone interested!`,answers:[]}],links:[],attachments:[],answers:[]},{id:17974,guid:"bbb37306-3f4c-5ade-a677-8de3811dc0e8",logo:"/media/juliacon-2022/submissions/AKVUKM/logo_ParallelStencil_jc_iAdWnnz.png",date:"2022-07-27T15:20:00+00:00",start:"15:20",duration:"00:10",room:"Purple",slug:"juliacon-2022-17974-high-performance-xpu-stencil-computations-in-julia",url:"https://pretalx.com/juliacon-2022/talk/AKVUKM/",title:"High-performance xPU Stencil Computations in Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"We present an efficient approach for writing architecture-agnostic parallel high-performance stencil computations in Julia. Powerful metaprogramming, costless abstractions and multiple dispatch enable writing a single code that is usable for both productive prototyping on a single CPU and for production runs on GPU or CPU workstations or supercomputers. Performance similar to CUDA C is achievable, which is typically a large improvement over reachable performance with `CUDA.jl` Array programming.",description:"Our approach for the expression of architecture-agnostic high-performance stencil computations relies on the usage of Julia's powerful metaprogramming capacities, costless high-level abstractions and multiple dispatch. We have instantiated the approach in the Julia package `ParallelStencil.jl`. Using `ParallelStencil`, a simple call to the macro `@parallel` is enough to parallelize and launch a kernel that contains stencil computations, which can be expressed explicitly or with math-close notation. The package used underneath for parallelization is defined in a initialization call beforehand. Currently supported are `CUDA.jl` for running on GPU and `Base.Threads` for CPU. Leveraging metaprogramming, `ParallelStencil` automatically generates high-performance code suitable for the target hardware, and automatically derives kernel launch parameters from the kernel arguments by analyzing the extensions of the contained arrays. A set of architecture-agnostic low level kernel language constructs allows for explicit low level kernel programming when useful, e.g., for the explicit control of shared memory on the GPU (these low level constructs are GPU-computing-biased). \r\n\r\nArrays are automatically allocated on the hardware chosen for the computations (GPU or CPU) when using the allocation macros provided by `ParallelStencil`, avoiding any need of code duplication. Moreover, the allocation macros are fully declarative in order to let `ParallelStencil` choose the best data layout in memory. Notably, logical arrays of structs (or of small arrays) can be either laid out in memory as arrays of structs or as structs of arrays accounting for the fact that each of these allocation approaches has its use cases where it performs best.\r\n\r\n`ParallelStencil` is seamlessly interoperable with packages for distributed parallelization, as e.g. `ImplicitGlobalGrid.jl` or `MPI.jl`, in order to enable high-performance stencil computations on GPU or CPU supercomputers. Communication can be hidden behind computation with as simple macro call. The usage of this feature solely requires that communication can be triggered explicitly as it is possible with, e.g, `ImplicitGlobalGrid` and `MPI.jl`.\r\n\r\nWe demonstrate the wide applicability of our approach by reporting on several multi-GPU solvers for geosciences as, e.g., 3-D solvers for poro-visco-elastic twophase flow and for reactive porosity waves. As reference, the latter solvers were ported from MPI+CUDA C to Julia using `ParallelStencil` and `ImplicitGlobalGrid` and achieve 90% and 98% of the performance of the original solvers, respectively, and a nearly ideal parallel efficiency on thousands of NVIDIA Tesla P100 GPUs at the Swiss National Supercomputing Centre. Moreover, we have shown in recent contributions that the approach is naturally in no way limited to geosciences: we have showcased a computational cognitive neuroscience application modelling visual target selection using `ParallelStencil` and `MPI.jl` and a quantum fluid dynamics solver using the Nonlinear Gross-Pitaevski Equation implemented with `ParallelStencil` and `ImplicitGlobalGrid`.\r\n\r\nCo-authors: Ludovic R\xE4ss\xB9 \xB2\r\n\r\n\xB9 ETH Zurich | \xB2 Swiss Federal Institute for Forest, Snow and Landscape Research (WSL)",recording_license:"",do_not_record:!1,persons:[{id:4264,code:"QTKXPY",public_name:"Samuel Omlin",biography:"Computational Scientist and responsible for Julia computing at the Swiss National Supercomputing Centre (CSCS), ETH Zurich",answers:[]},{id:4202,code:"ZTATFJ",public_name:"Ludovic R\xE4ss",biography:"Geoscientist with strong interests in Julia, HPC, GPUs, and supercomputing. Applications to resolve multi-physics processes in ice dynamics and geodynamics across scales.",answers:[]}],links:[],attachments:[],answers:[]},{id:17975,guid:"a8743484-5460-5d44-8d58-8ca29b4ce2ea",logo:"/media/juliacon-2022/submissions/RJYBLA/logo_ImplicitGlobalGrid_jc_WBpxQfb.png",date:"2022-07-27T15:30:00+00:00",start:"15:30",duration:"00:10",room:"Purple",slug:"juliacon-2022-17975-distributed-parallelization-of-xpu-stencil-computations-in-julia",url:"https://pretalx.com/juliacon-2022/talk/RJYBLA/",title:"Distributed Parallelization of xPU Stencil Computations in Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"We present a straightforward approach for distributed parallelization of stencil-based Julia applications on a regular staggered grid using GPUs and CPUs. The approach allows to leverage remote direct memory access and was shown to enable close to ideal weak scaling of real-world applications on thousands of GPUs. The communication performed can be easily hidden behind computation.",description:"The approach presented here renders the distributed parallelization of stencil-based GPU and CPU applications on a regular staggered grid almost trivial. We have instantiated the approach in the Julia package `ImplicitGlobalGrid.jl`. A highlight in the design of `ImplicitGlobalGrid` is the automatic implicit creation of the global computational grid based on the number of processes the application is run with (and based on the process topology, which can be explicitly chosen by the user or automatically defined). As a consequence, the user only needs to write a code to solve his problem on one GPU/CPU (local grid); then, as little as three functions can be enough to transform a single GPU/CPU application into a massively scaling Multi-GPU/CPU application: a first function creates the implicit global staggered grid, a second funtion performs a halo update on it, and a third function finalizes the global grid.\r\n\r\n`ImplicitGlobalGrid` relies on `MPI.jl` to perform halo updates close to hardware limits. For GPU applications, `ImplicitGlobalGrid` leverages remote direct memory access when CUDA- or ROCm-aware MPI is available and uses highly optimized asynchronous data transfer routines to move the data through the hosts when CUDA- or ROCm-aware MPI is not present. In addition, pipelining is applied on all stages of the data transfers, improving the effective throughput between GPU and GPU. Low level management of memory, CUDA streams and ROCm queues permits to efficiently reuse send and receive buffers and streams throughout an application without putting the burden of their management to the user. Moreover, all data transfers are performed on non-blocking high-priority streams, allowing to overlap the communication optimally with computation. `ParallelStencil.jl`, e.g., can do so with a simple macro call.\r\n\r\n`ImplicitGlobalGrid` is fully interoperable with `MPI.jl`. By default, it creates a Cartesian MPI communicator, which can be easily retrieved together with other MPI variables. Alternatively, an MPI communicator can be passed to `ImplicitGlobalGrid` for usage. As a result, `ImplicitGlobalGrid`'s functionality can be seamlessly extended using `MPI.jl`.\r\n\r\nThe modular design of `ImplicitGlobalGrid`, which heavily relies on multiple dispatch, enables adding support for other hardware with little development effort. Support for AMD GPUs using the recently matured `AMDGPU.jl` package has already been implemented as a result. `ImplicitGlobalGrid` supports at present distributed parallelization for CUDA- and ROCm-capable GPUs as well as for CPUs.\r\n\r\nWe show that our approach is broadly applicable by reporting scaling results of a 3-D Multi-GPU solver for poro-visco-elastic twophase flow and of various mini-apps which represent common building blocks of geoscience applications. For all these applications, nearly ideal parallel efficiency on thousands of NVIDIA Tesla P100 GPUs at the Swiss National Supercomputing Centre is demonstrated. Moreover, we have shown in a recent contribution that the approach is naturally in no way limited to geosciences: we have showcased a quantum fluid dynamics solver using the Nonlinear Gross-Pitaevski Equation implemented with `ParallelStencil` and `ImplicitGlobalGrid`.\r\n\r\nCo-authors: Ludovic R\xE4ss\xB9 \xB2,  Ivan Utkin\xB9\r\n\r\n\xB9 ETH Zurich | \xB2 Swiss Federal Institute for Forest, Snow and Landscape Research (WSL)",recording_license:"",do_not_record:!1,persons:[{id:4264,code:"QTKXPY",public_name:"Samuel Omlin",biography:"Computational Scientist and responsible for Julia computing at the Swiss National Supercomputing Centre (CSCS), ETH Zurich",answers:[]},{id:4202,code:"ZTATFJ",public_name:"Ludovic R\xE4ss",biography:"Geoscientist with strong interests in Julia, HPC, GPUs, and supercomputing. Applications to resolve multi-physics processes in ice dynamics and geodynamics across scales.",answers:[]}],links:[],attachments:[],answers:[]},{id:17918,guid:"5c165dab-1f48-5de3-bdda-479fa48b1139",logo:"",date:"2022-07-27T15:40:00+00:00",start:"15:40",duration:"00:10",room:"Purple",slug:"juliacon-2022-17918-building-julia-proxy-mini-apps-for-hpc-system-evaluation",url:"https://pretalx.com/juliacon-2022/talk/CJZ3MV/",title:"Building Julia proxy mini apps for HPC system evaluation",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"We will showcase our efforts building Julia proxy applications, or mini apps, targeting the Summit and Frontier supercomputers. We developed XSBench.jl to simulate on-node CPU and GPU scalability of a Monte Carlo computational kernel and, and RIOPA.jl for parallel input/output (I/O) strategies. We will share the lessons learned from Julia\u2019s fresh approach for performance and productivity as a viable language, similar to Fortran, C and C++ for high-performance computing (HPC) systems.",description:"We are developing Julia proxy applications, also known as mini apps, to understand the effects of parallel computation, memory, network and input/output (I/O) on the latest U.S. Department of Energy (DOE) extremely heterogeneous high-performance computing (HPC) systems. Our initial targets are the systems hosted at the Oak Ridge Leadership Computing Facility (OLCF): the Summit supercomputer, powered by IBM CPUs and NVIDIA GPUs; and the upcoming Frontier exascale system, powered by AMD CPUs and GPUs. Proxy applications, or mini apps, are simple yet powerful programs that isolate the important computational aspects that drive fully featured science applications. In this lighting talk, our efforts in developing two open-source proxy applications are presented: i) XSBench.jl, which is a port of the original C-based XSBench proxy app used to simulate on-node scalability of the OpenMC Monte Carlo computational kernel on CPU, and AMD and NVIDIA GPUs and, ii) RIOPA.jl, a Julia proxy application designed to mimic parallel I/O application characteristics and payloads. In particular, we are interested in the feasibility of using Julia as a HPC language, similar to Fortran, C and C++,  by evaluating the current state and integration with HPC heterogenous programming models and backends: MPI.jl, Julia\u2019s Base Threads, GPU programming: CUDA.jl, AMDGPU.jl and KernelAbstractions.jl; parallel I/O: HDF5.jl and ADIOS2.jl; and the portability of the resulting Julia proxy application across heterogeneous systems. We will share with the Julia community the current challenges, gaps and highlight potential opportunities to balance the trade-offs between programmer productivity and performance in a HPC environment as we prepare for the exascale era in supercomputing. Our goal is to showcase the value added by the Julia language in our early work constructing proxy apps for rapid prototyping as part of our efforts in the U.S. DOE Exascale Computing Project (ECP).",recording_license:"",do_not_record:!1,persons:[{id:10119,code:"QQZ83B",public_name:"William F Godoy",biography:"Senior Computer Scientist in the Computational Science and Mathematics Division at Oak Ridge National Laboratory. Interests in High-Performance Computing (HPC) infrastructure, computational physics and large scale simulations. Julia aficionado.",answers:[]},{id:18329,code:"898839",public_name:"Jeffrey Vetter",biography:null,answers:[]},{id:18464,code:"WQAWRU",public_name:"Philip Fackler",biography:"Research Software Engineer at Oak Ridge National Laboratory",answers:[]}],links:[],attachments:[],answers:[]},{id:21255,guid:"bc67ef0d-1200-5689-a772-133127c4793f",logo:"",date:"2022-07-27T15:50:00+00:00",start:"15:50",duration:"00:05",room:"Purple",slug:"juliacon-2022-21255-asml-sponsored-talk",url:"https://pretalx.com/juliacon-2022/talk/FEWD7V/",title:"ASML Sponsored Talk",subtitle:"",track:null,type:"Silver sponsor talk",language:"en",abstract:"We make machines that make chips; the hearts of the devices that keep us informed, entertained and safe.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:21251,guid:"3db2dcf4-785b-5226-a6f0-18cc5aedf746",logo:"",date:"2022-07-27T15:55:00+00:00",start:"15:55",duration:"00:05",room:"Purple",slug:"juliacon-2022-21251-metalenz-sponsored-talk",url:"https://pretalx.com/juliacon-2022/talk/VCSHJ3/",title:"MetaLenz Sponsored Talk",subtitle:"",track:null,type:"Silver sponsor talk",language:"en",abstract:"Metalenz is commercializing metasurface technology and transforming optical sensing in consumer electronics and automotive markets.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:18169,guid:"12c29768-20cb-5616-810a-39e1d2ac917d",logo:"",date:"2022-07-27T19:00:00+00:00",start:"19:00",duration:"00:30",room:"Purple",slug:"juliacon-2022-18169-quantum-computing-with-itensor-and-pastaq",url:"https://pretalx.com/juliacon-2022/talk/CSARPH/",title:"Quantum computing with ITensor and PastaQ",subtitle:"",track:null,type:"Talk",language:"en",abstract:"We introduce PastaQ.jl, a computational toolbox for simulating, designing, and benchmarking quantum hardware. PastaQ relies on a tensor network description of quantum processes, built on top of ITensors.jl, a leading library for efficient tensor network algorithms. Leveraging recent developments in tensor network differentiation in ITensor, PastaQ provides access to a broad range of computational tools to tackle a tasks routinely encountered when building quantum computers.",description:`Quantum computers provide a new computational paradigm with far-reaching implications for a variety of scientific disciplines. Small quantum computers exist in today\u2019s laboratories, but due to imperfections and noise, these machines can only handle problems of limited complexity. The successful development of larger quantum devices requires improved qubit manufacturing and control, active error correction, as well as theoretical advances.\r
\r
In practice, when building a quantum computer, tasks throughout the quantum computing stack rely on efficient classical algorithms running on conventional computers. These tasks include simulations for designing quantum gates and circuits, qubit calibration, and device characterization/benchmarking. Tensor networks are a powerful framework for describing and simulating quantum systems. They play an important role in simulating the quantum dynamics underlying the experimental hardware, reconstructing quantum processes from measurements, and correcting errors in quantum devices.\r
\r
PastaQ.jl is a new Julia package for quantum computing built on top of ITensors.jl. ITensors.jl is an established tensor network software library with a unique memory-independent array/tensor interface. ITensor provides a high level and flexible interface for easily calling state of the art tensor network algorithms and developing new tensor network algorithms. Recently in ITensor we have been adding support for automatic differentiation by adding differentiation rules with ChainRules.jl. These range from basic rules for tensor contraction to higher level rules for differentiating quantum state evolution. PastaQ builds on top of this new differentiation support in ITensor to enable a variety of quantum computing applications like the design/optimization of quantum gates via optimal control theory, simulation of quantum circuits, classical optimization of variational circuits, quantum tomography, etc. In this talk, we will discuss some basics of tensor network differentiation in ITensor, and discuss how these new differentiation tools are leveraged in PastaQ for advanced applications in designing and analyzing quantum computers.`,recording_license:"",do_not_record:!1,persons:[{id:18499,code:"FACVUA",public_name:"Giacomo Torlai",biography:`I am a research scientists at the Amazon Web Services Center for Quantum Computing, Pasadena (California). Previously I was a research fellow at the Center for Computational Quantum Physics of the Flatiron Institute (New York), and earned a PhD in physics at the University of Waterloo and the Perimeter Institute for Theoretical Physics, Waterloo (Canada). I am the lead developer of PastaQ.jl. \r
https://twitter.com/giactorlai`,answers:[]},{id:4147,code:"8Q8AYS",public_name:"Matthew Fishman",biography:"Associate Data Scientist (Research Software Engineer) at the Center for Computational Quantum Physics (CCQ) at the Flatiron Institute in New York. I'm lead developer of ITensors.jl (co-developed with Miles Stoudenmire), a software library for easily developing and running efficient tensor network calculations. Co-developer of PastaQ.jl with Giacomo Torlai.",answers:[]}],links:[],attachments:[],answers:[]},{id:18142,guid:"42d21151-cd7f-5c97-82c0-3651f218b474",logo:"/media/juliacon-2022/submissions/KJTGC3/logo_2_fHtFhy4.png",date:"2022-07-27T19:30:00+00:00",start:"19:30",duration:"00:30",room:"Purple",slug:"juliacon-2022-18142-quantumcircuitopt-for-provably-optimal-quantum-circuit-design",url:"https://pretalx.com/juliacon-2022/talk/KJTGC3/",title:"QuantumCircuitOpt for Provably Optimal Quantum Circuit Design",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"A key aspect for operating near-term intermediate-scale quantum (NISQ) computers is to develop compact circuits to implement quantum algorithms, given the hardware's architectural constraints. Efficient formulations and algorithms to solve such hard optimization problems with optimality guarantees is a key in designing such NISQ devices. This talk provides an overview of QuantumCircuitOpt.jl, a software package developed at LANL for provably optimal synthesis of architecture for Quantum circuits",description:`In recent years, the quantum computing community has seen an explosion of novel methods to implement non-trivial quantum computations on near-term intermediate-scale quantum (NISQ) hardware. An important direction of research has been to decompose an arbitrary entangled state, represented as a unitary, into a quantum circuit, that is, a sequence of gates supported by a quantum processor. It has been well known that circuits with longer decompositions and more entangling multi-qubit gates are error-prone for the current noisy, intermediate-scale quantum devices. To this end, we present the framework of "QuantumCircuitOpt" package, which is aimed at providing provably optimal quantum circuit design.\r
\r
"QuantumCircuitOpt.jl" (QCOpt in short), is an open-source, Julia-based, package for provably optimal quantum circuit design. QCOpt implements mathematical optimization formulations and algorithms for decomposing arbitrary unitary gates into a sequence of hardware-native gates with global optimality guarantees on the quality of the designed circuit. To this end, QCOpt takes the following inputs: the total number of qubits, the set of hardware-native elementary gates, the target gate to be decomposed, and the maximum allowable size (depth) of the circuit. Given these inputs, QCOpt invokes appropriate gates from a menagerie of gates implemented within the package, reformulates the optimization problem into a mixed-integer program (MIP), applies feasibility-based bound propagation, derives various hardware-relevant valid constraints to reduce the search space, and finally provides an optimal circuit with error guarantees. On a variety of benchmark quantum gates, we show that QCOpt can find up to 57% reduction in the number of necessary gates on circuits with up to four qubits, and in run times less than a few minutes on commodity computing hardware. We also validate the efficacy of QCOpt as a tool for quantum circuit design in comparison with a naive brute-force enumeration algorithm. We also show how the QCOpt package can be adapted to various built-in types of native gate sets, based on different hardware platforms like those produced by IBM, Rigetti and Google.\r
\r
Package link: https://github.com/harshangrjn/QuantumCircuitOpt.jl`,recording_license:"",do_not_record:!1,persons:[{id:9538,code:"YZAWN9",public_name:"Harsha Nagarajan",biography:"Harsha Nagarajan is currently a staff scientist in the \u201CApplied Mathematics and Plasma Physics\u201D group at Los Alamos National Laboratory (LANL). His research interests include development of efficient formulations and algorithms for modeling, design and control of complex physical systems.",answers:[]}],links:[],attachments:[],answers:[]},{id:17260,guid:"a93429bb-90b1-5b5a-ae9a-1ceb5d3236e1",logo:"/media/juliacon-2022/submissions/XNRBWC/SpinTrajExample_OkhvcoD.png",date:"2022-07-27T20:00:00+00:00",start:"20:00",duration:"00:30",room:"Purple",slug:"juliacon-2022-17260-simulating-and-visualizing-quantum-annealing-in-julia",url:"https://pretalx.com/juliacon-2022/talk/XNRBWC/",title:"Simulating and Visualizing Quantum Annealing in Julia",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"QuantumAnnealing.jl provides a toolkit for performing simulations of Adiabatic Quantum Computers on classical hardware. The package includes functionality for rapid simulation of the Schrodinger evolution of the system, processing annealing schedules used by real world annealing hardware, implementing custom annealing schedules, and more.",description:`The field of Quantum Computation has been rapidly growing in recent years.  One driving factor behind this growth is the computational intractability of simulating quantum systems.  The classical overhead for simulating quantum systems grows exponentially as the system size increases, making quantum computers an appealing option for performing these simulations.  Algorithms have also been developed to perform actions such as search and optimization on quantum computers.  Quantum Annealing is an optimization method which makes use of an adiabatic quantum computer to try to find a global minima.  It relies on the Adiabatic Theorem which states that if a quantum system is prepared in its ground state, if the system evolves slowly enough it will stay in its ground state.  A few companies have created quantum annealing hardware, most notably D-Wave Systems, so it is useful to be able to simulate small anneals to look for signatures that imply that the quantum annealing hardware is behaving as expected.  To accomplish this, we can solve the Schrodinger equation with the time varying Hamiltonian for the quantum annealer we wish to simulate.\r
\r
That is where this package comes into play.  QuantumAnnealing.jl allows for the simulation of a quantum annealer with arbitrary annealing schedule (two functions which dictate how the system evolves from the initial "easy" state to the final "problem" state), and arbitrary target hamiltonian (the encoding of the problem which is supposed to be solved by the quantum annealer).  This package also provides functionality for implementing controls on the annealing schedules, such as holding the schedules constant for a set amount of time (often called a pause) or increasing the speed of the anneal (often called a quench), as well as the ability to directly process D-Wave hardware schedules from CSV files into annealing schedule functions used by the simulator.  The simulation can be performed either by using a wrapper around DifferentialEquations.jl, or by using a specialized solver we have written to quickly and accurately simulate the closed system evolution of the quantum annealing hamiltonian.  This solver makes use of the Magnus Expansion and includes hard-coded implementations up to the fourth order, as well as a general implementation if a higher order solver is needed.  This hardcoded solver has empirically produced a 20-30x speed improvement over the DifferentialEquations.jl wrapper.\r
\r
Alongside QuantumAnnealing.jl, we have released a plotting package, QuantumAnnealingAnalytics.jl which provides useful plotting functionality for common use-cases of the QuantumAnnealing.jl package.  QuantumAnnealingAnalytics.jl includes functions to plot the instantaneous ground state of the Hamiltonian (useful for determining how quickly it is expected that the system can evolve without leaving the ground state), plotting the probabilities of various energy levels for the final system (useful for comparing output statistics from hardware), and plotting output statistics from data files in the bqpjson format.  This allows for much easier understanding of the system the user is working with and can be used to quickly reproduce figures found in seminal works in the field of Quantum Annealing.`,recording_license:"",do_not_record:!1,persons:[{id:18105,code:"B3K3DN",public_name:"Zachary Morrell",biography:"I am a Postbac working at Los Alamos National Laboratory researching Quantum Annealing.  I recently graduated from the University of New Mexico with a double major in Computer Science and Computational Mathematics.",answers:[]}],links:[],attachments:[],answers:[]}],Blue:[{id:18175,guid:"cdd4b1ba-91a2-5cb1-8385-67d1c82bea77",logo:"",date:"2022-07-27T12:30:00+00:00",start:"12:30",duration:"00:30",room:"Blue",slug:"juliacon-2022-18175-julia-to-the-nec-sx-aurora-tsubasa-vector-engine",url:"https://pretalx.com/juliacon-2022/talk/QMZUZH/",title:"Julia to the NEC SX-Aurora Tsubasa Vector Engine",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"The package VectorEngine.jl enables the use of the SX-Aurora Tsubasa Vector Engine (VE) as an accelerator in hybrid Julia programs. It builds on GPUCompiler.jl leveraging the VEDA API as well as the LLVM-VE compiler and the Region Vectorizer. Even though the VE is very different from GPUs, using only few cores and arithmetic units with very long vector length, the package enables programmers to use it in a very similar way, simplifying the porting of Julia applications.",description:`The talk introduces the VectorEngine.jl [1] package, the first port of the Julia programming language to the NEC SX-Aurora Tsubasa Vector Engine (VE) [2]. It describes the design choices made for enabling the Julia programming languages, architecture specific details, similarities and differences between VEs and GPUs and the currently supported features.\r
\r
The current instances of the VE are equipped with 6 HBM2 modules that deliver 1.55 TB/s memory bandwidth to 8 or 10 cores. Each core consists of a full fledged scalar processing unit (SPU) and a vector processing unit (VPU) running with very long vector lengths of up to 256 x 64 bit or 512 x 32 bit words. With C, C++ and Fortran the VE can run programs natively, completely on the VE, OpenMP and MPI parallelized, with Linux system calls being processed on the host machine. Native VE programs can offload function calls to the host CPU (reverse offloading). Alternatively the VE can be used as an accelerator, with the main program running on the host CPU and performance-critical kernels being offloaded to the VE with the help of libraries like AVEO or VEDA [3]. Prominent users of the SX-Aurora Vector Engines are in weather and climate research (eg. Deutscher Wetterdienst), earth sciences research (JAMSTEC, Earth Simulator), fusion research (National Institute for Fusion Science, Japan).\r
\r
For enabling the VE for Julia use we chose to use the normal offoading programming paradigm that treats the VE as an accelerator running particular code kernels. The GPUCompiler.jl module was slightly expanded and used in VectorEngine.jl to support VEDA on VE, similar to the GPU specific implementations CUDA.jl, AMDGPU.jl and oneAPI.jl. Although VEs are very different from GPUs, chosing a usage pattern similar to GPUs is the most promissing approach for reducing porting efforts and making multi-accelerator Julia code maintainable. With VectorEngine.jl we can declare device-side arrays and structures, copy data between host and device side, declare kernel functions, create cross-compiled objects that can be executed on the accelerator, or use a simple macro like @veda to run a function on the device side and hide steps like compilation and arguments transfer from the user.\r
\r
For cross-compiling VE device code we use the LLVM-VE compiler. It is a slightly extended version of the upstream LLVM compiler that supports VE as an official architecture since late 2021. For vectorization inside the Julia device code we use the Region Vectorizer [4], an advanced outer loop vectorizer capable of handling divergent control flow. The Region Vectorizer does not do data-dependency analysis, therefore loops that need to be vectorized must be annotated by the programmer.\r
\r
At the time of the submission of the talk proposal VE device side Julia supports a very limited runtime, quite similar to that of other GPUs. It includes device arrays, transfer of structures, vectorization using the Region Vectorizer and device-side ccalls to libc functions as well as other VE libraries. We discuss the target of implementing most of the Julia runtime on the device side, a step that would enable a much wider range of codes on the accelerator.\r
\r
\r
[1] VectorEngine.jl github repository: https://github.com/sx-aurora-dev/VectorEngine.jl\r
\r
[2] K. Komatsu et al, Performance evaluation of a vector supercomputer sx-aurora TSUBASA, https://dl.acm.org/doi/10.5555/3291656.3291728\r
\r
[3] VEDA github repository: https://github.com/sx-aurora/veda\r
\r
[4] Simon Moll, Vectorization system for unstructured codes with a Data-parallel Compiler IR, 2021, dissertation https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/32453`,recording_license:"",do_not_record:!1,persons:[{id:18473,code:"DF8WEQ",public_name:"Erich Focht",biography:"Erich has worked on optimizing CFD and structural mechanics algorithms for parallel vector supercomputers, did Linux kernel development and research in distributed systems software and parallel file systems. Currently he leads a research and development group at NEC HPC Europe, his work topics cover system software and compilers for heterogeneous computing with NEC's SX-Aurora Vector Engine, augmenting HPC simulations with AI and integrating cloud technologies into HPC clusters.",answers:[]},{id:903,code:"3C7UBC",public_name:"Valentin Churavy",biography:"asads",answers:[]}],links:[],attachments:[],answers:[]},{id:18014,guid:"2b8ba5fc-b546-5948-8c8b-5092c47ea1ef",logo:"/media/juliacon-2022/submissions/YPGNCS/julia_gpu_course_w4RORIk.png",date:"2022-07-27T13:00:00+00:00",start:"13:00",duration:"00:30",room:"Blue",slug:"juliacon-2022-18014-teaching-gpu-computing-experiences-from-our-master-level-course",url:"https://pretalx.com/juliacon-2022/talk/YPGNCS/",title:"Teaching GPU computing, experiences from our Master-level course",subtitle:"",track:null,type:"Talk",language:"en",abstract:"In the Fall Semester 2021 at ETH Zurich, we designed and taught a new course: **Solving PDEs in parallel on GPUs with Julia**. We present technical and teaching experiences we gained: we look at our tech-stack `CUDA.jl`, `ParallelStencils.jl` and `ImplictGlobalGrid.jl` for GPU-computing; and `Franklin.jl`, `Literate.jl`, `IJulia.jl`/Jupyter for web, slides, and exercises. We look into the crash-course in Julia, teaching software-engineering (git, CI) and project-based student evaluations.",description:"In the Fall Semester 2021 at ETH Zurich, we designed and taught a new Master-level course: [**Solving PDEs in parallel on GPUs with Julia**](https://eth-vaw-glaciology.github.io/course-101-0250-00/).\r\n\r\nWe had prior experience in teaching workshops and individual lectures based on Julia, this was our first end-to-end Julia-based lecture course. It filled a niche at ETH Zurich, Switzerland: namely numerical GPU computing for the domain scientists.\r\n\r\nWhilst we had great prior experience with the GPU tech-stack used (we're developing part of it), we had to learn much on the presentational tech-stack to create a website, slides and assignments. The presentation will focus on both the GPU-stack (`CUDA.jl`, `ParallelStencils.jl` and `ImplictGlobalGrid.jl`) and the presentation-stack (`Literate.jl`, `Franklin.jl`, `IJulia.jl`/Jupyter).\r\n\r\nCo-authors: Mauro Werder\xB9 \xB2 , Samuel Omlin\xB3\r\n\r\n\xB9 Swiss Federal Institute for Forest, Snow and Landscape Research (WSL) | \xB2 ETH Zurich | \xB3 Swiss National Supercomputing Centre (CSCS)",recording_license:"",do_not_record:!1,persons:[{id:4202,code:"ZTATFJ",public_name:"Ludovic R\xE4ss",biography:"Geoscientist with strong interests in Julia, HPC, GPUs, and supercomputing. Applications to resolve multi-physics processes in ice dynamics and geodynamics across scales.",answers:[]},{id:4374,code:"CRJ7BV",public_name:"Mauro Werder",biography:"Glaciologist and Julia programmer",answers:[]},{id:4264,code:"QTKXPY",public_name:"Samuel Omlin",biography:"Computational Scientist and responsible for Julia computing at the Swiss National Supercomputing Centre (CSCS), ETH Zurich",answers:[]}],links:[],attachments:[],answers:[]},{id:18038,guid:"0b84a4b3-4d74-56ac-a198-b33737fa0862",logo:"",date:"2022-07-27T13:30:00+00:00",start:"13:30",duration:"00:10",room:"Blue",slug:"juliacon-2022-18038-oneapi-jl-programming-intel-gpus-and-more-in-julia",url:"https://pretalx.com/juliacon-2022/talk/XKGBAM/",title:"oneAPI.jl: Programming Intel GPUs (and more) in Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"oneAPI.jl is a Julia package that makes it possible to use the oneAPI framework to program accelerators like Intel GPUs. In this talk, I will explain the oneAPI framework, which accelerators it supports, and demonstrate how oneAPI.jl makes it possible to work with these accelerators from the Julia programming language.",description:`oneAPI is a framework, developed by Intel but intended to be cross-platform, that can be used to program various hardware accelerators. This includes Intel GPUs, which exist as integrated solutions in many processors, and dedicated hardware that will be part of the Aurora supercomputer at Argonne National Laboratory.\r
\r
To program these GPUs from Julia, we have created the oneAPI.jl package based on existing GPU infrastructure like GPUCompiler.jl and GPUArrays.jl. It builds on the low-level Level Zero APIs that are part of oneAPI, and relies on Khronos tools to compile Julia code to SPIR-V. With it, Intel GPUs can be programmed using the familiar programming styles supported by other GPU back-ends: high-level array abstractions that automatically exploit the implicit parallelism, and low-level kernels where the programmer is responsible for doing so.`,recording_license:"",do_not_record:!1,persons:[{id:2402,code:"9YQMAK",public_name:"Tim Besard",biography:"Tim Besard is a software engineer at Julia Computing, working on GPU support for the Julia language. He holds a Ph.D. in computer science engineering from Ghent University, Belgium, for research on abstractions to program hardware accelerators in high-level programming languages.",answers:[]}],links:[],attachments:[],answers:[]},{id:18017,guid:"798c30d3-5b0a-53d1-bafb-660ccf1002ca",logo:"/media/juliacon-2022/submissions/7FVVF3/gpu4geo_jc_KtKmFdN.png",date:"2022-07-27T13:40:00+00:00",start:"13:40",duration:"00:10",room:"Blue",slug:"juliacon-2022-18017-gpu4geo-frontier-gpu-multi-physics-solvers-in-julia",url:"https://pretalx.com/juliacon-2022/talk/7FVVF3/",title:"GPU4GEO - Frontier GPU multi-physics solvers in Julia",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"The accelerating outflow of ice in Antarctica or Greenland due to a warming climate or the geodynamic processes shaping the Earth share common computational challenges: extreme-scale high-performance computing (HPC) which requires the next-generation of numerical models, parallel solvers and supercomputers. We here present a fresh approach to modern HPC and share our experience running Julia on thousands of graphical processing units (GPUs).",description:"Computational Earth sciences leverage numerical modelling to understand and predict the evolution of complex multi-physical systems. Ice sheet dynamics and solid Earth geodynamics are, despite their apparent differences, two domains that build upon analogous physical description and share similar computational challenges. Resolving the interactions among various physical processes in three-dimensions on high spatio-temporal resolution is crucial to capture rapid changes in the system leading to the formation of, e.g., ice streams or mountains ranges.\r\n\r\nWithin the [**GPU4GEO**](https://ptsolvers.github.io/GPU4GEO/) project, we propose software tools which provide a way forward in ice dynamics, geodynamics and computational Earth sciences by exploiting two powerful emerging paradigms in HPC: supercomputing with Julia on graphical processing units (GPUs) and massively parallel iterative solvers. We use Julia as the main language because it features high-level and high-performance capabilities and performance portability amongst multiple backends (e.g., multi-core CPUs, and AMD and NVIDIA GPUs). \r\n\r\nWe will discuss our experience using `ParallelStencil.jl` and `ImplicitGlobalGrid.jl` as software building blocks in combination to `CUDA.jl`, `AMDGPU.jl` and `MPI.jl` for designing massively parallel and scalable solvers based on the pseudo-transient relaxation method, namely `FastIce.jl` and `JustRelax.jl`. Our work shows great promise for solving a wide range of mechanical multi-physics problems in geoscience, at scale and on GPU-accelerated supercomputers.\r\n\r\nCo-authors: Ivan Utkin\xB9 \xB2, Albert De Montserrat\xB9, Boris Kaus\xB3, Samuel Omlin\u2074\r\n\r\n\xB9 ETH Zurich | \xB2 Swiss Federal Institute for Forest, Snow and Landscape Research (WSL) | \xB3 Johannes Gutenberg University Mainz | \u2074 Swiss National Supercomputing Centre (CSCS)",recording_license:"",do_not_record:!1,persons:[{id:4202,code:"ZTATFJ",public_name:"Ludovic R\xE4ss",biography:"Geoscientist with strong interests in Julia, HPC, GPUs, and supercomputing. Applications to resolve multi-physics processes in ice dynamics and geodynamics across scales.",answers:[]},{id:18416,code:"FQ7PY3",public_name:"Albert de Montserrat",biography:null,answers:[]},{id:18425,code:"NHMXEV",public_name:"Boris Kaus",biography:"Computational geodynamicist at the University of Mainz, Germany",answers:[]},{id:4264,code:"QTKXPY",public_name:"Samuel Omlin",biography:"Computational Scientist and responsible for Julia computing at the Swiss National Supercomputing Centre (CSCS), ETH Zurich",answers:[]}],links:[],attachments:[],answers:[]},{id:17053,guid:"3fa4b230-06e6-57ee-b8aa-5ac58bc8a9cf",logo:"",date:"2022-07-27T14:30:00+00:00",start:"14:30",duration:"00:10",room:"Blue",slug:"juliacon-2022-17053-using-hawkes-processes-in-julia-finance-and-more-",url:"https://pretalx.com/juliacon-2022/talk/PRYQ8N/",title:"Using Hawkes Processes in Julia: Finance and More!",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"Using HawkesProcesses.jl I'll introduce the theory behind Hawkes process and show how it can be used across many different applications. Hawkes processes in Julia benefit from the speed of the language and composability  of the different libraries, as you can easily extend the Hawkes process using other packages without too much difficulty. Plus, by using Pluto notebooks I can build simple interactions that demonstrate the underlying mechanics of the Hawkes process.",description:"",recording_license:"",do_not_record:!1,persons:[{id:9239,code:"BPSXJZ",public_name:"Dean Markwick",biography:`I've been using Julia user since 2015 and maintain a number of packages from HawkesProcesses.jl to a number of data API wrappers. \r
\r
In my day job I\u2019m currently an electronic trading quant working on both principal and algo execution. I build models, analyse data and construct algorithms to try and get the best prices in the market with the lowest impact.\r
\r
Outside of my day job I enjoy writing about technology and sports on my blog.`,answers:[]}],links:[],attachments:[],answers:[]},{id:18054,guid:"24052005-2d9f-5f6f-b46f-e698cd6ba523",logo:"",date:"2022-07-27T14:40:00+00:00",start:"14:40",duration:"00:10",room:"Blue",slug:"juliacon-2022-18054-dithering-in-julia-with-ditherpunk-jl",url:"https://pretalx.com/juliacon-2022/talk/FXMQPQ/",title:"Dithering in Julia with DitherPunk.jl",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`Dithering algorithms are a group of color quantization techniques that create the illusion of continuous color in images with small color palettes by adding high-frequency noise or patterns. Traditionally used in printing, they are now mostly used for stylistic purposes.\r
\r
DitherPunk.jl implements a wide variety of fast and extensible dithering algorithms. Using its example, I will demonstrate how packages for creative coding can be built on top of the JuliaImages ecosystem.`,description:`In this talk I will present [DitherPunk.jl](https://github.com/JuliaImages/DitherPunk.jl), a Julia package implementing over 30 dithering algorithms: from ordered dithering with Bayer matrices to digital halftoning and error diffusion methods such as Floyd-Steinberg.\r
\r
DitherPunk.jl can be used for binary dithering, channel-wise dithering and for dithering with custom color palettes. \r
Typically, color dithering algorithms are implemented using Euclidean distances in RGB color space. By building on top of packages from the JuliaImages ecosystem such as Colors.jl and ColorVectorSpace.jl, algorithms can be applied in any color space using any color distance metric, allowing for a lot of creative experimentation.\r
\r
Due to its modular design, DitherPunk.jl is highly extensible. This will be demonstrated by creating an ordered dithering algorithm from a signed distance function.`,recording_license:"",do_not_record:!1,persons:[{id:18371,code:"3CFNUV",public_name:"Adrian Hill",biography:"Adrian Hill is a PhD student in the Machine Learning Group at TU Berlin.",answers:[]}],links:[],attachments:[],answers:[]},{id:18026,guid:"db5ab4bb-a902-579e-acde-f84c5aa564e0",logo:"",date:"2022-07-27T14:50:00+00:00",start:"14:50",duration:"00:10",room:"Blue",slug:"juliacon-2022-18026-fdesolver-jl-solving-fractional-differential-equations",url:"https://pretalx.com/juliacon-2022/talk/SV9TS9/",title:"FdeSolver.jl: Solving fractional differential equations",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"FdeSolver Julia\xA0package solves fractional differential equations in the sense of Caputo, suitable for nonlinear and stiff ordinary differential systems. It has been used for describing memory effects in microbial community dynamics and complex systems. With some practical examples, I will present why (and how) developing such a computational package in open source programming is important (and useful).",description:"Differential equations with fractional operators describe many real-world phenomena more accurately than integer order calculus. Fractional calculus has been recognized as a powerful method for understanding the memory and nonlocal correlation of dynamic processes, phenomena, or structures. However, the Julia programming language has missed a package for solving differential equations of fractional order in an accurate, reliable, and efficient way. Hence, we devise the FdeSolver Julia package specifically for solving two general classes of fractional-order problems: fractional differential equations (FDEs) and multi-order systems of FDEs. We implement the explicit and implicit predictor-corrector algorithms with sufficient convergence and accuracy of the solution of the nonlinear systems, including the fast Fourier transform technique that gives us high computation speed and efficient treatment of the persistent memory term. The following document provides some overall information for using the package: https://juliaturkudatascience.github.io/FdeSolver.jl/stable/readme",recording_license:"",do_not_record:!1,persons:[{id:18413,code:"EY3SKS",public_name:"Moein Khalighi",biography:`PhD candidate in Turku Data Science Group, Department of Computing, at University of Turku, Finland.\r
Working on Identification and characterization of memory effects in experimental time-series data.\r
ORCID: 0000-0001-8176-0367\r
Interested in: Ecological Memory, Fractional Calculus, Differential Equations, Dynamic Modelling, Data Analysis.`,answers:[]}],links:[],attachments:[],answers:[]},{id:17964,guid:"f38ce03b-e990-5138-8961-91c6b40805cd",logo:"",date:"2022-07-27T15:00:00+00:00",start:"15:00",duration:"00:10",room:"Blue",slug:"juliacon-2022-17964-comparison-of-julia-r-and-python-for-mixed-effects-models",url:"https://pretalx.com/juliacon-2022/talk/PJNABU/",title:"Comparison of Julia, R, and Python for Mixed Effects Models",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"Mixed effects models are ubiquitous across multiple domains and all of the prominent open-source tools of Julia, Python, and R offer the ability to run Mixed Effects Models. This presentation compares and contrasts on speed of execution and the accuracy of model results on a large real world dataset run on a laptop, typically used by modelers and researchers for every day use (4 cores, 8GB RAM).",description:"",recording_license:"",do_not_record:!1,persons:[{id:18377,code:"VH9WW7",public_name:"Srinivas Kowta",biography:"A data and analytics professional with 20+ years experience in marketing research & analytics, public opinion research, healthcare & pharmaceuticals, epidemiology and bioinformatics. Began my career where SAS, SPSS, and STATA were the primary tools of use and now it is R, Python, and Julia in an applied setting.",answers:[]}],links:[],attachments:[],answers:[]},{id:18002,guid:"1b68cd0f-4711-5fca-a44e-cea05cb1b957",logo:"",date:"2022-07-27T15:10:00+00:00",start:"15:10",duration:"00:30",room:"Blue",slug:"juliacon-2022-18002-automated-pde-solving-in-julia-with-methodoflines-jl",url:"https://pretalx.com/juliacon-2022/talk/8AYKB7/",title:"Automated PDE Solving in Julia with MethodOfLines.jl",subtitle:"",track:null,type:"Talk",language:"en",abstract:"If you want to simulate something, sooner or later you\u2019re going to come across partial differential equations. But solving PDEs is hard, right? It doesn\u2019t have to be! In this talk we'll cut to the chase: how do I copy paste the textbook description of my PDE into Julia symbolic syntax and get a solution? MethodOfLines.jl is the answer, and in this talk we'll show you how to do it!",description:`MethodOfLines.jl is a system for the automated discretization of symbolically defined partial differential equations (PDEs), by the method of lines. By recognizing different linear and nonlinear terms in the specified system, we build a performant semidiscretization by symbolically applying effective finite difference schemes, which we then used to generate optimized Julia code. Consequently, one can solve the system with an appropriate ordinary differential equation (ODE) solver.  \r
\r
In this 30 minute talk, the audience will learn how to use MethodOfLines.jl to discretize and solve an example PDE that represents a physical simulation which arises in research, gaining the knowledge and skills to apply these tools to their own problems. They will also learn about some of the internals of MethodOfLines.jl. This will arm them with the knowledge required to implement improved finite difference schemes, benefiting their own research and others in the community. Finally, we will outline the proposed direction of development for the package moving forwards.`,recording_license:"",do_not_record:!1,persons:[{id:18404,code:"CVFTKF",public_name:"Alex Jones",biography:`From a background in electronic engineering, radar and electromagnetics to working developing PDE tooling in Julia.\r
\r
Languages - English, German`,answers:[]}],links:[],attachments:[],answers:[]},{id:18049,guid:"eedc5e3e-7113-51e4-89fd-d573e88c9439",logo:"",date:"2022-07-27T19:00:00+00:00",start:"19:00",duration:"00:30",room:"Blue",slug:"juliacon-2022-18049-automatic-generation-of-c-julia-bindings",url:"https://pretalx.com/juliacon-2022/talk/EA7NVT/",title:"Automatic generation of C++ -- Julia bindings",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Interporability of Julia with C++ is essential for the use of the Julia programming language in fields with a large legacy of code written in this language. We will show how the generation of a Julia interface to a C++ library can be automatized using CxxWrap.jl and a tool that generates the required C++ glue code. The concept is demonstrated with a prototype called WrapIt!, https://www.github.com/grasph/wrapit, based on clang and which is already well advanced.",description:`Interfacing Julia with C++ libraries can be done with the help of the CxxWrap.jl package. With this package bindings to C++ classes, their methods and to global functions with a clean Julia interface can be easily be implemented. To provide the bindings, a wrapper that defines the C++-Julia mapping must be written. \r
\r
We will show in this talk that this wrappper code can be automatically generated from the C++ library source code. A code generator, called WrapIt! (https://github.com/grasph/wrapit) and which was developped as a proof of concept will  be presented. \r
\r
The clang libraries (https://clang.llvm.org/) was used to interpret the C++ code and in particular its C API, libclang. The tool is already well advanced. We will show the challenges that represents deducing the library interface direcly from the C++ header files, in particular for large libraries with hundreds or thousands of C++ classes, the technical choices made in WrapIt!, the status of this tool, and what would be need to make it a full-fledged wrapper generator.`,recording_license:"",do_not_record:!1,persons:[{id:18429,code:"9RZAWU",public_name:"Philippe Gras",biography:"Philippe Gras is a physicist working at the Institute of Research of the Fundamental Laws of the Universe (Irfu). He is using Julia in the context of his research, to analyze data from High Energy Physics experiments.",answers:[]}],links:[],attachments:[],answers:[]},{id:18034,guid:"1109ac19-09b8-5970-935b-63673f241f43",logo:"",date:"2022-07-27T19:30:00+00:00",start:"19:30",duration:"00:30",room:"Blue",slug:"juliacon-2022-18034-extending-pyjl-to-translate-python-libraries-to-julia",url:"https://pretalx.com/juliacon-2022/talk/3VSJHV/",title:"Extending PyJL to Translate Python Libraries to Julia",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Many new high-level programming languages have emerged in recent years. Julia is one of these languages, that offers the speed of C, the macro capabilities of Lisp, and the user-friendliness of Python. However, its library set is still reduced when compared to languages, such as Python. We propose extending PyJL, an open source transpilation tool, to speedup the conversion of libraries to Julia.",description:`PyJL is part of the Py2Many transpiler, which is a rule-based transpilation tool. PyJL builds upon Py2Many to translate Python source code to Julia. Parsing is performed through Python's _ast_ module, which generates an Abstract Syntax Tree. Then, several intermediate transformations convert the input Python source code into Julia source code.\r
\r
In terms of our results, we managed to translate two commonly used benchmarks:\r
1. The N-Body problem, achieving a speedup of 19.5x when compared to Python, after adding only one type hint\r
2. An implementation of the Binary Trees benchmark to test Garbage Collection, which resulted in 8.6x faster execution time without requiring any user intervention\r
\r
The current major limitations of PyJL are type inference and mapping Python's OO paradigm to Julia. Regarding type inference, PyJL requires type hints in function arguments and return types, and we are currently integrating pytype, a type inference mechanism, to verify the soundness of type hints. Regarding the OO paradigm, PyJL currently maps Julia's classes, including class constructors, and single inheritance to Julia. However, Python's special methods, such as \\_\\_repr\\_\\_ or \\_\\_str\\_\\_ still require proper translation.\r
\r
Although the development of our transpilation tool is still at an early stage, our preliminary results show that the transpiler generates human-readable code that can achieve high performance with few changes to the generated source code.`,recording_license:"",do_not_record:!1,persons:[{id:18418,code:"9H8PN8",public_name:"Miguel Marcelino",biography:`I am a Master Thesis student at Instituto Superior T\xE9cnico and I am currently working on a transpiler to translate Python libraries into Julia. I also have experience in Java, Python, TypeScript, C, a hint of Haskell and, most recently, Julia, which surprised me for how fast and simple programming can be.\r
Besides my programming activities, I am also a fan of photography, sports and writing.`,answers:[]}],links:[],attachments:[],answers:[]},{id:18128,guid:"65ed3388-a0ab-5e01-8919-f1a1b0f86b8c",logo:"",date:"2022-07-27T20:00:00+00:00",start:"20:00",duration:"00:30",room:"Blue",slug:"juliacon-2022-18128-julia-in-vs-code-what-s-new",url:"https://pretalx.com/juliacon-2022/talk/JPYJS8/",title:"Julia in VS Code - What's New",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"We will highlight new features in the Julia VS Code extension that shipped in the last year and give a preview of some new work. The new features from last year that we will highlight are: 1) a new profiler UI, 2) a new table viewer UI, 3) a revamped plot gallery, 4) cloud indexing infrastructure, and 5) integration of JuliaFormatter. We will also present some brand-new features, in particular an entirely new test explorer UI integration.",description:"",recording_license:"",do_not_record:!1,persons:[{id:1038,code:"7JQFVF",public_name:"David Anthoff",biography:"David Anthoff is an environmental economist who studies climate change and environmental policy. His research has appeared in Nature, Science, the American Economic Review, Nature Climate Change, the Journal of the Association of Environmental and Resource Economists and other academic journals. He is an associate professor in the Energy and Resources Group at the University of California, Berkeley.",answers:[]},{id:1227,code:"RCTGVS",public_name:"Sebastian Pfitzner",biography:null,answers:[]}],links:[],attachments:[],answers:[]}],BoF:[{id:18170,guid:"038b0ca2-d184-5e47-8658-51366bd6cf43",logo:"",date:"2022-07-27T12:30:00+00:00",start:"12:30",duration:"01:30",room:"BoF",slug:"juliacon-2022-18170-simulating-neural-physiology-networks-in-julia",url:"https://pretalx.com/juliacon-2022/talk/V7CCYF/",title:"Simulating neural physiology & networks in Julia",subtitle:"",track:"JuliaCon",type:"Birds of Feather",language:"en",abstract:"Could Julia be uniquely well-suited for rapidly developing new approaches to simulate the brain ? What if neuroscientists could use a composable set of tools to craft models of ion channels, compartmentalized neuronal morphology, networks of LIF or conductance-based neurons, reinforcement learning, and everything in-between?",description:`Julia\u2019s software ecosystem certainly lessens the technical burden for computational neuroscientists\u2014it boasts federated development of high-quality packages for solving differential equations, machine learning, automatic differentiation, and symbolic algebra. Deep language support for multithreaded, distributed, and GPU parallelism also makes the case for models that can span multiple scales, both in biological detail and overall network size. \r
\r
Come join us for a community discussion about what a fresh Julian take on modeling the brain might look like. Together we will lay out an initial set of goals for building up a domain-specific ecosystem of packages for computational neuroscience.\r
\r
The discussion will be moderated by Wiktor Phillips, Alessio Quaresima, and Tushar Chauhan.`,recording_license:"",do_not_record:!1,persons:[{id:18500,code:"XHDSBZ",public_name:"Alessio Quaresima",biography:`Ph.D. in Cognitive Computational Neuroscience at the Max Planck Institute for Psycholinguistics.\r
\r
Interested in dendrites, spikes, and sequences.`,answers:[]},{id:21606,code:"Z99LJL",public_name:"Wiktor Phillips",biography:"Postdoc in the Julia Lab at MIT",answers:[]},{id:21616,code:"KHAHJ7",public_name:"Tushar Chauhan",biography:`Tushar Chauhan is a neuroscientist with a keen interest in bio-inspired AI. His work focusses on understanding computations in sensory cortices - both for placing sensory computation in an evolutionary context, as well as drawing inspiration from biological solutions to create highly efficient, robust artificial systems. His methodology is versatile, and an important part of his toolkit includes simulations of neural circuits at various levels of abstraction. \r
\r
He is a Postdoctoral Research Associate at the Bear Lab, Picower Institute of Learning and Memory, MIT.`,answers:[]}],links:[],attachments:[],answers:[]},{id:17698,guid:"65d1808c-44f1-55b5-b02d-9bba6dee0230",logo:"",date:"2022-07-27T14:30:00+00:00",start:"14:30",duration:"01:30",room:"BoF",slug:"juliacon-2022-17698-discussing-gender-diversity-in-the-julia-community",url:"https://pretalx.com/juliacon-2022/talk/YLSWBC/",title:"Discussing Gender Diversity in the Julia Community",subtitle:"",track:null,type:"Birds of Feather",language:"en",abstract:"Julia Gender Inclusive is an initiative that supports gender diversity in the Julia community. Over the last year, we have worked toward doing so through meetups and workshops for community building and education. In this Birds-of-Feather session, we hope to discuss current and future initiatives with other people with underrepresented genders, as well as supportive allies.",description:"The objective of this BoF is to find more people who feel their gender is underrepresented within the Julia community or want to support people who feel so. We aim to create a safe and fruitful discussion about gender diversity, increase awareness of our current initiatives, and receive input on new actions we can take as Julia Gender Inclusive.",recording_license:"",do_not_record:!0,persons:[{id:18159,code:"B38TN3",public_name:"Julia Gender Inclusive",biography:"An initiative to promote gender diversity and inclusion within the wider Julia community. We aim to do this through a combination of community building, targeted outreach, education, mentorship, and mutual support.",answers:[]}],links:[],attachments:[],answers:[]},{id:21381,guid:"e4b630eb-4c87-59f1-a9bf-60fc4d5e99b7",logo:"",date:"2022-07-27T18:00:00+00:00",start:"18:00",duration:"01:30",room:"BoF",slug:"juliacon-2022-21381-poster-session",url:"https://pretalx.com/juliacon-2022/talk/M7JDGG/",title:"Poster session",subtitle:"",track:null,type:"Virtual poster session",language:"en",abstract:"The virtual poster session will take place in the designated area in [Gather.town](http://gather.town/).",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]}],JuMP:[{id:16830,guid:"83f1b688-b69b-5601-937f-bd6c67fabf59",logo:"",date:"2022-07-27T12:30:00+00:00",start:"12:30",duration:"00:10",room:"JuMP",slug:"juliacon-2022-16830-unitjump-automatic-unit-handling-in-jump",url:"https://pretalx.com/juliacon-2022/talk/RDLDYD/",title:"UnitJuMP: Automatic unit handling in JuMP",subtitle:"",track:"JuMP",type:"Lightning talk",language:"en",abstract:"This talk will present the package UnitJuMP that allows the user to include units when modelling optimization problems in JuMP. Both variables and constraints can have specified units, as well as parameters involved in objective and constraints. If different units are combined, functionality in Unitful is used to check for compatibility and perform automatic conversions.",description:`When setting up complex optimization models involving real world problems, this will often involve\r
parameters and variables that represent physical quantitities with specified units. To ensure \r
correctness of the optimization model, considerable care has to be taken to avoid errors due \r
to inconsistent use of units. An example is investment models in the energy sector where \r
multiyear investments measured in GW can be combined with operational decisions on hour or minute basis with parameters being provided in a wide range of units (kWh, MJ, kcal, MMBTU).\r
\r
The package UnitJuMP is an extension to the JuMP package that handles modeling of units within JuMP models. \r
The implementation is based on use of the Unitful package for generic handling of physical units.\r
The package is still in an early stage of development, and currently only supports the use of units in combination with linear and mixed integer linear optimization problems.  \r
The package is available for download and testing at https://github.com/trulsf/UnitJuMP.jl.`,recording_license:"",do_not_record:!1,persons:[{id:17777,code:"ZSV3QP",public_name:"Truls Flatberg",biography:"Truls Flatberg is a researcher at the research institute SINTEF. With a background from applied mathematics and informatics, he develops decision support tools for industrial problems based on optimization models.",answers:[]}],links:[],attachments:[],answers:[]},{id:17198,guid:"c9902316-6a2a-5a9d-8e3c-75d368f7e9f8",logo:"",date:"2022-07-27T12:40:00+00:00",start:"12:40",duration:"00:10",room:"JuMP",slug:"juliacon-2022-17198-sparsevariables-efficient-sparse-modelling-with-jump",url:"https://pretalx.com/juliacon-2022/talk/STM8PM/",title:"SparseVariables - Efficient sparse modelling with JuMP",subtitle:"",track:"JuMP",type:"Lightning talk",language:"en",abstract:`Industry scale optimization problems are often large and sparse, and problem construction time can rival solution time. The default containers and macros in JuMP present some challenges for this class of problems, in particular some performance gotchas.\r
\r
We present SparseVariables.jl for simple sparse modelling, and demonstrate performance and conciseness with a supply chain optimization example, benchmarking both problem construction time and LOC for multiple modelling approaches.`,description:`## Motivation\r
\r
Industry scale optimization problems, e.g. in supply chain management or energy systems modeling often involve constructing and solving very large, very sparse linear programs. For such problems problem construction time can rival solution time when the problem is solved by very efficient commercial linear programming solvers.\r
\r
Julia and JuMP provide an elegant and fun modelling environment which integrates nicely with data management, versioning, reproducibility and portability.\r
\r
The default containers and macros in JuMP do present some challenges for this class of problems, related to performance gotchas and incremental variable construction.\r
\r
## What it is\r
\r
Thanks to the unique hackability of Julia and JuMP, it has been straight-forward to create custom containers and macros to investigate alternative approaches to modelling large sparse systems with JuMP.\r
\r
We present SparseVariables which provides a nice and compact syntax for these problems with good performance by default.\r
\r
## Performance\r
\r
To demonstrate SparseVariables, we present a demo supply chain optimization problem, which may be modelled in multiple ways, and benchmark the problem construction time and the number of lines of code for each approach.\r
\r
## Elegance\r
\r
With SparseVariables we avoid the boiler-plate necessary with suggested work-arounds for performance issues in JuMP, and also allow incremental construction of variables, which is useful for modular modelling code. Our container features slicing and other variable selection methods to allow for short and concise code, leveraging JuMP, MathOptInterface and the Julia package ecosystem.`,recording_license:"",do_not_record:!1,persons:[{id:18046,code:"ASSCEF",public_name:"Lars Hellemo",biography:"Lars Hellemo is a Senior Research Scientist at [SINTEF](https://www.sintef.no/en/), working on optimization and decision support, mainly in the energy and health care sectors.",answers:[]}],links:[],attachments:[],answers:[]},{id:17059,guid:"5011247b-db91-5e57-a164-3a472e6fd96d",logo:"/media/juliacon-2022/submissions/LJC7R8/logo_y512kFg.svg",date:"2022-07-27T12:50:00+00:00",start:"12:50",duration:"00:10",room:"JuMP",slug:"juliacon-2022-17059-jump-toqubo-automatic-reformulation",url:"https://pretalx.com/juliacon-2022/talk/LJC7R8/",title:"JuMP ToQUBO Automatic Reformulation",subtitle:"",track:"JuMP",type:"Lightning talk",language:"en",abstract:`We present ToQUBO.jl, a Julia package to reformulate general optimization problems into QUBO instances. This tool aims to convert JuMP problems for straightforward application in physics and physics-inspired solution methods whose normal form is equivalent to QUBO. It automatically maps between source and target models, providing a smooth JuMP modeling experience.\r
We also present a simple interface to connect various annealers and samplers as QUBO solvers bundled in another package, Anneal.jl.`,description:"",recording_license:"",do_not_record:!1,persons:[{id:17844,code:"FSFWDY",public_name:"Pedro Xavier",biography:`My name is Pedro and I'm from Brasil. I'm a Computer and Information Engineering student at the Federal University of Rio de Janeiro (UFRJ) where I also pursue a Pure Mathematics degree as double major.\r
I'm intersted in many research topics concerning Maths and it's applications, even those which apply to purely theoretical fields. I've been spending most of my time in the University studying Logic, Compilers, Optimization, Computer Graphics, Quantum Computing and Artificial Intelligence.\r
Apart from that, I've been into other adventures such as Public Healthcare management systems at FIOCRUZ (Viva o SUS!) and Generative Design in architecture at FAU-UFRJ.\r
I'm currently building amazing stuff at PSR.`,answers:[]}],links:[],attachments:[],answers:[]},{id:18068,guid:"c6d17349-bb3c-5b75-b84c-1bf4df688708",logo:"",date:"2022-07-27T13:00:00+00:00",start:"13:00",duration:"00:30",room:"JuMP",slug:"juliacon-2022-18068-a-multi-precision-algorithm-for-convex-quadratic-optimization",url:"https://pretalx.com/juliacon-2022/talk/VGSB89/",title:"A multi-precision algorithm for convex quadratic optimization",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"In this talk, we describe a Julia implementation of RipQP, a regularized interior-point method for convex quadratic optimization. RipQP is able to solve problems in several floating-point formats, and can also start in a lower precision as a form of warm-start. The algorithm uses sparse factorizations or Krylov methods from the Julia package Krylov.jl. We present an easy way to use RipQP to solve problems modeled with QuadraticModels.jl and LLSModels.jl.",description:"",recording_license:"",do_not_record:!1,persons:[{id:18438,code:"RT9N7T",public_name:"Geoffroy Leconte",biography:"Phd student at Polytechnique Montr\xE9al supervised by Dominique Orban. I am developing RipQP.jl, a package for solving convex quadratic problems and I also contribute to the organization JuliaSmoothOptimizers.",answers:[]}],links:[],attachments:[],answers:[]},{id:18115,guid:"a3cd4653-afdd-56e2-acd1-5cc586bf0134",logo:"",date:"2022-07-27T13:30:00+00:00",start:"13:30",duration:"00:30",room:"JuMP",slug:"juliacon-2022-18115-interior-point-conic-optimization-with-clarabel-jl",url:"https://pretalx.com/juliacon-2022/talk/UNRVRP/",title:"Interior-point conic optimization with Clarabel.jl",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"The talk will introduce Clarabel.jl, a conic convex optimization solver in pure Julia.   Clarabel.jl uses an interior point technique with a novel homogeneous embedding and can solve LPs, QPs, SOCPs, SDPs or exponential cone programs.   The talk will highlight the solver's performance advantages relative to competing solvers, discuss algorithmic and software design ideas drawn from existing solvers, and highlight extensibility features leveraging Julia's multiple dispatch system.",description:`The talk will introduce Clarabel.jl, a new package for conic convex optimization implemented in pure Julia.   The package is based on an interior point optimization method and can solve optimization problems in the form of linear and quadratic programs (LPs and QPs), second-order cone programs (SOCPs), semidefinite programs (SDPs) and constraints on the exponential cone.\r
\r
The package implements a novel homogeneous embedding technique that offers substantially faster solve times relative to existing open-source and commercial solvers for some problem types.   This improvement is due to both a reduction in the number of required interior point iterations as well as an improvement in both the size and sparsity of the linear system that must be solved at each iteration.   The talk will describe details of this embedding and show performance results with respect to solvers based on the standard homogeneous self-dual embedding, including ECOS, Hypatia and MOSEK.\r
\r
Our implementation of Clarabel.jl adopts design ideas from several existing solver packages.   Based on our group\u2019s prior experience implementing first-order optimization techniques in the ADMM-based solver COSMO.jl, Clarabel.jl adopts a modular implementation for convex cones that is easily extensible to new types.  The solver organises its core internal data types following the design of the C++ QP solver OOQP, allowing for future extensions of the solver to exploit optimization problems with special internal structure, e.g. optimal control or support vector machine problems.    Finally, the package works with generic types throughout, allowing for simple extension to abstract matrix or vector representations or use with arbitrary precision floating point types.   The talk will describe these features and their implementation through Julia\u2019s multiple dispatch system.\r
\r
Clarabel.jl provides a simple native interface for solving cone programs in a standard format.   The package also fully supports Julia's MathOptInterface package, and can therefore be used via both JuMP and Convex.jl.  \r
\r
The package will be available as an open-source package via Github under the Apache 2.0 license.  An initial public release is planned for June 2022, but full documentation and examples are already available at:\r
\r
	https://oxfordcontrol.github.io/Clarabel.jl/`,recording_license:"",do_not_record:!1,persons:[{id:18468,code:"HYYXU7",public_name:"Paul Goulart",biography:`Paul Goulart joined the University of Oxford in 2014 as an Associate Professor in Engineering Science and a Tutorial Fellow in Engineering Science. He received his SB and MSc degrees in Aeronautics and Astronautics from the Massachusetts Institute of Technology (MIT). Following his undergraduate studies he was a software developer in the flight operations centre for the Chandra X-Ray Observatory at the Harvard-Smithsonian Centre for Astrophysics, and later an engineer in the Autonomous Systems research group at the Charles Stark Draper Laboratory.\r
\r
In 2003 he was selected as a Gates Scholar at the University of Cambridge, where he received a PhD in Control Engineering in 2007. From 2007 to 2011 he was a Lecturer in control systems in the Department of Aeronautics at Imperial College London, and from 2011 to 2014 a Senior Researcher in the Automatic Control Laboratory at ETH Zurich. He is currently a member of the Control Group in the department of Engineering Science.\r
\r
His research interests are in high speed optimisation and control for embedded systems, data-driven and robust optimisation, and machine learning.`,answers:[]}],links:[],attachments:[],answers:[]},{id:17940,guid:"c47ec789-2f67-595d-8fd3-f45bb7b76d8a",logo:"",date:"2022-07-27T14:30:00+00:00",start:"14:30",duration:"00:30",room:"JuMP",slug:"juliacon-2022-17940-jump-1-0-what-you-need-to-know",url:"https://pretalx.com/juliacon-2022/talk/KCL3JM/",title:"JuMP 1.0: What you need to know",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"JuMP 1.0 was released in March 2022. I'll present the state of JuMP today, how we got here, what the JuMP community should know about the 1.0 release, and what's next on the roadmap.",description:"",recording_license:"",do_not_record:!1,persons:[{id:18350,code:"LHAQVA",public_name:"Miles Lubin",biography:"Miles Lubin is the benevolent dictator for life (BDFL) of JuMP.",answers:[]}],links:[],attachments:[],answers:[]},{id:18010,guid:"5abe3772-ee74-53ce-b637-d6c4c050351b",logo:"",date:"2022-07-27T15:00:00+00:00",start:"15:00",duration:"00:30",room:"JuMP",slug:"juliacon-2022-18010-a-user-s-perspective-on-using-jump-in-an-academic-project",url:"https://pretalx.com/juliacon-2022/talk/CFGAUV/",title:"A user\u2019s perspective on using JuMP in an academic project",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"The Risk-Aware Market Clearing (RAMC) project investigates the quantification and management of risk in power systems, thereby bridging machine learning, optimization and risk analysis. This talk will discuss the team's experience --from a user perspective-- on using Julia and JuMP within an academic project and a multi-disciplinary team. This will include the motivation for using these tools, as well as hurdles encountered along the way, and practical experience on industrial-size systems.",description:"",recording_license:"",do_not_record:!1,persons:[{id:18405,code:"9PVKLD",public_name:"Mathieu Tanneau",biography:"Mathieu is currently a Post-doctoral fellow at Georgia Tech, where he is part of the Risk-Aware Market Clearing (RAMC) project (https://ramc.isye.gatech.edu/). His interests are in mixed-integer linear and nonlinear optimization, and their applications to Power Systems.",answers:[]}],links:[],attachments:[],answers:[]},{id:18677,guid:"1715e69c-af5a-5f6e-ad9b-295b404cfba9",logo:"",date:"2022-07-27T15:30:00+00:00",start:"15:30",duration:"00:10",room:"JuMP",slug:"juliacon-2022-18677-copt-and-its-julia-interface",url:"https://pretalx.com/juliacon-2022/talk/XRDNVT/",title:"COPT and its Julia interface",subtitle:"",track:"JuMP",type:"Lightning talk",language:"en",abstract:"COPT (Cardinal Optimizer) is a mathematical optimization solver for large-scale optimization problems. It includes high-performance solvers for LP, MIP, SOCP, convex QP, convex QCP and other mathematical programming problems. In this talk we will give an overview of COPT and introduce its Julia interface.",description:"",recording_license:"",do_not_record:!1,persons:[{id:18925,code:"ZF7V93",public_name:"Qi Huangfu",biography:"Qi Huangfu is the developer of COPT and has worked on many different optimization solvers, including HiGHS and FICO-Xpress.",answers:[]}],links:[],attachments:[],answers:[]},{id:18645,guid:"e69b8c9b-97e7-5287-8c9c-6784a2695566",logo:"/media/juliacon-2022/submissions/ZPUZPU/HiGHS_Icon_square_KbMxUw9.jpg",date:"2022-07-27T15:40:00+00:00",start:"15:40",duration:"00:10",room:"JuMP",slug:"juliacon-2022-18645-jump-and-highs-the-best-open-source-linear-optimization-solvers",url:"https://pretalx.com/juliacon-2022/talk/ZPUZPU/",title:"JuMP and HiGHS: the best open-source linear optimization solvers",subtitle:"",track:"JuMP",type:"Lightning talk",language:"en",abstract:"This talk will describe how the JuMP and HiGHS teams have worked together to deliver the best open-source linear optimization solvers to the Julia community, and present some high-profile use cases.",description:`Almost from the moment that the development of HiGHS was proposed in 2018, the prospect of it offering top-class open-source linear optimization solvers with a well designed and fully supported API was attractive to JuMP. Since then, as HiGHS has developed from outstanding "gradware" to the world's best open-source linear optimization software, there have been invaluable contributions from the JuMP team. This great example of community cooperation now means that HiGHS is the default MILP solver in JuMP's documentation, and Julia users have a slick interface to HiGHS. One particular area of activity that is exploiting this is the rapidly-growing world of open-source energy systems planning, where the high license fees for commercial optimization solvers mean that open-source alternatives are critically important for small scale commercial enterprises, NGOs, and organisations in developing countries. Some high-profile use cases of the JuMP-HiGHS interface in this field will be presented.`,recording_license:"",do_not_record:!1,persons:[{id:18905,code:"SFV3PJ",public_name:"Julian Hall",biography:"I have been developing software for linear optimization since my time as a PhD student with Roger Fletcher in the late 1980's. A lecturer at the University of Edinburgh since 1990, my research has focused on serial and parallel computing techniques for implementing the simplex algorithm for linear programming. This has resulted in the development of HiGHS, the world's best open-source software for linear optimization.",answers:[]}],links:[],attachments:[],answers:[]},{id:17013,guid:"b16afdd2-95f1-598e-a50b-cff1b0cd4694",logo:"",date:"2022-07-27T19:00:00+00:00",start:"19:00",duration:"00:30",room:"JuMP",slug:"juliacon-2022-17013-pajarito-s-mathoptinterface-makeover",url:"https://pretalx.com/juliacon-2022/talk/Y8BCSL/",title:"Pajarito's MathOptInterface Makeover",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"Pajarito is an outer approximation solver for mixed integer conic problems. We have redesigned and rewritten Pajarito in version 0.8 to support MathOptInterface (finally!). Pajarito now has a generic cone interface that allows adding support for new convex cones through a small list of oracles. PajaritoExtras.jl extends Pajarito by defining several cones supported by the continuous conic solver Hypatia. We illustrate with applied examples, including mixed integer polynomial problems.",description:"",recording_license:"",do_not_record:!1,persons:[{id:11321,code:"ZBXW73",public_name:"Chris Coey",biography:"MIT PhD student graduating May 2022, starting postdoc at MIT Sloan.",answers:[]}],links:[],attachments:[],answers:[]},{id:17935,guid:"48781328-f1df-50b8-90bf-68237b6b35dd",logo:"",date:"2022-07-27T19:30:00+00:00",start:"19:30",duration:"00:30",room:"JuMP",slug:"juliacon-2022-17935-a-matrix-free-fix-propagate-and-project-heuristic-for-milps",url:"https://pretalx.com/juliacon-2022/talk/JLYCL8/",title:"A matrix-free fix-propagate-and-project heuristic for MILPs",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"We present Scylla, a primal heuristic for mixed-integer optimization. It uses matrix-free approximate LP solving with specialized termination criteria and parallelized fix-and-propagate procedures blended with feasibility pump-like objective updates. Besides the presentation of the method and results, we will go over lessons learned on experimentation and implementation tricks including overhead reduction, asynchronous programming, and interfacing with natively-compiled libraries.",description:"The talk will present our work on Scylla in two aspects. The first will be the presentation of the method and different components and ideas they link to, from feasibility pump to primal-dual hybrid gradients for linear optimization and fix-and-propagate procedures. The second aspect of the talk will include lessons learned on asynchronous programming using the Task-Channel model, working with and interfacing native libraries or time management for time-constrained experimental runs.",recording_license:"",do_not_record:!1,persons:[{id:1216,code:"DK9KDB",public_name:"Mathieu Besan\xE7on",biography:`Mathieu Besan\xE7on is a researcher at the Zuse Institute Berlin, in the AI in Society, Science, and Technology department, associated with the MODAL-SynLab project and a member of the MATH+ Berlin Mathematics Research Center.\r
\r
His research interests span solution methods and software in MI(N)LP and convex optimization and in particular the SCIP framework and Frank-Wolfe related approaches.`,answers:[]}],links:[],attachments:[],answers:[]},{id:18769,guid:"e664d501-a5ea-5d18-84d7-9da659898c3e",logo:"/media/juliacon-2022/submissions/TSN8ZR/juliacon_talk_image_uVpYXvH.png",date:"2022-07-27T20:00:00+00:00",start:"20:00",duration:"00:10",room:"JuMP",slug:"juliacon-2022-18769-verifying-inverse-model-neural-networks-using-jump",url:"https://pretalx.com/juliacon-2022/talk/TSN8ZR/",title:"Verifying Inverse Model Neural Networks Using JuMP",subtitle:"",track:"JuMP",type:"Lightning talk",language:"en",abstract:"Deep learning using neural networks is increasingly popular, but neural networks come with few built-in guarantees of correctness. This talk will discuss how I use JuMP to compute verified upper bounds on the error of a neural network trained as an inverse model. Using JuMP together with Distributed.jl allows me to run a large number of verification queries in parallel with minimal time spent on non-research development.",description:"The talk is based on https://arxiv.org/abs/2202.02429",recording_license:"",do_not_record:!1,persons:[{id:19011,code:"M9YY8S",public_name:"Chelsea Sidrane",biography:null,answers:[]}],links:[],attachments:[],answers:[]},{id:18244,guid:"3d5f5b4e-75ba-5320-854a-b0541f5d3d33",logo:"",date:"2022-07-27T20:10:00+00:00",start:"20:10",duration:"00:10",room:"JuMP",slug:"juliacon-2022-18244-complex-number-support-in-jump",url:"https://pretalx.com/juliacon-2022/talk/LSUKYX/",title:"Complex number support in JuMP",subtitle:"",track:"JuMP",type:"Lightning talk",language:"en",abstract:"Complex numbers appear in a variety of optimization problems such as AC optimal power flow problems (AC-OPF) and quantum information optimization. This talk presents the integration of complex numbers in JuMP. We first describe how to create complex variables and constraints with complex coefficients in JuMP. Then, we show how this addition makes use of the extensible design of MathOptInterface and JuMP. We illustrate this with examples from PowerModels.jl and SumOfSquares.jl.",description:"",recording_license:"",do_not_record:!1,persons:[{id:10452,code:"MLJG3F",public_name:"Beno\xEEt Legat",biography:"Beno\xEEt Legat is a postdoc at MIT with Prof. Pablo Parrilo in the Laboratory for Information and Decision Systems (LIDS).",answers:[]}],links:[],attachments:[],answers:[]}],"Sponsored forums":[{id:21246,guid:"c0783ef7-9e0d-5ab0-8021-8b5d4d22025a",logo:"",date:"2022-07-27T19:30:00+00:00",start:"19:30",duration:"00:45",room:"Sponsored forums",slug:"juliacon-2022-21246-julia-computing-sponsored-forum",url:"https://pretalx.com/juliacon-2022/talk/YGFHB7/",title:"Julia Computing Sponsored Forum",subtitle:"",track:null,type:"Sponsor forum",language:"en",abstract:"TODO",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]}]}},{index:10,date:"2022-07-28",day_start:"2022-07-28T04:00:00+00:00",day_end:"2022-07-29T03:59:00+00:00",rooms:{Green:[{id:20652,guid:"d9328a14-664d-5296-b663-c5b29b243312",logo:"",date:"2022-07-28T09:00:00+00:00",start:"09:00",duration:"00:45",room:"Green",slug:"juliacon-2022-20652-keynote-jeremy-howard",url:"https://pretalx.com/juliacon-2022/talk/78XMRJ/",title:"Keynote - Jeremy Howard",subtitle:"",track:"JuliaCon",type:"Keynote",language:"en",abstract:"Keynote - Jeremy Howard",description:"Keynote - Jeremy Howard",recording_license:"",do_not_record:!1,persons:[{id:20833,code:"WDGYZC",public_name:"Jeremy Howard",biography:"Jeremy Howard is a data scientist, researcher, developer, educator, and entrepreneur. Jeremy is a founding researcher at fast.ai, a research institute dedicated to making deep learning more accessible, and is an honorary professor at the University of Queensland. Previously, Jeremy was a Distinguished Research Scientist at the University of San Francisco, where he was the founding chair of the Wicklow Artificial Intelligence in Medical Research Initiative, the founding CEO of Enlitic, President and Chief Scientist of Kaggle, and CEO of FastMail as well as Optimal Decisions Group.",answers:[]}],links:[],attachments:[],answers:[]},{id:17950,guid:"7b0418a0-1585-5efa-8742-d97ed6ed3553",logo:"",date:"2022-07-28T10:30:00+00:00",start:"10:30",duration:"00:10",room:"Green",slug:"juliacon-2022-17950-quiqbox-jl-basis-set-generator-for-electronic-structure-problem",url:"https://pretalx.com/juliacon-2022/talk/SZSESM/",title:"Quiqbox.jl: Basis set generator for electronic structure problem",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Quiqbox.jl is a Julia package that allows highly customizable Gaussian-type basis set design for electronic structure problems in quantum chemistry and quantum physics. The package provides a variety of useful functions around basis set generation such as RHF and UHF methods, standalone 1-electron and 2-electron integrals, and most importantly, variational optimization for basis set parameters. It supports Linux, Mac OS, and Windows.",description:'Quantum and classical computers are being applied to solve ab initio problems in physics and chemistry. In the NISQ era, solving the "electronic structure problem" has become one of the major benchmarks for identifying the boundary between classical and quantum computational power. Electronic structure in condensed matter physics is often defined on a lattice grid while electronic structure methods in quantum chemistry rely on atom-centered single-particle basis functions. Grid-based methods require a large number of single-particle basis functions to obtain sufficient resolution when expanding the N-body wave function. Typically, fewer atomic orbitals are needed than grid points but the convergence to the continuum limit is less systematic. To investigate the consequences and compromises of the single-particle basis set selection on electronic structure methods, we need more flexibility than is offered in standard solid-state and molecular electronic structure packages. Thus, we have developed an open-source software tool called "Quiqbox" in the Julia programming language that allows for easy construction of highly customized floating basis sets. This package allows for versatile configurations of single-particle basis functions as well as variational optimization based on automatic differentiation of basis set parameters.',recording_license:"",do_not_record:!1,persons:[{id:18364,code:"SACWSR",public_name:"Weishi Wang",biography:"Weishi Wang is a Ph.D. student studying quantum chemistry and quantum physics at the department of physics and astronomy at Dartmouth College. His current research interests are classical and quantum computing applications for electronic structure problems.",answers:[]}],links:[],attachments:[],answers:[]},{id:16672,guid:"81fb1949-8351-517d-b885-727cf518fd69",logo:"/media/juliacon-2022/submissions/KPXD3Y/ReinML_DWUFhzm.png",date:"2022-07-28T10:40:00+00:00",start:"10:40",duration:"00:10",room:"Green",slug:"juliacon-2022-16672-mathlink-extras-the-powers-of-mathematica-and-julia-combined",url:"https://pretalx.com/juliacon-2022/talk/KPXD3Y/",title:"MathLink(Extras): The powers of Mathematica and Julia combined",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`Mathematica is a powerful tool for many purposes, but it can be cumbersome to work with. This is especially clear for more automated tasks.\r
In this short talk, I will introduce MathLink and MathLinkExtras, which enable interoperability between Julia and Mathematica.\r
I will introduce the basic syntax of MathLink and discuss an application of automated computation of nested integrals.`,description:`Mathematica is arguably the go-to tool for your everyday mathematical needs. It can efficiently perform integrals, solve equations, find roots, refine expression, plot functions, and many more things.\r
However, there are tasks where Mathematica performs poorly or is just plain inconvenient to work with.\r
One such place is if/else statements and the control flow.\r
Try, for instance, to construct programs where the algebraic manipulations depend on the functional form of the expression.\r
Or if you want to make non-trivial variable changes inside and expression.\r
\r
These limitations and many more are solved by Julia's MathLink (https://github.com/JuliaInterop/MathLink.jl)  and MathLinkExtras (https://github.com/fremling/MathLinkExtras.jl) packages.\r
The first package provides access to Mathematica/Wolfram Engine, via the Wolfram Symbolic Transfer Protocol (WSTP).\r
\r
The second is "sugar on top" and provides the basic algebraic operations (+,-,*,/) for the MathLink variable types.\r
\r
\r
As a practical example, I will show how MathLink and MathLinkExtras were used in a research project[1] to compute nested gaussian integrals.\r
\r
\r
[1] M. Fremling, "Exact gap-ratio results for mixed Wigner surmises of up to 4 eigenvalues", arXiv preprint arXiv:2202.01090 (2022). (https://arxiv.org/abs/2202.01090)`,recording_license:"",do_not_record:!1,persons:[{id:17592,code:"SLYRRC",public_name:"Mikael Fremling",biography:`My name is Mikael Fremling, and I am working as a postdoc in physics at Utrecht University, The Netherlands.\r
I study the fascinating properties that develop when a material is prevented from exploring the whole three-dimensional world around us.\r
\r
In my research, I routinely perform various types of numerical simulations. For a few years, the Julia language has been my go-to choice for numerics.`,answers:[]}],links:[],attachments:[],answers:[]},{id:16388,guid:"fafd9f0f-752c-505c-a1b5-9aa258324e7d",logo:"",date:"2022-07-28T10:50:00+00:00",start:"10:50",duration:"00:10",room:"Green",slug:"juliacon-2022-16388-dates-with-nanoseconds",url:"https://pretalx.com/juliacon-2022/talk/Y8G9VJ/",title:"Dates with Nanoseconds",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"Julia's DateTime type is limited to milliseconds, while the Time type supports nanoseconds.  This talk introduces NanoDate.jl and NanoDates.  This type works like DateTime with higher precision.  CompoundPeriods behave more smoothly and are available as an operational design element for developers.",description:"",recording_license:"",do_not_record:!1,persons:[{id:914,code:"UN78GE",public_name:"Jeffrey Sarnoff",biography:"Julia Innovator, author of DoubleFloats.jl, NamedTupleTools.jl, SaferIntegers.jl, RollingFunctions.jl, and others.",answers:[]}],links:[],attachments:[],answers:[]},{id:18089,guid:"bd8a493e-7796-5c95-aee9-c684aa47d3a8",logo:"",date:"2022-07-28T11:00:00+00:00",start:"11:00",duration:"00:30",room:"Green",slug:"juliacon-2022-18089-exploring-audio-circuits-with-modelingtoolkit-jl",url:"https://pretalx.com/juliacon-2022/talk/9EM3P7/",title:"Exploring audio circuits with ModelingToolkit.jl",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"The study of audio circuits is interdisciplinary. It combines DSP, analog circuits, differential equations, and semiconductor theory. Mathematical tools like Fourier Transforms and standard circuit analysis cannot explain the behavior of stateful nonlinearities. A complete description of a circuit can only be obtained through time-domain (or \u2018transient\u2019, in SPICE terms) simulation. ModelingToolkit.jl enables rapid design iteration and combines features that traditionally require multiple tools.",description:`This talk is targeted at people who want to start using ModelingToolkit.jl for simulations in their domain. It shows a workflow that is possible today. Additionally, it hints that composability is the key to unlock future breakthroughs. As a bonus, we can implement recent audio processing papers in a few lines of code!\r
\r
We begin with a survey of the numerical and symbolic software commonly employed in the field and explain our decision to use ModelingToolkit.jl. Typically, engineers working with audio systems face a 3-language problem: use SPICE-style software to analyze a circuit, then move on to Matlab/Scilab/Python to deliver a high-level prototype, and finally re-write that into a high-performance implementation in C/C++. Usually, the simplification of a circuit turns into a laborious, multi-week manual process. ModelingToolkit.jl covers these use cases and more.\r
\r
Afterwards, we will explore increasingly complex audio circuits via simulation. Topics include:\r
- implementing Kirchhoff laws\r
- defining simple models (capacitor, diode)\r
- defining a circuit\r
- simulating the circuit and plotting the result\r
- defining hierarchical models (VCCS, vacuum tube)\r
- animated plotting\r
- defining controls (potentiometers)\r
- exploring variations on a venerable guitar pedal\r
\r
Lastly, audio demos of the simulated circuits will be featured.\r
\r
Assumed background:\r
Attendees are expected to have some programming experience in e.g. Python. It is helpful, although not required, to have experience working with analog circuits and/or SPICE simulation software.`,recording_license:"",do_not_record:!1,persons:[{id:18451,code:"N7LMCY",public_name:"George Gkountouras",biography:"George Gkountouras (MSc ECE) is the founder of Arthurian Audio, an AI startup operating in the audio  software industry. Additionally, he has invented and published a quantum sequencer for modular environments. During his academic career, George regularly taught DSP to undergraduate students. He's worked on compilers, circuit simulators and audio plug-ins. He is also interested in embedded systems.",answers:[]}],links:[],attachments:[],answers:[]},{id:18084,guid:"a2f7028a-b45d-5968-84ee-97f7944e9a5a",logo:"",date:"2022-07-28T11:30:00+00:00",start:"11:30",duration:"00:10",room:"Green",slug:"juliacon-2022-18084-universal-differential-equation-models-with-wrong-assumptions",url:"https://pretalx.com/juliacon-2022/talk/AYAUPK/",title:"Universal Differential Equation models with wrong assumptions",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"The JuliaML ecosystem introduces an effective way to model natural phenomena with Universal Differential Equations. UDEs enrich differential equations combining an explicitly known term with a term learned from data via a Neural Network. Here, we explore what happens when our assumptions about the known term are wrong, making use of the rich interoperability of Julia. The insight we offer will be useful to the Julia community in better understanding strengths and possible shortcomings of UDEs.",description:"### Introduction\r\nJulia\u2019s SciML ecosystem introduced an effective way to model natural phenomena as dynamical systems with Universal Differential Equations (UDE\u2019s). The UDE framework enriches both classic and Neural Network differential equation modelling, combining an explicitly \u201Cknown\u201D term (that is, a term which functional expression is known) with an \u201Cunknown\u201D term (that is, a term which functional expression is not known). Within a UDE, the unknown term, and therefore the overall functional form of the dynamical system, is learned from observational data by fitting a Neural Network. The task of the Neural Network is facilitated by the domain knowledge embodied by the known term; moreover, the interpolation and, importantly, extrapolation performance of the fitted model is greatly increased by that knowledge (and by a simplification step, such as SiNDY). All of this relies on the tacit assumption that what we think about the natural phenomena is correctly expressed in the known term. Most of the research has focused on the robust identification of the unknown term, and the properties of the Neural Network. We focus instead on the impact of possible pathologies in the design of a UDE system, and in particular, on possible errors we introduce in the expression of the known term. That is, we ask what happens if our domain knowledge is not correctly expressed. In the context of the famous quote \u201CIt ain\u2019t what you don\u2019t know that gets you in trouble. It\u2019s what you know for sure that just ain\u2019t so\u201D attributed to Mark Twain, we explore the magnitude of the trouble you get into.\r\n### Details\r\nMore in detail, for a set of variables X, we consider a dynamical system of the form\r\n`dX(t)=F(X,t)=K(t)+U(X,t)`\r\nwhere `K(t)` is the part of the dynamical equation assumed as \u201Cknown\u201D, and `U(X,t)` is the part assumed as \u201Cunknown\u201D.\r\nIn this scenario, the observational data are samples from `X(t)` at various points in time.\r\nLet `K*(X,t)` be a perturbed version of K (say, for a certain `\u03C9`, `K*(t)=sin(t+\u03C9)` when `K(t)=sin(t)`).\r\nOur aim is to recover `F(X,t)` from the observed data by training a UDE of the form\r\n`dX(t)=K*(t)+NN(X,t)`.\r\n\r\nUnder the perturbed scenario, we ask some simple questions, which answers are far from trivial:\r\n- Can we recover the functional form of `F(X,t)`?\r\n- Can we at least approximate it accurately?\r\n- How does the perturbation we imposed on `K*(t)` impact our model accuracy?\r\n\r\nIn order to explore the discrepancy between expected and obtained results, we needed: synthetic data from the original dynamical system, that is a family of function for `K(t)`; a family of perturbed versions of the `K(t)` ; and a way to assess how far off we are from recovering the true `F(X,t)`. All three tasks were facilitated by the interoperability of Julia, and in the presentation we will show how that plays out.\r\n\r\n1. We considered trigonometric, exponential, polynomial functions, as well as linear combinations of these functions to create the original dynamical system and generate synthetic observational data. This was made efficiently by the symbolic computation capabilities of Julia, e.g., Symbolics.jl.\r\n2. We fitted family of UDEs to the data we generated under three scenarios: (a) a correctly specified known term, i.e., `K*(t)=K(t)`; (b) the lack of a known term, i.e., `K*(t)=0`; and (c) a perturbation of the known term. The UDE was subsequently simplified to recover a sparse representation of the dynamical system in terms of simple functions. This step was done within Julia\u2019s SciML framework.\r\n3. Finally, we evaluated the goodness of fit between the recovered dynamical system (simplified and not) with the original dynamical system. For this we developed a package, FunctionalDistances.jl, to automate as much as possible the estimation of the distance between two functions. (The package will be very shortly available in a github repository)\r\n\r\n### Future Development\r\nThe preliminary results we obtained suggest that no UDE with a strongly perturbed known term provided a better model than their counterparts with correctly specified terms. Yet, a few perturbed models give better fits than unspecified ones, raising the question of whether errors in the UDE specification are indeed detectable.\r\n\r\nOur talk will interest both people who study UDEs for our cautionary and surprising results, and the wider audience interested more in the use of Julia in mathematical modelling for the encouraging examples of interoperability we present.\r\nThe talk will present how Julia helped us in this experimental mathematical exercise, and offer many opportunities for further investigations.\r\n\r\nThe presentation will be as light as possible on the mathematical side, present ample examples of how the interoperability of Julia helped our analysis, and assumes little or no prior knowledge of UDE\u2019s. Graphs and examples will also be used to aid understanding of the topic.",recording_license:"",do_not_record:!1,persons:[{id:16724,code:"ZEM3A7",public_name:"Luca Reale",biography:"Currently a student in mathematics at the University of Canterbury in Christchurch New Zealand",answers:[]}],links:[],attachments:[],answers:[]},{id:17633,guid:"042dc3a6-c4d8-56b3-90d3-efed83ec8e9a",logo:"",date:"2022-07-28T11:40:00+00:00",start:"11:40",duration:"00:10",room:"Green",slug:"juliacon-2022-17633-using-sciml-to-predict-the-time-evolution-of-a-complex-network-",url:"https://pretalx.com/juliacon-2022/talk/BEY33E/",title:"Using SciML to predict the time evolution of a complex network.",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"Modeling the temporal evolution of complex networks is still an open challenge across many fields. Using the SciML ecosystem in Julia, we train and simplify a Neural ODE on the low-dimensional embeddings of a temporal sequence of networks. In this way, we discover a dynamical system representation of the network that allows us to predict its temporal evolution. In the talk we\u2019ll show how the tight integration of SciML, Network, and Matrix Algebra packages in Julia opens new modeling directions.",description:`**Introduction**\r
\r
Complex networks can change over time as vertices and edges between vertices get added or removed. Modeling the temporal evolution of networks and predicting their structure is an open challenge across a wide variety of disciplines: from the study of ecological networks as food-webs, to predictions about the structure of economical networks; from the analysis of social networks, to the modeling of how our brain develops and adapts during our lives.\r
In their usual representation, networks are binary (an edge is either observed or not), sparse (each vertex is linked to a very small subset of the network), and large (up to billions of nodes), and changes are discrete rewiring events. These properties make them hard to handle with classic machine learning techniques and have barred the use of more traditional mathematical modeling such as differential equations. In this talk, we show how we used Julia, and in particular the Scientific Machine learning (SciML) framework, to model the temporal evolution of complex networks as continuous, multivariate, dynamical systems from observational data. We took an approach cutting across different mathematical disciplines (machine learning, differential equations, and graph theory): this was possible largely thanks to the integration of packages like Graph.jl (and the integrated MetaGraph.jl package), LinearAlgebra.jl (and other matrix decomposition packages), and the SciML ecosystem, e.g., DiffEqFlux.jl.\r
\r
**Methodology**\r
\r
1. To translate the discrete, high-dimensional, dynamical system into a continuous, low-dimensional one, we rely on a network embedding technique. A network embedding maps the vertices of a network to points in a (low-dimensional) metric space. We adopt the well-studied Random Dot-Product Graphs statistical model: the mapping is provided by a truncated Singular Value Decomposition of the network\u2019s adjacency matrix; to reconstruct the network we use the fact that the probability of interaction between two vertices is given by the dot product of the points they map to. The decomposition of the adjacency matrices and their alignment is a computationally intensive  step, and we tackle it thanks to the fast matrix algorithms available for Julia and their integration with packages that allow for network data wrangling (like Graphs.jl).\r
2. In the embedding framework, a discrete change in the network is modeled as the effect of a continuous displacement of the points in the metric space. Our goal then, is that of discovering from the data (the network observed at various points in time) an adequate dynamical system capturing the laws governing the temporal evolution of the complex network. This is possible thanks to a pipeline that combines Neural ODEs and the identification of nonlinear dynamical systems (such as SiNDY).\r
\r
In general, each node may influence the temporal evolution of every over node in the network, and, if we are working in a space with dimension d, and N nodes, this translates to a dynamical system with N*N*d variables. As networks may often have thousands or millions of nodes, that number can be huge. In our talk we are going to discuss various strategies we adopted to tame the complexity of the dynamical system.\r
\r
\r
**Future Development**\r
\r
As a proof of concept, we tested our modeling approach on a network of wild birds interacting over the span of 6 days, collected by the team behind the Animal Social Network Repository (ASNR). The network has 202 vertices (birds), and 11899 edges (contact between birds). In the talk we will showcase this application to show strengths and current limitations of our novel approach.\r
\r
We are now working on three fronts:\r
- we need to scale up the framework, so to model very large networks (for example to model social networks, where being able to predict what people might link with others in the future could be a tool to fight the growing problem of misinformation and disinformation);\r
- we are considering  stepping from Neural Differential Equations to Universal Differential Equations, both to capture any preexisting knowledge of the network dynamical system, and to help with the training complexity;\r
- we are exploring data augmentation techniques to interpolate between the estimated embeddings, other embeddings, and other neural network architectures.\r
\r
These three development directions constitute interesting challenges for the Julia practitioner interested in extending Julia modeling abilities. We will discuss them in the talk and suggest how everyone can contribute\r
\r
All the code will be made available in a dedicated git repository and we are preparing a detailed publication to illustrate our approach.`,recording_license:"",do_not_record:!1,persons:[{id:16712,code:"WEFNJW",public_name:"Andre Macleod",biography:"My name is Andre Macleod, 25, born in Sweden, raised in Italy, moved to New Zealand as I am half-kiwi. Passionate in mathematics, I recently completed a Masters degree in Applied Data Science, and have been working on various data science projects, including some in Julia, which I would be excited to share at JuliaCon if given the chance.",answers:[]}],links:[],attachments:[],answers:[]},{id:17057,guid:"11eb216a-5e1e-59e9-8053-af3708b8049b",logo:"",date:"2022-07-28T12:30:00+00:00",start:"12:30",duration:"00:30",room:"Green",slug:"juliacon-2022-17057-fast-faster-julia-high-performance-implementation-of-the-nfft",url:"https://pretalx.com/juliacon-2022/talk/BASTLY/",title:"Fast, Faster, Julia: High Performance Implementation of the NFFT",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"In this talk, we present the architecture of the NFFT.jl package, which implements the non-equidistant fast Fourier trans-form (NFFT). The NFFT is commonly implemented in C/C++ and requires sophisticated performance optimizations to exploit the full potential of the underlying algorithm. We demonstrate how Julia enables a high-performance, generic, and dimension-agnostic implementation with only a fraction of the code required for established C/C++ NFFT implementations.",description:`The non-equidistant fast Fourier transform (NFFT) is an extension of the well-known fast Fourier transform (FFT) in which the sample points in one domain can be non-equidistant. The NFFT is an approximate algorithm and allows the approximation error to be controlled to achieve machine precision while keeping the algorithmic complexity in the same order of magnitude as a regular FFT. The NFFT plays an important role in many signal processing applications and has been intensively studied from both theoretical and computational perspectives. The fastest NFFT libraries are implemented in the low-level programming languages C and C++ and require a trade-off between generic code, code readability, and code efficiency. \r
\r
In this talk, we show that Julia provides new ways to optimize these three conflicting goals. We outline the architecture and implementation of the NFFT.jl package, which has recently been refactored to match the performance of the modern C++ implementation FINUFFT. NFFT.jl is fully generic, dimension-independent, and has a flexible architecture that allows parts of the algorithm to be exchanged through different code paths. This is crucial for the realization of different precomputation strategies tailored to optimize either the computation time or the required main memory. NFFT.jl makes intensive use of the Cartesian macros in Julia Base, allowing for zero-overhead and dimension-agnostic implementation. In contrast, the two modern C (NFFT3) and C++ (FINUFFT) libraries use dedicated 1D, 2D and 3D code paths to achieve maximum performance. The generic Julia implementation thus avoids code duplication and requires 3-4 times less code than its C/C++ counterparts. NFFT.jl is multi-threaded and uses a cache-aware blocking technique to achieve decent speedups.\r
\r
Package being presented: \r
-	https://github.com/JuliaMath/NFFT.jl`,recording_license:"",do_not_record:!1,persons:[{id:10315,code:"PM3B8U",public_name:"Tobias Knopp",biography:"Tobias Knopp received his Diplom degree in computer science in 2007 and his PhD in 2010, both from the University of L\xFCbeck with highest distinction. For his PhD on the tomographic imaging method Magnetic Particle Imaging (MPI) he was awarded with the Klee award from the DGBMT (VDE) in 2011. From 2010 until 2011 he led the MAPIT project at the University of L\xFCbeck and published the first scientific book on MPI. In 2011 he joined Bruker Biospin to work on the first commercially available MPI system. From 2012 until 2014 he worked at Thorlabs in the field of Optical Coherence Tomography (OCT) as a software developer. Since 2014, Tobias Knopp is a professor for Biomedical Imaging at the University Medical Center Hamburg-Eppendorf and the Hamburg University of Technology in Hamburg, Germany. Beside his work as a researcher in the field of tomographic imaging method Tobias Knopp is an open-source developer and part of the Julia community since 2012.",answers:[]}],links:[],attachments:[],answers:[]},{id:17702,guid:"285ff4ae-596f-56e5-a040-d19546abb7e2",logo:"/media/juliacon-2022/submissions/VC9YHN/sorting_wsCietR.svg",date:"2022-07-28T13:00:00+00:00",start:"13:00",duration:"00:30",room:"Green",slug:"juliacon-2022-17702-julia-s-latest-in-high-performance-sorting",url:"https://pretalx.com/juliacon-2022/talk/VC9YHN/",title:"Julia's latest in high performance sorting",subtitle:"",track:null,type:"Talk",language:"en",abstract:"This talk compares the runtime of Julia's builtin sorting with that of other languages and explains some of the techniques Julia uses to outperform other languages. This is a small part of the larger ongoing effort to equip Julia with state of the art and faster than state of the art performance for all sorting tasks.",description:`Julia's radix sort implementation: https://github.com/JuliaLang/julia/blob/fc1093ff1560b47611293bf71f8074030116edcc/base/sort.jl#L681\r
\r
Benchmark implementations: https://github.com/LilithHafner/InterLanguageSortingComparisons\r
\r
Extended discussion surrounding the introduction of radix sort to Julia: https://github.com/JuliaLang/julia/pull/44230\r
\r
Ongoing work: https://github.com/JuliaLang/julia/pull/45222\r
\r
Potential future work: https://github.com/JuliaLang/julia/discussions/44876#discussioncomment-2890020`,recording_license:"",do_not_record:!1,persons:[{id:18161,code:"UYMQJS",public_name:"Lilith Hafner",biography:"I live in Grinnell Iowa :)",answers:[]}],links:[],attachments:[],answers:[]},{id:18100,guid:"0435b43b-2ddb-545b-9924-dc2bfeb5f814",logo:"/media/juliacon-2022/submissions/N7DSLT/jgp_sgsHA1Q.png",date:"2022-07-28T13:30:00+00:00",start:"13:30",duration:"00:30",room:"Green",slug:"juliacon-2022-18100-julia-gaussian-processes",url:"https://pretalx.com/juliacon-2022/talk/N7DSLT/",title:"Julia Gaussian Processes",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Julia Gaussian Processes (Julia GPs) is home to an ecosystem of packages whose aim is to enable research and modelling using GPs in Julia. It specifies a variety of interfaces, code which implements these interfaces in standard settings, and code built on top of these interfaces (e.g. plotting). The composability and modularity of these interfaces distinguishes it from other GP software. This talk will explore the things that you can currently do with the ecosystem, and where it\u2019s heading.",description:`Gaussian processes provide a way to place prior distributions over unknown functions, and are used throughout probabilistic machine learning, statistics and numerous domain areas (climate science, epidemiology, geostatistics, model-based RL to name a few). Their popularity stems from their flexibility, interpretability, and the ease with which exact and approximate Bayesian inference can be performed, and their ability to be utilised as a single module in a larger probabilistic model.\r
\r
The goal of the [JuliaGPs organisation](https://github.com/JuliaGaussianProcesses/) is to provide a range of software which is suitable for both methodological research and deployment of GPs. We achieve this through a variety of clearly-defined abstractions, interfaces, and libraries of code. These are designed to interoperate with each other, and the rest of the Julia ecosystem (Distributions.jl, probabilistic programming languages, AD, plotting, etc), instead of providing a single monolithic package which attempts to do everything. This modular approach allows a GP researcher to straightforwardly build on top of lower-level components of the ecosystem which are useful in their work, without compromising on convenience when applying a GP in a more applications-focused fashion.\r
\r
This talk will (briefly) introduce GPs, and discuss the JuliaGPs: what its design principles are and how these relate to existing GP software, how it is structured, what is available, what it lets you do, what it doesn\u2019t try to do, and where there are gaps that we are trying to fill (and could use some assistance!). It will provide some examples of standard use (e.g. regression and classification tasks), making use of the core packages ([AbstractGPs](https://github.com/JuliaGaussianProcesses/AbstractGPs.jl), [ApproximateGPs](https://github.com/JuliaGaussianProcesses/ApproximateGPs.jl/), [KernelFunctions](https://github.com/JuliaGaussianProcesses/KernelFunctions.jl)), and how to move forward from there. It will also show how the abstractions have been utilised in the existing contributors\u2019 research, for example with [Stheno](https://github.com/JuliaGaussianProcesses/Stheno.jl), [TemporalGPs](https://github.com/JuliaGaussianProcesses/TemporalGPs.jl), [AugmentedGPLikelihoods](https://github.com/JuliaGaussianProcesses/AugmentedGPLikelihoods.jl), [GPDiffEq](https://github.com/Crown421/GPDiffEq.jl), [BayesianLinearRegressors](https://github.com/JuliaGaussianProcesses/BayesianLinearRegressors.jl), [LinearMixingModels](https://github.com/invenia/LinearMixingModels.jl), with the aim of providing inspiration for how you might do the same in your own.`,recording_license:"",do_not_record:!1,persons:[{id:1051,code:"LQKANJ",public_name:"Will Tebbutt",biography:"I'm a PhD student in the Machine Learning Group at Cambridge, supervised by Richard E. Turner. I'm generally interested in probabilistic modelling and (approximate) inference, how Gaussian processes should feature in probabilistic programming, and how to scale GPs for large time series and spatio-temporal problems.",answers:[]}],links:[],attachments:[],answers:[]},{id:21234,guid:"026dbe4f-f884-510c-8569-76d1d467eaa3",logo:"",date:"2022-07-28T14:30:00+00:00",start:"14:30",duration:"00:45",room:"Green",slug:"juliacon-2022-21234-restreaming-of-jeremy-howard-keynote",url:"https://pretalx.com/juliacon-2022/talk/UZBZRQ/",title:"Restreaming of Jeremy Howard Keynote",subtitle:"",track:"JuliaCon",type:"Keynote",language:"en",abstract:"Restreaming of the earlier Keynote by Jeremy Howard",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:21248,guid:"b3983d26-9946-52c1-afe7-6ac5b7619784",logo:"",date:"2022-07-28T15:20:00+00:00",start:"15:20",duration:"00:10",room:"Green",slug:"juliacon-2022-21248-intel-sponsored-talk",url:"https://pretalx.com/juliacon-2022/talk/DXHVBM/",title:"Intel Sponsored Talk",subtitle:"",track:null,type:"Gold sponsor talk",language:"en",abstract:"We create world-changing technology that improves the life of every person on the planet.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:21244,guid:"296f8eb8-467e-5a47-84b6-af7a8e42e0fb",logo:"",date:"2022-07-28T15:30:00+00:00",start:"15:30",duration:"00:15",room:"Green",slug:"juliacon-2022-21244-julius-tech-sponsored-talk",url:"https://pretalx.com/juliacon-2022/talk/R8VHSS/",title:"Julius Tech Sponsored Talk",subtitle:"",track:null,type:"Platinum sponsor talk",language:"en",abstract:"Julius offers an auto-scaling, low code graph computing solution that allows firms to quickly build transparent and adaptable data analytics pipelines.",description:`Julius offers an auto-scaling, low code graph computing solution that allows firms to quickly build transparent and adaptable data analytics pipelines. Graph computing is an innovative technology that enables developers to organize pipelines as directed acyclic graphs (DAGs). With Julius, DAGs representing complex workflows are created by composing smaller modular DAGs, and can be applied to many enterprise use cases including: explainable ML, big data analytics, data visualization and transformation, AAD, and more.\r
\r
For Julia users, we provide a dynamic platform to help developers make Julia more manageable and adoptable for enterprise computing. Engineers can produce enterprise scale solutions in a fraction of the time and cost.`,recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:17294,guid:"889514a1-27ac-5762-8bd8-7a88123f9172",logo:"",date:"2022-07-28T16:30:00+00:00",start:"16:30",duration:"00:30",room:"Green",slug:"juliacon-2022-17294-blockdates-a-context-aware-fuzzy-date-matching-solution",url:"https://pretalx.com/juliacon-2022/talk/AEXDKT/",title:"BlockDates: A Context-Aware Fuzzy Date Matching Solution",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"We developed the open-source software package BlockDates using the Julia programming language to allow the extraction of fuzzy-matched dates from a block of text. The tool leverages contextual information and draws on external date data to find the best date matches.  For each identified date, multiple interpretations are proposed and scored to find the best fit. The output includes several record-level variables that help explain the result and prioritize error detection.",description:`The date is often a critical piece of information for safety data analysis. It provides context and is necessary for measurement of event frequency and time-based trends. In some data sources, such as narrative information about an event or subject, the date is provided in various non-standardized formats. The Bureau of Transportation Statistics uses data provided in narrative, free-text format to validate and supplement reported safety event data.\r
\r
We developed the open-source software package BlockDates using the Julia programming language to allow the extraction of fuzzy-matched dates from a block of text. The tool leverages contextual information and draws on external date data to find the best date matches.  For each identified date, multiple interpretations are proposed and scored to find the best fit. The output includes several record-level variables that help explain the result and prioritize error detection.\r
\r
In a sample of 59,314 narrative records that include dates, the tool returned positive scores for 96.5% of records, meaning high confidence the selected date is valid.  Of those with no matching date, 77.9% were recognized correctly as having no viable match.`,recording_license:"",do_not_record:!1,persons:[{id:1181,code:"VPQZRP",public_name:"Francis Smart",biography:"Data Scientist at Censeo Consulting currently supporting GSA.",answers:[]}],links:[],attachments:[],answers:[]},{id:17277,guid:"e69c4b88-ca91-5555-8861-e627a5db3b6c",logo:"/media/juliacon-2022/submissions/XRDKTW/BOMBsLogo_iLDaFH0.png",date:"2022-07-28T17:00:00+00:00",start:"17:00",duration:"00:10",room:"Green",slug:"juliacon-2022-17277-an-introduction-to-bombs-jl-",url:"https://pretalx.com/juliacon-2022/talk/XRDKTW/",title:"An introduction to BOMBs.jl.",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Mathematical models are crucial to build and predict the behaviour of new biological systems. However, selecting between plausible model candidates or estimate parameters is an arduous job, especially considering the different informative content of experiments. BOMBs.jl is a package to automate model simulations, pseudo-data generation, maximum likelihood estimation and Bayesian inference of parameters (Stan and Turing.jl), and design optimal experiments for model selection and inference.",description:`We designed BOMBs.jl intending to contribute to the widespread of mathematical models in Biological sciences. Users only need basic Julia knowledge to use the package. The only requirement is to know how dictionaries work. Users can define in the contents of a dictionary the set of ordinary differential equations (and some other model information), and BOMBs.jl will automatically generate all the necessary scripts to simulate the model (including models with external time-varying inputs) and estimate parameters (MLE). The package also generates all the scripts required to perform Bayesian inference using Stan or Turing.jl, leaving as much freedom as possible in prior definitions. BOMBs will also generate any necessary scripts to perform optimal experimental design for model selection (drive pairs of competing model simulations as far as possible) and model inference (using model predictions uncertainty), aiming at reducing the time and resources allocated to in vivo experiments. The package is documented, with functions generating the dictionary structures for the user, complementary functions explaining what should be the contents and structures of the dictionaries, a document including a brief description of each function in the package and a set of Jupyter notebooks showing how to use all the package functionalities.\r
The Jupyter Notebook of this talk is included in the GitHub repository of the package at https://github.com/csynbiosysIBioEUoE/BOMBs.jl/blob/main/Examples/JuliaCon2022Notebook.ipynb`,recording_license:"",do_not_record:!1,persons:[{id:18120,code:"NBMJG8",public_name:"David Gomez-Cabeza",biography:"I am a Bioengineering PhD student at the University of Edinburgh working on optimal experimental design for automated model calibration and selection, both computationally and experimentaly. Coming from a pure experimental background (Microbiology), I discovered how powerfull modeling can be in not just predicting, but designing new biological systems, hence my transition to a hybrid type of work. I discovered Julia a couple of years ago, looking for faster environments to do my computational research (mostly Bayesian based), and now I completely shifted all my work to it!",answers:[]}],links:[],attachments:[],answers:[]},{id:18145,guid:"44325aa5-7f38-589e-a071-914d3fa52824",logo:"",date:"2022-07-28T17:10:00+00:00",start:"17:10",duration:"00:10",room:"Green",slug:"juliacon-2022-18145-build-test-sleep-repeat-modernizing-julia-s-ci-pipeline",url:"https://pretalx.com/juliacon-2022/talk/YED3MP/",title:"Build, Test, Sleep, Repeat: Modernizing Julia's CI pipeline",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Julia's Continuous Integration pipeline has struggled for many years now as the needs of the community have significantly outgrown the old Buildbot system.  In this talk we will detail the efforts of the CI dev team to provide reliability, reproducibility, security, and greater introspective ability in our CI builds.  These CI improvements aren't just helping the Julia project itself, but also other related open-source projects, as we continue to generate self-contained, useful building blocks.",description:"",recording_license:"",do_not_record:!1,persons:[{id:1080,code:"B98NWS",public_name:"Elliot Saba",biography:"Elliot Saba is a senior research engineer at Julia Computing, where he design next-generation tools for the Julia programming language. He received his Ph.D. from the University of Washington in Electrical Engineering in 2018, specializing in Digital Signal Processing and Machine Learning. Elliot received the Julia community prize at JuliaCon 2018, recognizing his open source contributions to the Julia project. When he is not building fundamental infrastructure for the Julia language, he enjoys dreaming up ever more complex strategies to automate watering his houseplants.",answers:[]},{id:18621,code:"VMSPPS",public_name:"Dilum Aluthge",biography:null,answers:[]}],links:[],attachments:[],answers:[]},{id:17948,guid:"c3fa6442-f84e-5ca0-be83-3171ab86cd5a",logo:"",date:"2022-07-28T17:20:00+00:00",start:"17:20",duration:"00:30",room:"Green",slug:"juliacon-2022-17948-extreme-value-analysis-in-julia-with-extremes-jl",url:"https://pretalx.com/juliacon-2022/talk/XMXJTD/",title:"Extreme Value Analysis in Julia with Extremes.jl",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"In this talk, we present [Extremes.jl](https://github.com/jojal5/Extremes.jl), a package that provides exhaustive high-performance functions for the statistical analysis of extreme values with Julia. Parameter estimation, diagnostic tools for assessing model accuracy and high quantile estimation are implemented for stationary and non-stationary extreme value models. The functionalities will be illustrated in this talk by reproducing many results from the popular book of Coles (2001).",description:`Risk assessment and impact analysis of extreme values is an important aspect of climate sciences. Recently, the Intergovernmental Panel on Climate Change (IPCC) reported that extreme meteorological events are expected to increase in frequency and intensity with climate change, leading to important impacts on many sectors of activities (IPCC 2013). The only statistical discipline that develops a rigorous framework for the study of extremes events is Extreme value theory. However, unlike other programming languages commonly used by statisticians, tools for the analysis of extreme values are lacking in Julia despite the growing popularity of the language among scientific community. \r
\r
In this talk, we present [Extremes.jl](https://github.com/jojal5/Extremes.jl), a package that provides exhaustive high-performance functions for the statistical analysis of extreme values. In particular, methods for the usual block maxima and peaks-over-threshold models are implemented. Model parameter estimation can be achieved by using the probability weighted moments, the maximum likelihood, and the Bayesian paradigm. Non-stationary models are also implemented as well as diagnostic plots for assessing model accuracy and high quantile estimation. \r
\r
The proposed package is designed to be used by the statistical community as well as by engineers who need estimations of extremes. We illustrate the package functionalities by reproducing many results obtained by Coles (2001).`,recording_license:"",do_not_record:!1,persons:[{id:18062,code:"8EDXNB",public_name:"Gabriel Gobeil",biography:"I am a research associate at Polytechnique Montr\xE9al in the group of [Jonathan Jalbert](https://www.polymtl.ca/expertises/jalbert-jonathan).",answers:[]}],links:[],attachments:[],answers:[]},{id:16876,guid:"1c6a6d61-ddf6-5aba-a74c-750d4278245f",logo:"",date:"2022-07-28T17:50:00+00:00",start:"17:50",duration:"00:10",room:"Green",slug:"juliacon-2022-16876-manopt-jl-optimisation-on-riemannian-manifolds",url:"https://pretalx.com/juliacon-2022/talk/ZT7AZZ/",title:"Manopt.jl \u2013\xA0Optimisation on Riemannian manifolds",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"`Manopt.jl` provides a set of optimization algorithms for problems given on a Riemannian manifold. Build upon on a generic optimization framework, together with the interface `ManifoldsBase.jl` for Riemannian manifolds, classical and recently developed methods are provided in an efficient implementation. This talk will also present some algorithms implemented in the package.",description:`In many applications and optimization tasks, non-linear data appears naturally.\r
For example, when data on the sphere is measured, diffusion data can be captured as a signal or even multivariate data of symmetric positive definite matrice, and orientations like they appear for electron backscattered diffraction (EBSD) data. Another example are fixed rank matrices, appearing in matrix completion.\r
Working on these data, for example doing data interpolation and approximation, denoising, inpainting, or performing matrix completion, can usually be phrased as an optimization problem\r
\r
Manopt.jl (manoptjl.org) provides a set of optimization algorithms for optimization problems given on a Riemannian manifold. Build upon on a generic optimization framework, together with the interface ManifoldsBase.jl for Riemannian manifolds, classical and recently developed methods are provided in an efficient implementation. Algorithms include the derivative-free Particle Swarm and Nelder\u2013Mead algorithms, as well as classical gradient, conjugate gradient and stochastic gradient descent. Furthermore, quasi-Newton methods like a Riemannian L-BFGS and nonsmooth optimization algorithms like a Cyclic Proximal Point Algorithm, a (parallel) Douglas-Rachford algorithm and a Chambolle-Pock algorithm are provided, together with several basic cost functions, gradients and proximal maps as well as debug and record capabilities.`,recording_license:"",do_not_record:!1,persons:[{id:17832,code:"3W8BBF",public_name:"Ronny Bergmann",biography:"I am a mathematician and computer scientist working on optimization on manifolds.",answers:[]}],links:[],attachments:[],answers:[]},{id:21378,guid:"f2fc169e-f664-56d9-b454-d73161dc0748",logo:"",date:"2022-07-28T18:00:00+00:00",start:"18:00",duration:"01:00",room:"Green",slug:"juliacon-2022-21378-gathertown-social-break",url:"https://pretalx.com/juliacon-2022/talk/HBYSDD/",title:"GatherTown -- Social break",subtitle:"",track:null,type:"Social hour",language:"en",abstract:"Join us on [Gather.town](http://gather.town/) for a social hour.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:17919,guid:"c88fd5d6-7426-5413-ac49-6b4c8e4cc382",logo:"",date:"2022-07-28T19:00:00+00:00",start:"19:00",duration:"00:10",room:"Green",slug:"juliacon-2022-17919-pycallchainrules-jl-reusing-differentiable-python-code-in-julia",url:"https://pretalx.com/juliacon-2022/talk/HBERVN/",title:"PyCallChainRules.jl: Reusing differentiable Python code in Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"While Julia is great, there are still a lot of existing useful differentiable Python code in PyTorch, Jax, etc. Given PyCall.jl is already so great and seamless, one might wonder what it takes to differentiate through those calls to Python functions. PyCallChainRules.jl aims for that ideal. DLPack.jl is leveraged to pass CPU or GPU arrays without any copy between Julia and Python.",description:"Auto differentiation interfaces are rapidly converging with [`functorch`](https://github.com/pytorch/functorch) and [`jax`](https://github.com/google/jax) on the Python side and more explicit interfaces for dealing with gradients in Julia with [`Functors.jl`](https://github.com/FluxML/Functors.jl) and [Optimisers.jl](https://github.com/FluxML/Optimisers.jl) as well as more explicit machine learning layers in [Lux.jl](https://github.com/avik-pal/Lux.jl). While it is relatively easy to implement new functionality in Julia, Python still remains the standard interface layer for most state-of-the-art functionality especially for GPU kernels. Even if not the most performant, there is value in being able to call existing differentiable functions in Python, as a developer slowly implements equivalent functionality in Julia.",recording_license:"",do_not_record:!1,persons:[{id:18333,code:"YMPKPW",public_name:"Jayesh K. Gupta",biography:"I am a Researcher at Microsoft Autonomous Systems where I work on improving simulations with data-driven methods.",answers:[]}],links:[],attachments:[],answers:[]},{id:18058,guid:"0ea34662-7c5f-527e-8802-057abb5ed453",logo:"",date:"2022-07-28T19:10:00+00:00",start:"19:10",duration:"00:10",room:"Green",slug:"juliacon-2022-18058-cosmological-emulators-with-flux-jl-and-differentialequations-jl",url:"https://pretalx.com/juliacon-2022/talk/VWGBAL/",title:"Cosmological Emulators with Flux.jl and DifferentialEquations.jl",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`In the next decade, forthcoming galaxy surveys will provide the astrophysical community with an unprecedented wealth of data. The standard analysis pipeline, usually employed to analyze this kind of surveys, are quite expensive from a computational point of view.\r
In this presentation I will show how, using Flux.jl and DiffEquations.jl, it is possible to accelerate standard analysis of some order of magnitudes.`,description:`We are living in the Golden Age of Cosmology: in the 20th century, our comprehension of the Universe has been rapidly evolving, eventually leading to the establishment of a concordance model, the so-called \u039BCDM model. Although the remarkable success of this model, which is able to explain with few parameters a great wealth of observations, there are several unanswered questions.\r
\r
What is the origin of the primordial fluctuations in the Universe? Is this due to some form of inflationary scenario?\r
\r
What is Dark Matter? Is it a new particle, not present in the Standard Model of Particle Physics? Is it composed by Primordial Black Holes?\r
\r
Which is the nature of Dark Energy? Can the Cosmological Constant really explain its effects or is this the sign of the breakdown of Einstein theory of General Relativity?\r
\r
In the next decade several galaxy surveys will start taking data, data that will be used to study the universe using different observational probes, such as weak lensing, galaxy clustering and their cross-correlation: studying these probes jointly will enhance the scientific outcome from galaxy surveys.\r
However, this improvement does not come at no cost.\r
\r
The analysis of a galaxy survey employs the evaluation of a complicated theoretical model, with about a hundred parameters. The computation of this theoretical prediction requires about 1-10 seconds; although this is not an expensive step per se, considering that this computation is repeated 10^5-10^7 times shows that a complete analysis requires either a very long time or dedicated hardware.\r
\r
In order to overcome this issue, I am developing several surrogate models, based on DifferentialEquations.jl and Flux.jl. The combination of these two packages is quite useful for this particular case: while several papers on this topic have usually relied solely on Neural Networks to build emulators, solving some of the differential equations involved in the model evaluation reduces the dimensionality of the emulated parameters space, obtaining a more precise surrogate model. The result of this work is the development of several surrogate models with a precision of ~ 0.1% (matching the requirement for the scientific analysis) with a speed-up of about 100-1000X. The developed models will be released after the publications of the related papers.`,recording_license:"",do_not_record:!1,persons:[{id:10300,code:"PPMTQ9",public_name:"Marco Bonici",biography:"I am a PostDoctoral Researcher at INAF-IASF in Milano. My research interest lies in the field of Cosmology and, specifically, I am involved in Euclid, a mission of the European Space Agency. I am involved in several scientific working group within Euclid, with a particular focus on the analysis of the final data of the mission.",answers:[]}],links:[],attachments:[],answers:[]},{id:16742,guid:"d6143caf-0465-5514-95c2-c3806e07423e",logo:"/media/juliacon-2022/submissions/UPQFKL/SpringFineMeshNHb_TMEDxsr.png",date:"2022-07-28T19:20:00+00:00",start:"19:20",duration:"00:10",room:"Green",slug:"juliacon-2022-16742-automatic-differentiation-for-solid-mechanics-in-julia",url:"https://pretalx.com/juliacon-2022/talk/UPQFKL/",title:"Automatic Differentiation for Solid Mechanics in Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Automatic Differentiation (AD) is widely applied in many different fields of computer science and engineering to accurately evaluate derivatives of functions expressed in a computer programming language. In this talk we illustrate the use of AD for the solution of Finite Elements (FE) problems with special emphasis on solid mechanics.",description:`The standard implementation of the Finite Element Method for solid mechanics is based on discretizing the domain into elements and solving the weak form of the point-wise Cauchy's equilibrium equations. This process involves the evaluation of the components of complex tensorial quantities, such as the stress and the stiffness tensor, that are required to calculate the residual force vector and the tangent stiffness matrix. On the other hand the residual force vector and the tangent stiffness matrix coincides, both formally and numerically, with the gradient and the hessian of the free energy of the system, therefore they can be evaluated directly by taking the automatic derivatives of this quantity. The advantage, in this case, is that the free energy is a scalar quantity, which is significantly simpler to evaluate.\r
\r
In particular, forward mode AD seems particularly suited for the solution of solid mechanics FE problems. In fact, even if FE models can have a very large number of degrees of freedom (DoFs), the free energy of the system in a given configuration is obtained as the sum over the elements of the mesh, and only the degrees of freedom of a single element are involved in the calculation of its contribution to the global residual force vector and tangent stiffness matrix. Therefore we only deal with a limited number of independent variables at time when evaluating individual elements contributions. In this situation a forward mode automatic differentiation scheme implemented through hyper-dual numbers is very efficient for the calculation of higher order derivatives of, however complicate scalar expressions.\r
    \r
The definition of a hyper-dual number system in Julia is particularly straightforward, in fact a structure capable of storing the gradient and the hessian of a quantity, alongside its value, can be simply defined as\r
\`\`\`Julia\r
struct D2{T,N,M} <:Number \r
  v::T\r
  g::NTuple{N,T}\r
  h::NTuple{M,T}\r
end\r
\`\`\`\r
with\r
- \`v\` the value of the variable,\r
- \`g\` the components of the gradient of \`v\`,\r
- \`h\` the Hessian,\r
\r
and where the type parameters are\r
- \`T\` the type of the values,\r
- \`N\` the number of independent variables controlling the gradient,\r
- \`M = N(N+1)/2\` is the number of independent elements in the Hessian, we remark that since the hessian is symmetric we only store and operate on half of it.\r
\r
Thanks to the multiple dispatch feature of Julia, it is sufficient to implement the needed mathematical operator and function over this newly numerical type and the same code that evaluates an expression will also evalute its derivatives, without any change to the original source code. In addition, the usage of macros for implementation of the operations on the gradient and hessian tuples makes the resulting code particualarly efficient.\r
\r
In this talk we will present [AD4SM.jl](https://github.com/avigliotti/AD4SM.jl/), a package that implements a second order hyper-dual number system for evaluating both the gradient and hessian of the free energy of a deformable body, allowing the solution of non linear equilibrium problems. The implementation of the dual number system was inspired by the [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) package, but here the hessian is explicitly introduced, since it is essential for the evaluation of the tangent stiffness matrix, and its symmetry exploited to maximize efficiency. A number of examples are also presented that illustrate how complex non linear problems, with non trivial constraints and boundary conditions, both in two and three dimensions can be numerically stated and solved [1].\r
\r
\r
#### References \r
\r
[1] [Vigliotti, A., Auricchio, F., Automatic Differentiation for Solid Mechanics, Archives of Computational Methods in Engineering, Volume 28, Issue 3, Pages 875 - 895 May 2021](https://rdcu.be/b0yx2)`,recording_license:"",do_not_record:!1,persons:[{id:17643,code:"BVAVX8",public_name:"Andrea Vigliotti",biography:"Researcher at the Italian Aerospace Research Center. My interests are in solid mechanics at large, both numerical and experimental.",answers:[]}],links:[],attachments:[],answers:[]},{id:18065,guid:"abb62661-7298-5952-9825-5c2e2d6be571",logo:"",date:"2022-07-28T19:30:00+00:00",start:"19:30",duration:"00:10",room:"Green",slug:"juliacon-2022-18065-chainrules-jl-meets-unitful-jl-autodiff-via-unit-analysis",url:"https://pretalx.com/juliacon-2022/talk/G9SQQD/",title:"ChainRules.jl meets Unitful.jl: Autodiff via Unit Analysis",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Tools for performing autodifferentiation (AD) and dimensional work in Julia are robust, but not always compatible. This talk explores how we can understand rule-based AD in Julia by showing how to make dimensional quantities from `Unitful.jl` compose with `ChainRules.jl`. Combining these two projects produces an intuitive look at the building blocks of AD in Julia using only rudimentary calculus and dimensional analysis.",description:"`Unitful.jl` provides efficient type-level support for dimensional quantities we encounter when simulating physical systems. Likewise, `ChainRules.jl` forms the backbone of robust but easily-extensible autodifferentiation (AD) systems. Exploring these two systems together yields an insightful look at Julia's rule-based AD. Calculus, dimensional analysis, and physical intuition are sufficient to explain how `ChainRules.jl` works by building AD rules for `Unitful.jl`.\r\n\r\nThe versatility of the `ChainRules.jl` ecosystem arises from implementing and extending a ruleset for fundamental functions, such as `*` and `inv`, as `rrule`s and `frule`s. What can often seem like a mysterious black box that computes derivatives is actually composed of many individual `rrule`s or `frule`s built on rudimentary calculus.\r\n\r\nThese `rrule`s and `frule`s are interpreted by thinking about differentiation as a problem of physical dimensions, and `Unitful.jl` is used to confirm these findings. However, arithmetic between `Unitful.jl` quantities is not immediately compatible with `ChainRules.jl`-based AD. This talk presents the pertinent AD rules to enable basic `ChainRules.jl` compatibility. These rules are also used as a lens to understand how to read and write AD rules for the `ChainRules.jl` ecosystem.",recording_license:"",do_not_record:!1,persons:[{id:18435,code:"7YNMYP",public_name:"Sam Buercklin",biography:`Sam Buercklin is a research software engineer at Metalenz. \r
\r
At Metalenz, Sam develops computational E&M tools for optical metasurfaces. His work touches on high performance computing, numerical optimization, and user-facing tools to specify and solve complex technical problems.\r
\r
Sam has previously worked in various computational domains, including quantum computing, optics, and neuroscience.`,answers:[]}],links:[],attachments:[],answers:[]},{id:17259,guid:"2a04f025-24f7-5b21-8e3d-35c83d62af14",logo:"",date:"2022-07-28T19:40:00+00:00",start:"19:40",duration:"00:30",room:"Green",slug:"juliacon-2022-17259-using-optimization-jl-to-seek-the-optimal-optimiser-in-sciml",url:"https://pretalx.com/juliacon-2022/talk/PDCANR/",title:"Using Optimization.jl to seek the optimal optimiser in SciML",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Optimization.jl seeks to bring together all of the optimization packages it can find, local and global, into one unified Julia interface. This means, you learn one package and you learn them all! Optimization.jl adds a few high-level features, such as integrating with automatic differentiation, to make its usage fairly simple for most cases, while allowing all of the options in a single unified interface.",description:"Optimization.jl wraps most of the major optimisation packages available in Julia currently, namely BlackBoxOptim, CMAEvolutionStrategy, Evolutionary, Flux, GCMAES, MultistartOptimization, Metaheuristics, NOMAD, NLopt, Nonconvex, Optim and Quaddirect. Additionally the integration with ModelingToolkit and MathOptInterface allow it to leverage the state of art symbolic manipulation capabilities offered by these packages, specifically making use of it to construct the objective and constraint, jacobian and hessian efficiently. This talk will show how to use the Optimization.jl package, its various AD backends in combination with various optimiser backends. The interface is broken into three components, `OptimizationFunction`, `OptimizationProblem` and then `solve` on a `OptimizationProblem`. We will cover each of this components and discuss the pros and cons of choices available for specific problems. The focus would also be to show how such a flexible system is necessary for scientific machine learning by demonstrating some popular SciML models on real world problems.",recording_license:"",do_not_record:!1,persons:[{id:10006,code:"7YFPLU",public_name:"Vaibhav Dixit",biography:"I am a Software Engineer at Julia Computing where I am involved in building tools for pharmaceutical industry. I am also a maintainer in the SciML ecosystem of packages for parameter estimation and global sensitivity analysis. I would love to talk to people about bayesian statistics and scientific machine learning as well as building software for EHRs and healthcare in general.",answers:[]}],links:[],attachments:[],answers:[]},{id:21377,guid:"601f584b-22a1-5c08-9d84-d90584aaadeb",logo:"",date:"2022-07-28T20:30:00+00:00",start:"20:30",duration:"01:00",room:"Green",slug:"juliacon-2022-21377-gathertown-social-break",url:"https://pretalx.com/juliacon-2022/talk/VLZBNZ/",title:"GatherTown -- Social break",subtitle:"",track:null,type:"Social hour",language:"en",abstract:"Join us on [Gather.town](http://gather.town/) for a social hour.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]}],Red:[{id:18151,guid:"747db241-5b1b-51e2-aa41-8cfcce75b4e0",logo:"",date:"2022-07-28T12:30:00+00:00",start:"12:30",duration:"00:30",room:"Red",slug:"juliacon-2022-18151-adaptive-radial-basis-function-surrogates-in-julia",url:"https://pretalx.com/juliacon-2022/talk/MDCJKK/",title:"Adaptive Radial Basis Function Surrogates in Julia",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"This talk focuses on an iterative algorithm, called active learning, to update radial basis function surrogates by adaptively choosing points across its input space. This work extensively uses the SciML ecosystem, and in particular, Surrogates.jl.",description:`Active Learning algorithms have been applied to fine tune surrogate models. In this talk, we analyze these algorithms in the context of dynamical systems with a large number of input parameters. The talk will demonstrate: \r
1. An adaptive learning algorithm for radial basis functions \r
2. Its efficacy on dynamical systems with high dimensional input parameter spaces\r
\r
This will make use of Surrogates.jl and the rest of the SciML ecosystem.`,recording_license:"",do_not_record:!1,persons:[{id:1148,code:"AZXJH3",public_name:"Ranjan Anantharaman",biography:"I am a PhD candidate at the Julia Lab at MIT.",answers:[]}],links:[],attachments:[],answers:[]},{id:18647,guid:"20ee9b9c-d15c-5c6e-811c-190aa88621e6",logo:"",date:"2022-07-28T13:00:00+00:00",start:"13:00",duration:"00:10",room:"Red",slug:"juliacon-2022-18647-lux-jl-explicit-parameterization-of-neural-networks-in-julia",url:"https://pretalx.com/juliacon-2022/talk/NLDVYU/",title:"Lux.jl: Explicit Parameterization of Neural Networks in Julia",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"Julia already has quite a few well-established Neural Network Frameworks -- [Flux](https://fluxml.ai/) & [KNet](https://denizyuret.github.io/Knet.jl/latest/). However, certain design elements -- **Coupled Model and Parameters** & **Internal Mutations** -- associated with these frameworks make them less compiler and user friendly. Making changes to address these problems in the respective frameworks would be too disruptive for users. To address these challenges, we designed `Lux,` a NN framework.",description:"`Lux,` is a neural network framework built completely using pure functions to make it both compiler and automatic differentiation friendly. Relying on the most straightforward pure functions API ensures no reference issues to debug, and compilers can optimize it as much as possible, is compatible with Symbolics/XLA/etc. without any tricks.\r\n\r\nRepository: https://github.com/avik-pal/ExplicitFluxLayers.jl/",recording_license:"",do_not_record:!1,persons:[{id:16717,code:"D3QNBC",public_name:"Avik Pal",biography:null,answers:[]}],links:[],attachments:[],answers:[]},{id:17223,guid:"7bda8ac6-ae9c-5ff0-9b99-e4a546a75a10",logo:"",date:"2022-07-28T13:10:00+00:00",start:"13:10",duration:"00:10",room:"Red",slug:"juliacon-2022-17223-graphppl-jl-a-package-for-specification-of-probabilistic-models",url:"https://pretalx.com/juliacon-2022/talk/MVRVTP/",title:"GraphPPL.jl: a package for specification of probabilistic models",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"We present GraphPPL.jl - a package for user-friendly specification of probabilistic models with variational inference constraints. GraphPPL.jl creates a model as a factor graph and supports the specification of factorization and form constraints on the variational posterior for the latent variables. The package collection GraphPPL.jl, ReactiveMP.jl and Rocket.jl provide together a full reactive programming-based ecosystem for running efficient and customizable variational Bayesian inference.",description:`**Background**\r
\r
Bayesian modeling has become a popular framework for important real-time machine learning applications, such as speech recognition and robot navigation.  Unfortunately, many useful probabilistic time-series models contain a large number of latent variables, and consequently real-time Bayesian inference based on Monte Carlo sampling or other black-box methods in these models is not feasible.\r
\r
**Problem statement**\r
\r
Existing packages for automated Bayesian inference in the Julia language ecosystem, such as Turing.jl, Stan.jl, and Soss.jl, support probabilistic model specification by well-designed macro-based meta languages. These packages assume that inference is executed by black-box variational or sampling-based methods. In principle, for conjugate probabilistic time-series models, message passing-based variational inference by minimization of a constrained Bethe Free Energy yields approximate inference solutions obtained with cheaper computational costs. In this contribution, we develop a user-friendly and comprehensive meta language for specification of both a probabilistic model and variational inference constraints that balance accuracy of inference results with computational costs. \r
\r
**Solution proposal**\r
\r
The GraphPPL.jl package implements a user-friendly specification language for both the model and the inference constraints. GraphPPL.jl exports the \`@model\` macro to create a probabilistic model in the form of a factor graph that is compatible with ReactiveMP.jl's reactive message passing-based inference engine. To enable fast and accurate inference, all message update rules default to precomputed analytical solutions. The ReactiveMP.jl package already implements a selection of precomputed rules. If an analytical solution is not available, then the GraphPPL.jl package provides ways to tweak, relax, and customize local constraints in selected parts of the factor graph. To simplify this process, the package exports the \`@constraints\` macro to specify extra factorization and form constraints on the variational posterior [1]. For advanced use cases, GraphPPL.jl exports the \`@meta\` macro that enables custom message passing inference modifications for each node in a factor graph representation of the model. This approach enables local approximation methods only if necessary and allows for efficient variational Bayesian inference.\r
\r
**Evaluation**\r
\r
Over the past two years, our probabilistic modeling ecosystem comprising GraphPPL.jl, ReactiveMP.jl, and Rocket.jl has been battle tested with many sophisticated models that led to several publications in high-ranked journals such as Entropy [1] and Frontiers [2], and conferences like MLSP-2021 [3] and ISIT-2021 [4]. The current contribution enables a user-friendly approach to very sophisticated Bayesian modeling problems. \r
\r
**Conclusions**\r
\r
We believe that a user-friendly specification of efficient Bayesian inference solutions for complex models is a key factor to expedite application of Bayesian methods. We developed a complete ecosystem for running efficient, fast, and reactive variational Bayesian inference with a user-friendly specification language for the probabilistic model and variational constraints. We are excited to present GraphPPL.jl as a part of our complete variational Bayesian inference ecosystem and discuss the advantages and drawbacks of this approach. \r
\r
**References**\r
\r
[1] Ismail Senoz, Thijs van de Laar, Dmitry Bagaev, Bert de Vries. Variational Message Passing and Local Constraint Manipulation in Factor Graphs, Entropy. Special Issue on Approximate Bayesian Inference, 2021. \r
\r
[2] Albert Podusenko, Bart van Erp, Magnus Koudahl, Bert de Vries. AIDA: An Active Inference-Based Design Agent for Audio Processing Algorithms, Frontiers in Signal Processing, 2022.\r
\r
[3] Albert Podusenko, Bart van Erp, Dmitry Bagaev, Ismail Senoz, Bert de Vries. Message Passing-Based Inference in the Gamma Mixture Model, 2021 IEEE 31st International Workshop on Machine Learning for Signal Processing (MLSP).\r
\r
[4] Ismail Senoz, Albert Podusenko, Semih Akbayrak, Christoph Mathys, Bert de Vries. The Switching Hierarchical Gaussian Filter, 2021 IEEE International Symposium on Information Theory (ISIT).`,recording_license:"",do_not_record:!1,persons:[{id:9845,code:"F87RD7",public_name:"Dmitry Bagaev",biography:"My research interests lie in the fields of computers science, machine learning and probabilistic programming. Currently I am a PhD candidate in the SPS group of Electrical Engineering department in Eindhoven University of Technology. I\u2019m working on a high-performant implementation of message passing-based Bayesian inference package in the Julia programming language. My research project focuses on Signal Processing and Active inference applications, but is also aimed to expand the scope of possible applications for message passing in general.",answers:[]}],links:[],attachments:[],answers:[]},{id:16261,guid:"ae4fc11e-fe8b-5259-ad3d-2599d8c4bad3",logo:"",date:"2022-07-28T13:20:00+00:00",start:"13:20",duration:"00:10",room:"Red",slug:"juliacon-2022-16261-turingglm-jl-bayesian-generalized-linear-models-using-formula",url:"https://pretalx.com/juliacon-2022/talk/8JWMG8/",title:"TuringGLM.jl: Bayesian Generalized Linear models using @formula",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:`TuringGLM makes easy to specify Bayesian **G**eneralized **L**inear **M**odels using the formula syntax and returns an instantiated [Turing](https://github.com/TuringLang/Turing.jl) model.\r
\r
Example:\r
\r
\`\`\`julia\r
@formula(y ~ x1 + x2 + x3)\r
\`\`\`\r
\r
Heavily inspired by [brms](https://github.com/paul-buerkner/brms/) (uses RStan or CmdStanR) and [bambi](https://github.com/bambinos/bambi) (uses PyMC3).`,description:"# TuringGLM\r\n\r\nTuringGLM makes easy to specify Bayesian **G**eneralized **L**inear **M**odels using the formula syntax and returns an instantiated [Turing](https://github.com/TuringLang/Turing.jl) model.\r\n\r\nHeavily inspired by [brms](https://github.com/paul-buerkner/brms/) (uses RStan or CmdStanR) and [bambi](https://github.com/bambinos/bambi) (uses PyMC3).\r\n\r\n## `@formula`\r\n\r\nThe `@formula` macro is extended from [`StatsModels.jl`](https://github.com/JuliaStats/StatsModels.jl) along with  [`MixedModels.jl`](https://github.com/JuliaStats/MixedModels.jl) for the random-effects (a.k.a. group-level predictors).\r\n\r\nThe syntax is done by using the `@formula` macro and then specifying the dependent variable followed by a tilde `~` then the independent variables separated by a plus sign `+`.\r\n\r\nExample:\r\n\r\n```julia\r\n@formula(y ~ x1 + x2 + x3)\r\n```\r\n\r\nModerations/interactions can be specified with the asterisk sign `*`, e.g. `x1 * x2`.\r\nThis will be expanded to `x1 + x2 + x1:x2`, which, following the principle of hierarchy,\r\nthe main effects must also be added along with the interaction effects. Here `x1:x2`\r\nmeans that the values of `x1` will be multiplied (interacted) with the values of `x2`.\r\n\r\nRandom-effects (a.k.a. group-level effects) can be specified with the `(term | group)` inside\r\nthe `@formula`, where `term` is the independent variable and `group` is the **categorical**\r\nrepresentation (i.e., either a column of `String`s or a `CategoricalArray` in `data`).\r\nYou can specify a random-intercept with `(1 | group)`.\r\n\r\nExample:\r\n\r\n```julia\r\n@formula(y ~ (1 | group) + x1)\r\n```\r\n\r\n## Data\r\n\r\nTuringGLM supports any `Tables.jl`-compatible data interface.\r\nThe most popular ones are `DataFrame`s and `NamedTuple`s.\r\n\r\n## Supported Models\r\n\r\nTuringGLM supports non-hiearchical and hierarchical models.\r\nFor hierarchical models, only single random-intercept hierarchical models are supported.\r\n\r\nFor likelihoods, `TuringGLM.jl` supports:\r\n\r\n* `Gaussian()` (the default if not specified): linear regression\r\n* `Student()`: robust linear regression\r\n* `Logistic()`: logistic regression\r\n* `Pois()`: Poisson count data regression\r\n* `NegBin()`: negative binomial robust count data regression",recording_license:"",do_not_record:!1,persons:[{id:11896,code:"SKB7VR",public_name:"Jose Storopoli",biography:"Associate Professor and Researcher of the [Department of Computer Science](https://uninove.br/ppgi) at [Universidade Nove de Julho - UNINOVE](https://uninove.br) located in S\xE3o Paulo - Brazil.\r\nLead on Education and Training at [Pumas-AI](https://pumas.ai).\r\n\r\nTeaches undergraduate and graduate courses in Data Science, Statistics, Bayesian Statistics, Machine Learning and Deep Learning using `Julia`, `R`, `Python`, and `Stan`. Contributor to `Julia`, `R` and `Stan` ecosystems. Proficient in `C`/`C++` and `Rust`.\r\nHas published `Julia`, `Rust`, `R`, and `Python` packages in official repositories/registries.\r\n\r\nResearches, publishes and advises PhD candidates on topics about Bayesian Statistical Modeling and Machine Learning applied to Decision Making.\r\nPrincipal Investigator of [LabCidades - Smart City Research Lab at UNINOVE](https://github.com/LabCidades).\r\n\r\nCoauthor of [Julia Data Science book](https://juliadatascience.io/).\r\nLeads the development of education and training materials for Pumas users in Julia.\r\nMember of the [`Stan` Governing Body - SGB](https://mc-stan.org/about/).\r\nMember of the [`Turing.jl` Developer Team](https://turing.ml/dev/team/).\r\nCertified [RStudio Tidyverse Instructor](https://education.rstudio.com/trainers/people/storopoli+jose/).",answers:[]}],links:[],attachments:[],answers:[]},{id:18032,guid:"a1f33df5-af8f-5a00-ae20-d0c83c5af75d",logo:"",date:"2022-07-28T13:30:00+00:00",start:"13:30",duration:"00:10",room:"Red",slug:"juliacon-2022-18032-text-segmentation-with-julia",url:"https://pretalx.com/juliacon-2022/talk/VGEWU7/",title:"Text Segmentation with Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Introducing TextSegmentation.jl, a package for Text Segmentation with Julia. Text Segmentation is a method of dividing an unstructured document including various contents into several parts according to its topics. So it is an important technique that supports various natural language processing tasks such as summarization, extraction, and question answering. If the audience listen to this presentation, they will learn Text Segmentation and how to use packages and be able to perform it easily.",description:`TextSegmentation.jl(https://github.com/kawasaki-kento/TextSegmentation.jl) provides a julia implementation of unsupervised text segmentation methods. Text Segmentation is a method for dividing an unstructured document including various contents into several parts according to their topics. A specific example of its use is pre-processing in natural language processing. Natural language processing includes various tasks such as summarization, extraction, and question answering, but to achieve higher accuracy, text preprocessing is necessary. Text segmentation helps improve the accuracy of those tasks by allowing documents to be segmented according to topics. As specific text segmentation methods, this package provides the following three:\r
\r
 - TextTiling\r
	 + TextTiling is a method for finding segment boundaries based on lexical cohesion and similarity between adjacent blocks.\r
 - C99\r
	 + C99 is a method for determining segment boundaries by divisive clustering.\r
 - TopicTiling\r
	 + TopicTiling is an extension of TextTiling that uses the topic IDs of words in a sentence to calculate the similarity between blocks.\r
\r
The planned presentations are as follows\r
\r
1. introduction\r
	 + I will introduce the purpose of TextSegmentation.jl and what it is useful for.\r
\r
2. Text Segmentation\r
	 + Specific methods of text segmentation will be explained.\r
\r
3. overview of the package\r
	 + Introduce how to use the package and how to perform the tasks.\r
\r
4. example\r
	 + Using simple text data, this section explains how to actually perform text segmentation with the package.\r
\r
5. future work\r
	 + Share future prospects for TextSegmentation.jl.`,recording_license:"",do_not_record:!1,persons:[{id:12241,code:"TX88YQ",public_name:"Kento Kawasaki",biography:"Researcher in natural language processing",answers:[]}],links:[],attachments:[],answers:[]},{id:17284,guid:"fd51664e-2331-58a0-aed9-4358a904cf8a",logo:"/media/juliacon-2022/submissions/VWVY9S/overview_UGhf2Z2.png",date:"2022-07-28T13:40:00+00:00",start:"13:40",duration:"00:10",room:"Red",slug:"juliacon-2022-17284-recommendation-jl-modeling-user-item-interactions-in-julia",url:"https://pretalx.com/juliacon-2022/talk/VWVY9S/",title:"Recommendation.jl: Modeling User-Item Interactions in Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Recommender system is a data-driven application that generates personalized content for users. This talk shows how Julia can be a deeply satisfying option to capture the unique characteristics of recommenders, which rely heavily on repetitive matrix computations in multi-stage data pipelines. To build trustworthy systems in terms of not only accuracy and scalability but usability and fairness at large, we particularly focus on API design and evaluation methods implemented on Recommendation.jl.",description:`This talk demonstrates **Recommendation.jl**, a Julia package for building recommender systems, with a special emphasis on its design principle and evaluation framework. While the package was first presented at JuliaCon 2019 to collect early feedback from the community, this talk highlights how the implementation has evolved afterwards and gives a preview of upcoming "v1.0.0" major release, accompanied by a proceeding paper.\r
\r
An underlying question for the audiences throughout the talk is: *How should "good" recommender systems be?* On one hand, improving the accuracy of recommendation with sophisticated algorithms is indeed desired. However, at the same time, recommendation is not always the same as machine learning problems, and non-accuracy aspects of the systems are equally or even more important in practice; we particularly discuss the importance of decoupling data from business logic and validating data/model quality based on a diverse set of decision criteria.\r
\r
First of all, a core of recommendation engine largely relies on simple math and matrix computation against sparse user-item data, where we can take full advantage of numerical computing methods. Thus, Julia is a great choice to efficiently and effectively implement an end-to-end recommendation pipeline that typically consists of multiple sub-tasks as follows:\r
\r
1. preprocessing user-item data;\r
2. building a recommendation model;\r
3. evaluating a ranked list of recommended contents;\r
4. post-processing the recommendation.\r
\r
Here, Recommendation.jl provides a unified abstraction layer, namely \`DataAccessor\`, which represents user-item interactions in an accessible form. Since data for recommender systems is readily standardizable as a collection of user, item, and contextual features, the common interface helps us to follow the separation of concerns principle and ensure the easiness and reliability of data manipulation. To be more precise, raw data is always converted into a \`DataAccessor\` instance at the data preprocessing phase (Phase#1) with proper validation (e.g., data type check, missing value handling), and hence the subsequent steps can simply access the data (or metadata) through the instance without worrying about unexpected input.\r
\r
Moreover, when it comes to generating recommendations at later phases (Phase#2-4), Recommendation.jl enables developers to optimize recommenders against not only standard accuracy metrics (e.g., recall, precision) but non-accuracy measures such as novelty, diversity, and serendipity. Even though the idea of diverse or serendipitous recommendation is not new in the literature, the topic has rapidly gained traction as society realizes the importance of fairness in intelligent systems. In this talk, we dive deep into the concept of these non-accuracy metrics and their implementation in Julia.\r
\r
Last but not least, there are a couple of new recommendation models recently added to the package, including matrix factorization with Bayesian personalized ranking loss and factorization machines. We plan to provide comprehensive benchmark results for supported recommender-metric pairs to undergo trade-off discussion. Furthermore, we compare Recommendation.jl with other publicly available recommendation toolkit like LensKit (Python), MyMediaLite (C#), and LibRec (Java).`,recording_license:"",do_not_record:!1,persons:[{id:1059,code:"H7JDBW",public_name:"Takuya Kitazawa",biography:"**[Takuya Kitazawa](https://takuti.me/)** is a product developer and data ethicist, working at the intersection of technological and societal aspects of data-driven applications. He professionally serves as a full-stack software & machine learning engineer, data scientist, and product manager, while advocating [ethical product development](https://takuti.me/note/ethical-product-developer/) as an OSS developer and technical evangelist.",answers:[]}],links:[],attachments:[],answers:[]},{id:21253,guid:"8da78d64-b124-5540-94d8-e5b0e8901d50",logo:"",date:"2022-07-28T13:50:00+00:00",start:"13:50",duration:"00:05",room:"Red",slug:"juliacon-2022-21253-g-research-sponsored-talk",url:"https://pretalx.com/juliacon-2022/talk/JKKXTS/",title:"G Research Sponsored Talk",subtitle:"",track:null,type:"Silver sponsor talk",language:"en",abstract:"G-Research is Europe\u2019s leading quantitative finance research firm",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:21249,guid:"975fd349-357d-5550-952f-032a744bfe43",logo:"",date:"2022-07-28T13:55:00+00:00",start:"13:55",duration:"00:05",room:"Red",slug:"juliacon-2022-21249-pumas-sponsored-talk",url:"https://pretalx.com/juliacon-2022/talk/JC3GKD/",title:"Pumas Sponsored Talk",subtitle:"",track:null,type:"Silver sponsor talk",language:"en",abstract:"With deep expertise in allied fields of clinical pharmacology, pharmacometrics, drug development, regulations and advanced data analytics including machine learning, Pumas-AI works with companies, laboratories and universities as their healthcare intelligence partner.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:17952,guid:"d61434af-ac4d-517b-8a3e-db13c37d4873",logo:"/media/juliacon-2022/submissions/ZZ3HGF/logo_EjpCY6N.png",date:"2022-07-28T16:30:00+00:00",start:"16:30",duration:"00:10",room:"Red",slug:"juliacon-2022-17952-hpc-sparse-linear-algebra-in-julia-with-partitionedarrays-jl",url:"https://pretalx.com/juliacon-2022/talk/ZZ3HGF/",title:"HPC sparse linear algebra in Julia with PartitionedArrays.jl",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"PartitionedArrays is a distributed sparse linear algebra engine that allows Julia users to easily prototype and deploy large computations on distributed-memory HPC platforms. The long-term goal is to provide a Julia alternative to the parallel vectors and sparse matrices available in well-known distributed algebra packages such as PETSc. Using PartitionedArrays, application libraries have shown excellent strong and weak scaling results up to tends of thousands of CPU cores.",description:"PartitionedArrays (https://github.com/fverdugo/PartitionedArrays.jl) is a distributed sparse linear algebra engine that allows Julia programmers to easily prototype and deploy large computations on distributed-memory, high performance computing (HPC) platforms. The package provides a data-oriented parallel implementation of vectors and sparse matrices, ready to use in several applications, including (but not limited to) the discretization of partial differential equations (PDEs) with grid-based algorithms such as finite differences, finite volumes, or finite element methods.  The long-term goal of this package is to provide a Julia alternative to the parallel vectors and sparse matrices available in well-known distributed algebra packages such as PETSc or Trilinos. It also aims at providing the basic building blocks for the implementation in Julia of other linear algebra algorithms such as distributed sparse linear solvers. We started this project motivated by the fact that using bindings to PETSc or Trilinos for parallel computations in Julia can be cumbersome in many situations. One is forced to use MPI as the parallel execution model and drivers need to be executed non-interactively with commands like `mpiexec -n 4 julia input.jl`, which posses serious difficulties to the development process. Some typos and bugs can be debugged interactively with a single MPI rank in the Julia REPL, but genuine parallel bugs often need to be debugged non-interactively using `mpiexec`. In this case, one cannot use development tools such as Revise or Debugger, which is a serious limitation, specially for complex codes that take a lot of time to JIT-compile since one ends up running code in fresh Julia sessions. To overcome these limitations, PartitionedArrays provides a data-oriented parallel execution model that allows one to implement parallel algorithms in a generic way, independently of the underlying message passing software that is eventually used at the production stage. At this moment, the library provides two backends for running the generic parallel algorithms: a sequential backend and an MPI backend. In the former, the parallel data structures are logically parallel from the user perspective, but they are stored in a conventional (sequential) Julia session using standard serial arrays. The sequential back end does not mean to distribute the data in a single part. The data can be split in an arbitrary number of parts, but they are processed one after the other in a standard Julia sequential process. This configuration is specially handy for developing new parallel codes. The sequential backend runs in a standard Julia session and one can use tools like Revise and Debugger, which dramatically improves the developer experience. Once the code works with the sequential backend, it can be automatically deployed in a supercomputer via the MPI backend. In the latter case, the data layout of the distributed vectors and sparse matrices is compatible with the linear solvers provided by libraries like PETSc or MUMPS. This allows one to use these libraries for solving large systems of linear algebraic equations efficiently until competitive Julia alternatives are available. The API of PartitionedArrays allows the programmer to write efficient parallel algorithms since it enables fine control over data exchanges. In particular, asynchronous communication directives are provided, making possible to overlap communication and computation. This is useful, e.g., to efficiently implement the distributed sparse matrix-vector product, where the product on the owned entries can be overlapped with the communication of the off-processor vector components. Application codes using PartitionedArrays such as the parallel finite element library GridapDistributed have shown excellent strong and weak scaling results up to tends of thousands of CPU cores. In the near future, we plan to add hierarchical/multilevel parallel data structures to the library to extend its support to multilevel parallel algorithms such as multigrid, multilevel domain decomposition, and multilevel Montecarlo methods.  In this talk, we will provide an overview of the main components of the library and show users how to get started by means of simple examples. PartitionedArrays can be easily installed from the official Julia language package registry and it is distributed with an MPI licence.",recording_license:"",do_not_record:!1,persons:[{id:4053,code:"TJKSVY",public_name:"Francesc Verdugo",biography:"Assistant Professor at the Computer Science Department at VU Amsterdam.",answers:[]},{id:18370,code:"UX89E7",public_name:"ALBERTO FRANCISCO MARTIN HUERTAS",biography:"https://research.monash.edu/en/persons/alberto-f-martin",answers:[]}],links:[],attachments:[],answers:[]},{id:18173,guid:"8a71e7ed-b7f0-55a8-b426-831b3481374b",logo:"",date:"2022-07-28T16:40:00+00:00",start:"16:40",duration:"00:10",room:"Red",slug:"juliacon-2022-18173-calling-julia-from-matlab-using-matdaemon-jl",url:"https://pretalx.com/juliacon-2022/talk/CB3PEY/",title:"Calling Julia from MATLAB using MATDaemon.jl",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"MATLAB is a proprietary programming language popular for scientific computing. Calling MATLAB code from Julia via the C API has been supported for many years via MATLAB.jl. The reverse direction is more complex. One approach is to compile Julia via the C++ MEX API as in Mex.jl. In MATDaemon.jl (https://bit.ly/3JxTFFU), we instead communicate by writing data to .mat files. This method is robust across Julia and MATLAB versions, and easy to use: just download jlcall.m from the GitHub repository.",description:"MATLAB is a popular programming language in the scientific community. Unfortunately, it is proprietary, closed-source, and expensive. Within academia, purchasing MATLAB licenses can feel like a tax on research development, especially given the growing global trends towards open, reproducible, and transparent science. For this reason, many scientists are switching as much as possible to open software development using open-source programming languages such as Python, R, and Julia.\r\n\r\nTransitioning between programming languages can be a daunting task, however. Beyond the obvious requirement of learning a new language, translating and rewriting existing codebases in a new language can be difficult to do in a modular fashion. Modularity is important in order to be able to translate and test as you go. Indeed, it is often not even necessary to translate an entire library to gain nontrivial improvements; for example, by rewriting only performance-critical code paths.\r\n\r\nA convenient way to ease such transitions is through language interoperability. From the Julia side, calling out to the MATLAB C API has been possible for many years using the fantastic `MATLAB.jl` package, made possible by Julia\u2019s support for calling C code. Calling Julia from MATLAB, however, is more complex for several reasons. The first approach one might try is to use Julia\u2019s C API in conjunction with the MATLAB C/C++ MEX API in order to build a MEX \u2013 that is, (M)ATLAB (EX)ecutable \u2013 function which embeds Julia. This is the approach taken by the `Mex.jl` Julia package. When this approach works, it is extremely effective: calling Julia is convenient with little overhead. Unfortunately, writing scripts to compile MEX functions across operating systems and MATLAB versions is notoriously fragile. Indeed, the current version of `Mex.jl` only supports Julia v1.5.\r\n\r\nFor these reasons, we created `MATDaemon.jl` (https://github.com/jondeuce/MATDaemon.jl). This package aims to call Julia from MATLAB in as simple a manner as possible while being robust across both Julia and MATLAB versions \u2013 it should \u201Cjust work\u201D. `MATDaemon.jl` does this by communicating with Julia via writing MATLAB variables to disk as `.mat` files. These variables are then read by Julia using the `MAT.jl` package. The Julia function indicated is then called and the output variables are similarly written to `.mat` files and read back by MATLAB. Naturally, this comes at the cost of some overhead which would not be present when using the MEX approach. In order to alleviate some of the overhead, a Julia daemon is created using the `DaemonMode.jl` package (https://github.com/dmolina/DaemonMode.jl). This helps to avoid Julia startup time by running Julia code on a persistent server. While this package is still not recommended for use in tight performance critical loops due to overhead on the order of seconds, it is certainly fast enough for use in rewriting larger bottlenecks and for interactive use in the MATLAB REPL.\r\n\r\nDue to its simplicity,`MATDaemon.jl` is easy to use: just download the jlcall.m MATLAB function from the GitHub repository (https://github.com/jondeuce/MATDaemon.jl/blob/master/api/jlcall.m) and call Julia. For example, running `jlcall('sort', {rand(2,5)}, struct('dims', int64(2)))` will sort a 2x5 MATLAB double array along the second dimension. A temporary workspace folder `.jlcall` is created containing a local `Project.toml` and `Manifest.toml` file in order to not pollute the global Julia environment. And that\u2019s it! See the documentation in the GitHub repository for example usage, including loading local Julia projects, Base modules, running setup scripts, and more.",recording_license:"",do_not_record:!1,persons:[{id:10487,code:"MJ9ECN",public_name:"Jonathan Doucette",biography:"PhD candidate studying MRI physics at the University of British Columbia.",answers:[]}],links:[],attachments:[],answers:[]},{id:17928,guid:"c2566bc4-f227-5c45-b9d2-947e356cb301",logo:"",date:"2022-07-28T16:50:00+00:00",start:"16:50",duration:"00:10",room:"Red",slug:"juliacon-2022-17928-linearsolve-jl-because-a-b-is-not-good-enough",url:"https://pretalx.com/juliacon-2022/talk/RUQAHC/",title:"LinearSolve.jl: because A\\b is not good enough",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Need to solve Ax=b for x? Then use A\\b! Or wait, no. Don't. If you use that method, how do you swap that out for a method that performs GPU offloading? How do you switch between UMFPACK and KLU for sparse matrices? Krylov subspace methods? What does all of this mean and why is A\\b not good enough? Find out all of this and more at 11. P.S. LinearSolve.jl is the answer.",description:`We tell people that to solve Ax=b, you use A\\b. But in reality, that is insufficient for many problems. For dense matrices, LU-factorization, QR-factorization, and SVD-factorization approaches are all possible ways to solve this, each making an engineering trade-off between performance and accuracy. While with Julia's Base you can use lu(A)\\b, qr(A)\\b, and svd(A)\\b, this idea does not scale to all of the cases that can arise. For example, Krylov subspace methods require you set a tolerance \`tol\`... how do you expect to do that? krylov(A;tol=1e-7)\\b? No, get outta here, the libraries don't support that. And even if they did, this still isn't as efficient as... you get the point.\r
\r
This becomes a major issue with packages. Say Optim.jl uses a linear solve within its implementation of BFGS (it does). Let's say the code is A\\b. Now you know in your case A is a sparse matrix which is irregular, and thus KLU is 5x faster than the UMFPACK that Julia's \\ defaults to. How do you tell Optim.jl to use KLU instead? Oops, you can't. But wouldn't it be nice if you could just pass \`linsolve = KLUFactorization()\` and have it do that? \r
\r
Okay, we can keep belaboring the point, which is that the true interface of linear solvers needs to have many features and performance, and it needs to be a multiple dispatching interface so that it can be used within other packages and have the algorithms swapped around by passing just one type. What a great time for the SciML ecosystem to swoop in! This leads us to LinearSolve.jl, a common interface for linear solver libraries. What we will discuss is the following:\r
\r
- Why there are so many different linear solver methods. What are they used for? When are which ones recommended? Short list: LU, QR, SVD, RecursiveFactorization.jl (pure Julia, and the fastest?), GPU-offload LU, UMFPACK, KLU, CG, GMRES, Pardiso, ...\r
- How do you swap between linear solvers in the LinearSolve.jl interface. It's easy: solve(prob,UMFPACKFactorization()) vs solve(prob,KLUFactorization()).\r
- How do you efficiently reuse factorizations? For example, the numerical factorization stage can be reused when swapping out \`b\` if doing many \`A\\b\` operations. But did know that if A is a sparse matrix you only need to perform the symbolic factorization stage once for each sparsity pattern? How do you do all of this efficiently? LinearSolve.jl has a caching interfaces that automates all of this!\r
- What is a preconditioner? How do you use preconditioners?\r
\r
We will showcase examples where stiff differential equation solving is accelerated by over 20x just by swapping out to the correct linear solvers (https://diffeq.sciml.ai/stable/tutorials/advanced_ode_example/). This will showcase that it's not a small detail, and in fact, every library should adopt this swappable linear solver interface.`,recording_license:"",do_not_record:!1,persons:[{id:904,code:"WUWQQ3",public_name:"Chris Rackauckas",biography:`Research Affiliate and Co-PI of the Julia Lab at the Massachusetts Institute of Technology\r
Director of Modeling and Simulation at Julia Computing and Creator / Lead Developer of JuliaSim\r
Director of Scientific Research at Pumas-AI and Creator / Lead Developer of Pumas\r
Lead Developer of the SciML Open Source Software Organization\r
\r
Chris Rackauckas\r
\r
Chris' research and software is focused on Scientific Machine Learning (SciML): the integration of domain models with artificial intelligence techniques like machine learning. By utilizing the structured scientific (differential equation) models together with the unstructured data-driven models of machine learning, our simulators can be accelerated, our science can better approximate the true systems, all while enjoying the robustness and explainability of mechanistic dynamical models.\r
\r
Chris's recent work is focused on bringing personalized medicine to standard medical practice through the proliferation of software for scientific AI. Chris is at the cutting edge of mathematical methods for scientific simulation. He is the lead developer of the DifferentialEquations.jl solver suite along with over a hundred other Julia packages, earning him the inaugural Julia Community Prize, an outstanding paper award at the IEEE-HPEC conference on computational derivation for the efficient stochastic differential equation solvers, and front page features on many tech community sites. Chris' work on high performance differential equation solving is the engine accelerating many applications from the MIT-CalTech CLiMA climate modeling initiative to the SIAM Dynamical Systems award winning DynamicalSystems.jl toolbox (of which DifferentialEquations.jl was the runner-up). His work is credited for the 15,000x acceleration of NASA Launch Services simulations and recently demonstrated a 60x-570x acceleration over Modelica tools. For these achievements Chris received the United States Department of the Air Force Artificial Intelligence Accelerator Scientific Excellence Award.\r
\r
Chris brought these enhanced numerical approaches to the domain of pharmaceutical modeling and simulation as the creator and lead developer of Pumas. Pumas is scientific AI in clinical practice. Pumas makes it possible to predict the optimal medication dosage for individuals, reducing the costs and potential complications associated with treatments. Pumas is being used by many major pharmasceuticals to predict personalized safe dosage regimens by incorporating realistic biological models (quantitative systems pharmacology) and deep learning into the traditional nonlinear mixed effects (NLME) modeling framework. These efforts on Pumas led to the International Society of Pharmacology's (ISoP) Mathematical and Computational Special Interest Group Award at the American Conference of Pharmacology (ACoP) 2019 for his work on improved clinical dosing via Koopman Expectations, along with the ACoP 2020 Quality Award for his work with Pfizer on GPU-accelerated quantitative systems pharmacology to accelerate preclinical analysis by 175x. Notably, Moderna adopted Pumas in 2020 to accelerate crucial clinical trials, noting "Pumas has emerged as our 'go-to' tool for most of our analyses in recent months". For these achievements, Chris received the Emerging Scientist award from ISoP, the highest early career award in pharmacometrics.\r
\r
Chris started this work while completing his Masters and Ph.D. at the University of California, Irvine where he was awarded the Mathematical and Computational Biology institutional fellowship, the Graduate Dean's Fellowship, the National Science Foundation's Graduate Research Fellowship, the Ford Predoctural Fellowship, the NIH T32 Predoctural Training Grant, the Center for Complex Biological Systesms Opportunity Award, and the Data Science Initiative Summer Fellowship. His research with his advisor, Dr. Qing Nie, focused on the methods for simulating stochastic biological models and detailing how the randomness inherent in biological organisms can be controlled using stochastic analysis. Chris bridged the gap between theory and practice by having a "wet lab bench" in Dr. Thomas Schilling's lab, where these methodologies were tested on zebrafish. Fluorescence Light Microscopy (FLIM) measurements of retinoic acid in the zebrafish hindbrain showed that the predicted control proteins could attenuate inherent biological randomness. The result was a verified mathematical theory for controlling the randomness in biological signaling. Chris received the Kovalevsky Outstanding Ph.D. Thesis Award from the Department of Mathematics upon graduation and was showcased in an interview "Interdisciplinary Case Study: How Mathematicians and Biologists Found Order in Cellular Noise" in Cell Press's iScience.\r
\r
As an undergraduate at Oberlin College, Chris was awarded the NSF S-STEM scholarship and the Margaret C. Etter Student Lecturer Award by the American Crystallographic Association, an award usually given for PhD dissertations, for his work on 3+1 dimensional incommensurate crystal structure identification of H-acid. This award was given for Service Crystallography for its potential impact on industrial dye manufacturing.`,answers:[]}],links:[],attachments:[],answers:[]},{id:17263,guid:"d51ee254-c5af-5053-b731-3bfffc9d4e03",logo:"/media/juliacon-2022/submissions/HCEGRV/CanicasEnRCP_yLvoHXh.png",date:"2022-07-28T17:00:00+00:00",start:"17:00",duration:"00:10",room:"Red",slug:"juliacon-2022-17263-calippso-jl-jamming-of-hard-spheres-via-linear-optimization",url:"https://pretalx.com/juliacon-2022/talk/HCEGRV/",title:"CALiPPSO.jl: Jamming of Hard-Spheres via Linear Optimization",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"The CALiPPSO.jl package implements a new algorithm for producing *disordered* [spheres packings](https://en.wikipedia.org/wiki/Sphere_packing) with very high accuracy. The algorithm reaches the critical jamming point of hard spheres through a chain of constrained linear optimization problems. CALiPPSO.jl exploits the functionality of JuMP for modelling and is thus compatible with several optimizers. In collaboration with C. Artiaco, G. Parisi, and F. Ricci Tersenghi.",description:`You can find the complete description of our algorithm in [this preprint](https://arxiv.org/abs/2203.05654). \r
The package can be installed directly from Julila's package manager, and the documentation is available [here](https://rdhr.github.io/CALiPPSO.jl/dev/index.html)`,recording_license:"",do_not_record:!1,persons:[{id:18108,code:"KJ9YRY",public_name:"Rafael Diaz",biography:'I am a post-doc at "La Sapienza" University of Rome, working in the group of Giorgio Parisi. I mostly study disordered systems like amorphous solids, but I am interested in several topics related to statistical physics. I am Mexican and obtained my BSc and MSc degrees in the National University of Mexico, and then moved to Rome for my PhD.',answers:[]}],links:[],attachments:[],answers:[]},{id:18064,guid:"fba7c046-3715-59f4-a7fd-113fcdad17b2",logo:"",date:"2022-07-28T17:10:00+00:00",start:"17:10",duration:"00:30",room:"Red",slug:"juliacon-2022-18064-writing-a-genericarpack-library-in-julia-",url:"https://pretalx.com/juliacon-2022/talk/7H77WX/",title:"Writing a GenericArpack library in Julia.",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Arpack is a library for computing eigenvalues and eigenvectors of a linear operator. It has been used in many technical computing packages. The goal of the `GenericArpack.jl` package is to create a Julia translation of Arpack. Right now, the Julia `GenericArpack.jl` methods produce _bitwise identical_ results to the `Arpack_jll` methods for Float64 types in all testcases. The new library has zero dependency on BLAS and supports element types beyond those in Arpack, such as `DoubleFloats.jl`.",description:`## Summary of key points\r
\r
Arpack is a library for iteratively computing eigenvalues and eigenvectors of a linear operator. It has been widely used, debugged, and implemented in many technical computing packages. The goal of the \`GenericArpack.jl\` package is to create a Julia translation of the Arpack methods. (Currently, only the symmetric solver has been translated.) \r
\r
The new library has zero dependency on system level BLAS, allowing it to support matrix element types beyond those in Arpack, such as those in \`DoubleFloats.jl\` and \`MultiFloats.jl\`. Other advantages of the \`GenericArpack.jl\` package include thread safety and using Julia features to allow one to optionally avoid the reverse communication interface. Despite not using the system BLAS, the goal was to make the Julia output equivalent to an alternative compilation of the Arpack source code for \`Float64\` types. \r
\r
An anticipated future use is using the \`GenericArpack.jl\` package to give WebASM Julia implementations tools for iterative eigensolvers. This would enables a wide variety of in-browser analysis including finite element, pseudospectra, and spectral graph theory. \r
\r
## Talk overview\r
\r
The talk will discuss some interesting challenges that arose:\r
\r
- representing state information in Julia for the statically located Fortran \`save\` variables in Arpack.\r
\r
- sensitivity to the \`norm\` operation and implementing an exact replacement for the OpenBLAS \`dnrm2\` on x86 architectures that uses 80-bit floating point features of x86 CPUs (without calling the OpenBLAS function)\r
\r
- getting the same random initialization vectors as Arpack (i.e. porting the Fortran \`dlarnv\` function)\r
\r
- designing an interface that allows us to compare results between \`Arpack_jll\` and \`GenericArpack.jl\` at internal methods in Arpack call chains.  \r
\r
- how much code it took to translate the symmetric eigensolver to a Hermitian eigensolver (which is not in Arpack)\r
\r
It will also discuss some tools created that may be useful elsewhere\r
\r
- a tridiagonal eigensolver that only computes a single row of the eigenvector matrix (the Arpack \`dstqrb\` function)\r
\r
- allocation analysis that automatically runs, parses output, and cleans up after a \`track-allocations\` run of Julia\r
\r
- Julia implementations of a few LAPACK/BLAS functions and the details needed to match bitwise match OpenBLAS calls (on MacOS)\r
\r
## Initial rough talk slide ideas\r
\r
- teaser: the world's most precise estimate of the largest few singular values of the netflix ratings matrix. (100M non-zeros) ... or something similar.\r
\r
- reveal: the code... using GenericArpack; svds(...) \r
\r
- pitch: A dropin replacement for Arpack.jl (for symmetric problems). \r
\r
- what is Arpack and why is it important? \r
\r
- Arpack and reverse communication. \r
\r
- summary of project goals: why _translation, same input/same output_ and not something else (new algorithms, etc.), also why minimal dependencies. \r
\r
- basic translation approach: an exercise in @view / sub-arrays. \r
\r
- getting bitwise identical output -- the Lanczos/Arnoldi information seems close, but somewhat different from Arpack\r
	- key issue: well, turns out this is _very_ sensitive to the norm function. \r
	- real problem: OpenBlas norm uses 80-bit FP operations. (And why they can get away with sqrt(sum(x.^2)) and you can't!)\r
	- solution 1: use double-double to simulate! (but it's slow)\r
	- solution 2: just use ideas from \`BitFloats.jl\` and llvm intrinsics instead\r
\r
- So, I've written everything, it passes tests, etc. Why does it use _so_ many allocations? (When it should use zero, like the Fortran code!)\r
- tools for hunting down allocations. (well, really just parsing track-allocation output)\r
- A curiosity: why does the line \`while true\` allocate? \r
- I wish there was a "strict" mode that doesn't allow quite so much flexibility. \r
\r
- because we can: from Arpack \`ido\` (really what you the user do!) to Julia idonow to avoid reverse communication.\r
\r
- because we can: going from symmetric real-valued Arpack methods to Hermitian complex-valued methods (which do not exist in Arpack)\r
\r
- because someone will ask: comparing performance. This will show the current state of performance. At the moment, for a problem Arpack solves in 15ms, GenericArpack.jl takes 23ms; although there has been only minor performance tuning. \r
\r
- A list of future work. Portion the non-Hermitian complex valued case; an "AbstractEigenspace.jl" package that multiple people could implement; Handling differences. \r
\r
- The vision: Why this would be super useful. Iterative Eigenvalues in the browser for Pluto.jl running via WebASM...  for really cool demos akin to pseudospectra... for finite elements in the browser ... for interactive spectral graph analysis in the browser... for mixed precision Arpack computations (Lanczos/Arnoldi info in high-precision, vectors in low-precision).`,recording_license:"",do_not_record:!1,persons:[{id:18433,code:"LTHEEK",public_name:"David Gleich",biography:"David Gleich is an associate professor of computer science at Purdue University.",answers:[]}],links:[],attachments:[],answers:[]},{id:18127,guid:"c96592e8-cb88-5d64-b33e-f7f411b44293",logo:"",date:"2022-07-28T19:00:00+00:00",start:"19:00",duration:"00:30",room:"Red",slug:"juliacon-2022-18127-onlinesampling-online-inference-on-reactive-models",url:"https://pretalx.com/juliacon-2022/talk/PFHGSD/",title:"OnlineSampling : online inference on reactive models",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:`OnlineSampling.jl is a Julia package for online Bayesian inference on reactive models, i.e., streaming probabilistic models.\r
\r
Online sampling provides 1) a small macro based domain specific language to describe reactive models and 2) a semi-symbolic inference algorithm which combines exact solutions using Belief Propagation for trees of Gaussian random variables, and approximate solutions using Particle Filtering.`,description:`[OnlineSampling](https://github.com/wazizian/OnlineSampling.jl) is a probabilistic programming language that focuses on reactive models, i.e., streaming probabilistic models based on the synchronous model of execution.\r
Programs execute synchronously in lockstep on a global discrete logical clock.\r
Inputs and outputs are data streams, programs are stream processors.\r
For such models, inference is a reactive process that returns the distribution of parameters at the current time step given the observations so far.\r
\r
## Synchronous Reactive Programming\r
\r
We use Julia's macro system to program reactive models in a style reminiscent of synchronous dataflow programming languages.\r
\r
A stream function is introduced by the macro \`@node\`.\r
Inside a \`node\`, the macro \`@init\` can be used to initialize a variable.\r
Another macro \`@prev\` can then be used to access the value of a variable at the previous time step.\r
\r
Then, the macro \`@nodeiter\` turns a node into a Julia iterator which unfolds the execution of a node and returns the current value at each step.\r
\r
For examples, the following function \`cpt\` implements a simple counter incremented at each step, and prints its value\r
\r
\`\`\`julia\r
@node function cpt() \r
    @init x = 0 \r
    x = @prev(x) + 1 \r
    return x\r
end\r
\r
for x in @nodeiter T = 10 cpt() \r
    println(x)\r
end\r
\`\`\`\r
\r
\r
## Reactive Probabilistic Programming\r
\r
Reactive constructs \`@init\` and \`@prev\` can be mixed with probabilistic constructs to program reactive probabilistic models.\r
\r
Following recent probabilistic languages (e.g., Turing.jl), probabilistic constructs are the following:\r
- \`x = rand(D)\` introduces a random variable \`x\` with the prior distribution \`D\`.\r
- \`@observe(x, v)\` conditions the models assuming the random variable \`x\` takes the value \`v\`.\r
\r
For example, the following example is a HMM where we try to estimate the position of a moving agent from noisy observations.\r
\r
\`\`\`julia\r
speed = 1.0\r
noise = 0.5\r
    \r
@node function model()\r
    @init x = rand(MvNormal([0.0], ScalMat(1, 1000.0))) # x_0 ~ N(0, 1000)\r
    x = rand(MvNormal(@prev(x), ScalMat(1, speed)))     # x_t ~ N(x_{t-1}, speed)\r
    y = rand(MvNormal(x, ScalMat(1, noise)))            # y_t ~ N(x_t, noise)\r
    return x, y\r
end\r
@node function hmm(obs)\r
    x, y = @nodecall model()\r
    @observe(y, obs) # assume y_t is observed with value obs_t \r
    return x\r
end\r
\r
steps = 100\r
obs = rand(steps, 1)\r
cloud = @nodeiter particles = 1000 hmm(eachrow(obs)) # launch the inference with 1000 particles (return an iterator)\r
\r
for (x, o) in zip(cloud, obs)                            \r
    samples = rand(x, 1000)                                    # sample the 1000 values from the posterior     \r
    println("Estimated: ", mean(samples), " Observation: ", o)\r
end\r
\`\`\`\r
\r
\r
## Semi-symbolic algorithm\r
\r
The inference method is a Rao-Blackwellised particle filter, a semi-symbolic algorithm which tries to analytically compute closed-form solutions, and falls back to a particle filter when symbolic computations fail.\r
For Gaussian random variables with linear relations, we implemented belief propagation if the factor graph is a tree. \r
As a result, in the previous HMM example, belief propagation is able to recover the equation of a Kalman filter and compute the exact solution and only one particle is necessary as shown below.\r
\r
\`\`\`julia\r
cloud = @noderun particles = 1 algo = belief_propagation hmm(eachrow(obs)) # launch the inference with 1 particles for all observations\r
d = dist(cloud.particles[1])                                               # distribution for the last state\r
\`\`\`\r
\r
## Internals\r
This package relies on Julia's metaprogramming capabilities. \r
Under the hood, the macro \`@node\` generates a stateful stream processor which closely mimic the \`Iterator\` interface of Julia. The state correspond to the memory used to store all the variables accessed via \`@prev\`.\r
\r
The heavy lifting to create these functions is done by a Julia macro which acts on the Abstract Syntax Tree. The transformations at this level include, for \`t > 0\`, adding the code to retrieve the previous internal state, update it and return it.\r
\r
However, some transformations are best done at a later stage of the Julia pipeline. \r
One of them is the handling of calls to \`@prev\` during the initial step \`t = 0\`.\r
To seamlessly handle the various constructs of the Julia language, these calls are invalidated at the level of Intermediate Representation (IR) thanks to the package \`IRTools\`.\r
\r
Another operation at the IR level is the automatic realization of a symbolic variable undergoing an unsupported transform: when a function is applied to a random variable and there is no method matching the variable type, this variable is automatically sampled. \r
\r
We also provide a "pointer-minimal" implementation of belief propagation: during execution when a random variables is not referenced anymore by the program, it can be freed by the garbage collector (GC).`,recording_license:"",do_not_record:!1,persons:[{id:18455,code:"9WJ7KH",public_name:"Wa\xEFss Azizian",biography:"Phd student at ENS Paris & Universit\xE9 Grenoble Alpes",answers:[]},{id:18476,code:"C7FG3K",public_name:"marc lelarge",biography:`Dr. Lelarge is a researcher at INRIA in the DYOGENE Research team which is part of the computer science department of Ecole Normale Superieure, (Paris, France). He is also a lecturer in deep learning at Ecole Polytechnique (Palaiseau, France) and Ecole Normale Superieure. He graduated from Ecole Polytechnique, qualified as an engineer at Ecole Nationale Superieure des Telecommunications (Paris) and received a PhD in Applied Mathematics from Ecole Polytechnique in 2005. His research interests include machine learning, deep learning, graphs and data analytics.\r
Dr. Lelarge received the NetGCoop 2011 Best Paper Award with his PhD student E. Coupechoux, was awarded the 2012 SIGMETRICS rising star researcher award and the 2015 Best Publication in Applied Probability Award with Mohsen Bayati and Andrea Montanari for their work on compressed sensing.`,answers:[]},{id:18483,code:"N8GRVN",public_name:"Guillaume Baudart",biography:`Researcher at Inria Paris and \xC9cole normale sup\xE9rieure.\r
Previously research staff member at the IBM T.J. Watson research center.`,answers:[]}],links:[],attachments:[],answers:[]},{id:18025,guid:"8adec99f-892b-5cdd-bba6-d5c63ab2ecc7",logo:"/media/juliacon-2022/submissions/YBH93M/program_figure.001_0nteiDR.png",date:"2022-07-28T19:30:00+00:00",start:"19:30",duration:"00:10",room:"Red",slug:"juliacon-2022-18025-dynamical-low-rank-approximation-in-julia",url:"https://pretalx.com/juliacon-2022/talk/YBH93M/",title:"Dynamical Low Rank Approximation in Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"We present LowRankArithmetic.jl and LowRankIntegrators.jl. The conjunction of both packages forms the backbone of a computational infrastructure that enables simple and non-intrusive use of dynamical low rank approximation for on-the-fly compression of large matrix-valued data streams or the approximate solution of otherwise intractable matrix-valued ODEs. We showcase the utility of these packages for the quantification of uncertainty in scientific models.",description:`Many scientific computing problems boil down to solving large matrix-valued ordinary differential equations (ODE); prominent examples for that are the propagation of uncertainties through (partial-)differential equation models or on-the-fly compression of large-scale simulation or experimental data. While the naive integration of such matrix-valued ODEs often remains prohibitively expensive, it is in many cases found that their solution admit an accurate low-rank approximation. Exploiting such a low rank structure generally holds the potential for substantial computational resource savings (time and memory) over naive integration approaches, often recovering the tractability of integration. \r
\r
Dynamical low rank approximation (DLRA), a concept also known under the names Dirac-Fraenkel time-varying variational principle or dynamically orthogonal schemes, seeks to exploit the low-rank structure of the solution of matrix-valued ODEs by performing the integration within the manifold of fixed (low-)rank matrices.  However, while theoretically elegant, the effective use of DLRA in practice is often cumbersome due to the need for custom implementations of integration routines that take advantage of the assumed low-rank structure. To alleviate this limitation, we present the packages LowRankArithmetic.jl and LowRankIntegrators.jl. The conjunction of both packages forms the backbone of a computational infrastructure that enables simple and non-intrusive use of DLRA. To that end, LowRankArithmetic.jl facilitates the propagation of low rank matrix representations through finite compositions of a rich set of algebraic operations, alleviating the need for custom implementations. Based on this key functionality, LowRankIntegrators.jl implements state-of-the-art integration routines for DLRA that automatically take advantage of low rank structure; the user needs to supply nothing more than the the right-hand-side of a matrix-valued ODE of interest. \r
\r
In this talk, we briefly review the conceptual idea behind DLRA, outline the primitives underpinning LowRankArthmetic.jl and LowRankIntegrators.jl, and showcase their utility for the propagation of uncertainties through scientific models ranging from stochastic PDEs to the chemical master equation.`,recording_license:"",do_not_record:!1,persons:[{id:10514,code:"39MLZ3",public_name:"Flemming Holtorf",biography:"Flemming is a PhD student at MIT working on computational techniques for uncertainty quantification and optimization under uncertainty.",answers:[]}],links:[],attachments:[],answers:[]},{id:17986,guid:"7dc7c014-ba3e-5955-b295-ff0ab6fa2a55",logo:"",date:"2022-07-28T19:40:00+00:00",start:"19:40",duration:"00:10",room:"Red",slug:"juliacon-2022-17986-visualization-dashboards-with-pluto-",url:"https://pretalx.com/juliacon-2022/talk/SQJTRS/",title:"Visualization Dashboards with Pluto!",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`Data visualization with intuitive interactions is an essential feature of many scientific investigations. I propose to go over use cases and examples on why/how to develop reactive dashboards in Julia using "Pluto.jl". Pluto provides a way to isolate cells in a separate page of which the style is editable as regular HTML/CSS. Alongside PlutoUI's experimental layout feature, this is a powerful tool to create immersive interactive experiences for users.`,description:"In Python, one could assemble a Jupyter notebook to experiment with visualizations and turn it into a Dash dashboard with multiple plots, panes, and widgets. In R, someone could do the same with RShiny. Julia has support for Dash and Jupyter, but one could argue that dashboarding and experimentation should be part of the same workflow. Pluto's solution to this problem is complete and extensible, which is every scientist's dream.",recording_license:"",do_not_record:!1,persons:[{id:10230,code:"V8B8TS",public_name:"Guilherme Gomes Haetinger",biography:"I am a Computer Science MSc. student at the *Universidade Federal do Rio Grande do Sul*. My interests hop around the fields of Operating Systems, Algorithm Design, Computer Graphics and Image Processing. Currently, I am working as a Back End Development intern at DeepX , using Elixir and Rust. I've been using Julia for a couple of years in order to get fast image processing results with easy-on-the-eyes code. I'm currently working at Julia Computing developing visualizations to help ML workflows.",answers:[]}],links:[],attachments:[],answers:[]},{id:17990,guid:"048d9584-2707-5e88-b06a-00594c8c794f",logo:"/media/juliacon-2022/submissions/VVPY9G/JuliaCon_2022_Talk_Image_BtwALWa.png",date:"2022-07-28T19:50:00+00:00",start:"19:50",duration:"00:10",room:"Red",slug:"juliacon-2022-17990-visualizing-astronomical-data-with-astroimages-jl",url:"https://pretalx.com/juliacon-2022/talk/VVPY9G/",title:"Visualizing astronomical data with AstroImages.jl",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"To study the cosmos, astronomers examine images captured of light exceeding human-visible colors and dynamic range. AstroImages.jl makes it easy to load, manipulate, and visualize astronomical data intuitively and efficiently using arbitrary color-schemes, stretched color scales, RGB composites, PNG rendering, and plot recipes. Come to our talk to see how you too can create beautiful images of the universe!",description:`To study the cosmos, astronomers use data cubes with many dimensions representing images with axes for sky position, time, wavelength, polarization, and more. Since these large datasets often span many orders of magnitude in intensity and typically include colours invisible to humans, astronomers like to visualize their images using a variety of non-linear stretching and contrast adjustments.\r
Additionally, images may contain metadata specifying arbitrary mappings of pixel positions to multiple celestial coordinate systems.\r
Julia is a powerful language for processing astronomical data, but these visualization tasks are a challenge for any tool. Built on Images, DimensionalData, FITS, WCS, and Plots, AstroImages.jl makes it easy to load, manipulate, and visualize astronomical data intuitively and efficiently with support for arbitrary colorschemes, stretched color scales, RGB composites, lazy PNG rendering, and plot recipes.\r
Come to our talk to see how you too can create beautiful images of the universe!`,recording_license:"",do_not_record:!1,persons:[{id:10488,code:"BHARS7",public_name:"William Thompson",biography:`Astronomy PhD candidate and Julia Enthusiast at the University of Victoria.\r
Maintainer of PairPlots.jl`,answers:[]}],links:[],attachments:[],answers:[]},{id:17890,guid:"f52e2153-4fa9-5dda-943f-e27bbc6d8bac",logo:"",date:"2022-07-28T20:00:00+00:00",start:"20:00",duration:"00:10",room:"Red",slug:"juliacon-2022-17890-microbiome-jl-biobakeryutils-jl-for-analyzing-metagenomic-data",url:"https://pretalx.com/juliacon-2022/talk/PXRENJ/",title:"Microbiome.jl & BiobakeryUtils.jl for analyzing metagenomic data",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Microbiome.jl is a Julia package to facilitate analysis of microbial community data. BiobakeryUtils.jl is built on top of Microbiome.jl, and provides utilities for working with a suite of command line tools (the bioBakery) that are widely used for converting raw metagenomic sequencing data into tables of taxon and gene function counts. Together, these packages provide an effective way to link microbial community data with the power of Julia\u2019s numerical, statistical, and plotting libraries.",description:"",recording_license:"",do_not_record:!1,persons:[{id:18267,code:"JURY3H",public_name:"Anika Luo",biography:"I am a Biochemistry major and Music minor at Wellesley College, and I plan to pursue a Ph.D. in Biomedical Sciences. My career goal is to conduct research in biomedical science and advance the field of pharmaceutical medicine. As an undergraduate researcher in the Klepac-Ceraj Lab, I have worked on various engineering and computational projects with Dr. Kevin Bonham in which I have built tools to study microbial communities and to streamline analysis of metagenomic data. My current project investigates a method of using gut microbes to restore normal function in neurotransmitter deficient Caenorhabditis elegans, which may have important therapeutic implications for neurological conditions.",answers:[]},{id:17459,code:"JAMMRT",public_name:"Kevin Bonham",biography:"Senior research scientist at Wellesley College, studying the human microbiome and its effects on cognitive development.",answers:[]},{id:18270,code:"MHQTLH",public_name:"Annelle Kayisire Abatoni",biography:"I am a Biology and Media Arts and Sciences double major, and I am particularly interested in the intersection of computational design and biological concepts. I am currently working on finding out and creatively exhibiting the microbial composition of Wellesley\u2019s greenhouse, the Global Flora and exploring their different functions. In the past, I\u2019ve worked on developing a software package that manipulates and analyzes microbial community data. After college, I hope to keep working with computational modeling tools to better understand biological systems. Outside of lab and school, I enjoy playing tennis and spending time with my friends.",answers:[]}],links:[],attachments:[],answers:[]},{id:18101,guid:"5fa11e6f-fb45-5416-aeb3-ad6a92ec1101",logo:"/media/juliacon-2022/submissions/FLB8G9/cutebanner_0Bjgd4Z.png",date:"2022-07-28T20:10:00+00:00",start:"20:10",duration:"00:10",room:"Red",slug:"juliacon-2022-18101--pluto-jl-recordings-a-crazy-new-video-format",url:"https://pretalx.com/juliacon-2022/talk/FLB8G9/",title:"\u{1F388} Pluto.jl Recordings \u2014 a crazy new video format",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"[Pluto.jl](https://github.com/fonsp/Pluto.jl) has a new Recording feature, a hybrid format between traditional video and interactive Pluto-web-magic!",description:`Pluto Recordings can be made directly from the Pluto interface, and making a recording feels a lot like recording a screen capture with Zoom. But there are some exciting differences:\r
- Much smaller file format, > 4K resolution!\r
- Video is **responsive**: it looks great on all screen sizes, from mobile to desktop.\r
- While watching a recording, you can **scroll around** the notebook to read hidden sections. You are not bound to the recorder's viewport.\r
- The video is **executable**\r
\r
This experimental new feature is great for education, and you can start using it in your course! It also opens the door even more advanced "hybrid" web-video ideas, which we will discuss in the talk!`,recording_license:"",do_not_record:!1,persons:[{id:4400,code:"ECC83Q",public_name:"Fons van der Plas",biography:"Excited about making scientific computing more accessible and fun! Looking forward to meet you!",answers:[]}],links:[],attachments:[],answers:[]}],Purple:[{id:18066,guid:"1d04054f-876b-5e5d-a8df-81ca6695ad32",logo:"",date:"2022-07-28T12:30:00+00:00",start:"12:30",duration:"00:30",room:"Purple",slug:"juliacon-2022-18066-a-guided-tour-through-julia-s-front-end",url:"https://pretalx.com/juliacon-2022/talk/KMHPFT/",title:"A Guided Tour Through Julia's Front End",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:'Although many Julia users may be familiar with functions such as `Meta.parse` and `code_lowered`, not many are familiar what actually goes on under the hood. In this talk, I aim to decipher words such as "lexing", "parsing", "lowering", and "macro expansion" and I will explain how Julia translates the literal code you write into something type inference and the optimizer understands.',description:`My motivation for giving this talk is that there have been several talks at past JuliaCons touching various parts of Julia's compilation pipeline, but they have mostly been about the stages after lowering. I think this is a bit of a shame, since the intuitive and powerful surface syntax is a big part of what draws users to Julia \u2013 not to talk about its meta programming capabilities. Julia also inherited a lot of its syntax decisions from the Lisp family of languages and I will explain what that means for the language.\r
\r
I will also give some tips and tricks on how users can tinker with the actual code themselves using a bit of rudimentary Scheme. Lastly, I plan on touching on future directions for Julia's front end with a potential pure-Julia implementation in [JuliaSyntax.jl](https://github.com/c42f/JuliaSyntax.jl) on the horizon.`,recording_license:"",do_not_record:!1,persons:[{id:18434,code:"XRD9WL",public_name:"Simeon",biography:"I am currently a master's student in Computational Science and Engineering at the MIT Julia Lab. I have been a Julia user since 2018 and am one of the maintainers of the Julia language. Among other parts of the language, I work on Julia's front end and contribute to packages such as Cthulhu.jl, JuliaInterpreter.jl, and ArtifactUtils.jl.",answers:[]}],links:[],attachments:[],answers:[]},{id:16961,guid:"73b02d4e-29e3-5cc2-a83c-ef1197fb6f45",logo:"",date:"2022-07-28T13:00:00+00:00",start:"13:00",duration:"00:10",room:"Purple",slug:"juliacon-2022-16961-tricks-jl-abusing-backedges-for-fun-and-profit",url:"https://pretalx.com/juliacon-2022/talk/DZNPL9/",title:"Tricks.jl: abusing backedges for fun and profit",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`Tricks.jl is a package that does cool tricks to do more work at compile time.\r
It does this by generating (\`@generated\`) functions that just return "hardcoded" values, and then trigger the generation when (if) that value changes. This retriggering is done using backedges.\r
Tricks.jl can for example declare Tim Holy traits that depend on whether or not a method has been defined\r
[Slides](https://raw.githack.com/oxinabox/TricksJuliaCon2022/main/build/index.html)`,description:`Tricks.jl was made at the JuliaCon 2019 hackathon in Baltimore.\r
Shortly after manual backedges were added to Julia-1.3.\r
But has never been explained at a JuliaCon.\r
\r
This talk is expressly targeted at advanced Julia users wanting to understand on the internals.\r
Attendee's will learn a bunch about backedges, why they exist and how they work.`,recording_license:"",do_not_record:!1,persons:[{id:1095,code:"ECUZBT",public_name:"Frames Catherine White",biography:`Frames White is the lead of the research software engineering group at Invenia.\r
She is also the lead of the ChainRules project, and a major developer of many other Julia projects.`,answers:[]}],links:[],attachments:[],answers:[]},{id:18062,guid:"5578d6e2-6917-5af7-9655-28c7ca5733d6",logo:"",date:"2022-07-28T13:10:00+00:00",start:"13:10",duration:"00:10",room:"Purple",slug:"juliacon-2022-18062-making-abstract-interpretation-less-abstract-in-cthulhu-jl",url:"https://pretalx.com/juliacon-2022/talk/WTPZLZ/",title:"Making Abstract Interpretation Less Abstract in Cthulhu.jl",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Cthulhu.jl is a highly useful tool for performance engineering as well as general debugging of Julia programs. However, as the name implies, one can quickly descend into the abyss that is Julia's compilation pipeline and get lost in the vast amounts of code even modest looking Julia functions may end up generating. I present a combination of Cthulhu.jl with a step-by-step debugger, showing concrete results every step along the type lattice to make compilation more interpretable.",description:`One of the main motivations for this work was the use case of debugging source-to-source automatic differentiation on scientific codes as exemplified by Zygote.jl, which emit code that is significantly more complex than that of the original program. That can make it difficult to correctly identify intermediate steps. This is often complicated by the fact that the more complicated code can lead to results not being inferred to a concrete type anymore.\r
\r
I leverage the already existing infrastructure in JuliaInterpreter.jl to enable explorative analysis of what the code does by interpreting the program based on concrete input values. Because interpretation works on a statement-by-statement basis just as inference does, this allows the user to go back and look at what the interpreter computed for any intermediate steps or see which branch actually ended up being taken.\r
\r
One of the main challenges was the fact that JuliaInterpreter.jl was designed to interpret untyped Julia IR, which has slightly different semantics to IR after inference which again differs from the semantics of IR after all other Julia-specific optimizations such as inlining. A prototype currently exists in https://github.com/JuliaDebug/Cthulhu.jl/pull/214. I plan to introduce a flexible plugin infrastructure for this to be able to develop most of this outside of Cthulhu first. Support for step-by-step execution and for interpreting optimized Julia IR is also being worked on.\r
\r
In this talk I aim to first give an overview on how Cthulhu.jl differs from a debugger and the various advantages and disadvantages of both approaches. I will then explain how I combined the two and how users can take advantage of these new capabilities in their own workflows. While I will be primarily targeting intermediate to advanced Julia users, I believe this could even be of use to those who have not used Cthulhu.jl before, because it allows for a much more interactive exploration of the intricacies of Julia IR.`,recording_license:"",do_not_record:!1,persons:[{id:18434,code:"XRD9WL",public_name:"Simeon",biography:"I am currently a master's student in Computational Science and Engineering at the MIT Julia Lab. I have been a Julia user since 2018 and am one of the maintainers of the Julia language. Among other parts of the language, I work on Julia's front end and contribute to packages such as Cthulhu.jl, JuliaInterpreter.jl, and ArtifactUtils.jl.",answers:[]}],links:[],attachments:[],answers:[]},{id:17234,guid:"09b44de7-4d52-587c-bb9d-b85f9a47fc36",logo:"",date:"2022-07-28T13:20:00+00:00",start:"13:20",duration:"00:10",room:"Purple",slug:"juliacon-2022-17234-reducing-running-time-and-time-to-first-x-a-walkthrough",url:"https://pretalx.com/juliacon-2022/talk/LJHYAQ/",title:"Reducing Running Time and Time to First X: A Walkthrough",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"Optimizing Julia isn't hard if you compare it to Python or R where you have to be an expert in Python or R and C/C++. I'll describe what type stability is and why it is important for performance. I'll discuss it in the context of performance (raw throughput) and in the context of time to first X (TTFX). Julia is sort of notorious for having really bad TTFX in certain cases. This talk explains the workflow that you can use to reduce running time and TTFX.",description:"",recording_license:"",do_not_record:!1,persons:[{id:10019,code:"JHBKNM",public_name:"Rik Huijzer",biography:"I'm a PhD student at the University of Groningen and co-author of the Julia Data Science book. I think that Julia solves a lot of problems that other languages have, so that's why I like contributing to the language ecosystem. To this end, I have created the Books.jl, PowerAnalyses.jl, Skans.jl and PlutoStaticHTML.jl packages and I contributed to Turing, MLJ, Pluto, julia-actions and more.",answers:[]}],links:[],attachments:[],answers:[]},{id:16792,guid:"670b1223-bc34-5724-8e18-5bc599ece6cf",logo:"",date:"2022-07-28T13:30:00+00:00",start:"13:30",duration:"00:10",room:"Purple",slug:"juliacon-2022-16792-garbage-collection-in-julia-",url:"https://pretalx.com/juliacon-2022/talk/8VQAAD/",title:"Garbage Collection in Julia.",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Garbage collection is one of those productivity tools that you don't think about until you need to.  We will discuss the current state of Julia GC and what can be done to make it better.",description:`"Garbage collection is like an omniscient housekeeper who can go through your things getting rid of those that you will never use and making more room for the things you need."\r
\r
Most programmers are happy to have the memory management issues handled for them right up until the point that they aren't.  Then they start trying to do unnatural things, like reusing arrays, creating off heap storage, or turning off GC all together.  \r
\r
This talk will focus on the internals of the current Julia collector, and what we can do to make things better.`,recording_license:"",do_not_record:!1,persons:[{id:17737,code:"C9Q9NL",public_name:"Christine Flood",biography:"Christine Flood has worked in academia, industry, and government.  She's worked on commercially successful programming language implementations like java and academically interesting ones like Fortress, Lisp, and Id  She's  now focused on improving memory management performance in Julia.",answers:[]}],links:[],attachments:[],answers:[]},{id:18076,guid:"29d7499c-6954-526f-bf1f-b74e56f215f0",logo:"",date:"2022-07-28T13:40:00+00:00",start:"13:40",duration:"00:10",room:"Purple",slug:"juliacon-2022-18076-parallelizing-julia-s-garbage-collector",url:"https://pretalx.com/juliacon-2022/talk/LXSC3P/",title:"Parallelizing Julia\u2019s Garbage Collector",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:`With the increasing popularity of Julia for memory intensive applications, garbage collection is becoming a performance bottleneck.\r
\r
Julia currently uses a serial mark-and-sweep collector, in which objects are traced starting from a root-set (e.g. thread\u2019s stacks, global variables, etc.) and unreachable objects are then deallocated.\r
\r
We discuss in this talk how we recently parallelized tracing of live Julia objects and the performance improvements we got so far.`,description:"",recording_license:"",do_not_record:!1,persons:[{id:18442,code:"AZ8F99",public_name:"Diogo Netto",biography:"Masters student at MIT Julia Lab.",answers:[]}],links:[],attachments:[],answers:[]},{id:17900,guid:"e785972f-a2f7-54cc-9949-7336cd6fbe4f",logo:"",date:"2022-07-28T13:50:00+00:00",start:"13:50",duration:"00:10",room:"Purple",slug:"juliacon-2022-17900-unbake-the-cake-and-eat-it-too-flexible-and-performant-gc",url:"https://pretalx.com/juliacon-2022/talk/3XBUWE/",title:"Unbake the Cake (and Eat it Too!): Flexible and Performant GC",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"The tension between performance and flexibility is always present when developing new systems. Often, poor performance is unacceptable. But poor flexibility hinders experimentation and evolution, which may lead to bad performance later on. In this talk, we show how we used MMTk.io \u2013 a toolkit we are developing that provides language implementers with a powerful garbage collection framework \u2013 to implement a flexible (unbaking the cake) and performant (and eating it too) memory manager for Julia.",description:`When implementing a system such as a programming language runtime, decisions usually favor performance over flexibility. Lacking performance is often unacceptable but lacking flexibility can hinder experimentation and evolution, which may also affect performance in the long run. Consider memory management, for example. If we ignore flexibility and only favor performance, sticking to a particular type of garbage collector that "performs well" can have a huge effect later on, such that changing any aspect about it can be almost impossible without rewriting the whole system.\r
MMTk.io is a memory management toolkit providing language implementers with a powerful memory management framework and researchers with a multi-runtime platform for memory management research. Instead of a single, monolithic collector, MMTk efficiently implements various garbage collector strategies, increasing flexibility without compromising performance.\r
MMTk started with its original Java implementation, which was integrated into Jikes RVM in 2002. Since then, it has gained a fresh Rust implementation, which is under active development and even though it is not ready for production use, can currently be used experimentally. \r
To use MMTk, one must develop a binding, which contains three artefacts: (i) a logical extension of the VM, (ii) a logical extension of MMTk core, and (iii) an implementation of MMTk's API. At the moment, there are various bindings under development including bindings for V8, OpenJDK, Jikes RVM, Ruby, GHC, PyPy and now Julia.\r
In this talk we discuss our experience developing the MMTk binding for Julia. Julia currently implements a precise non-moving generational garbage collector. It relies on some LLVM features to calculate roots, but the code follows a monolithic approach, as described earlier.\r
We reuse some of Julia's strategies for calculating roots and processing objects, integrating these into an Immix implementation inside MMTk. Our implementation passes all but a few of Julia's correctness tests, and has shown promising results regarding GC performance. We hope that with MMTk-Julia we are able to easily explore different GC strategies, including a partially-moving GC, observing how these strategies affect the language's performance.`,recording_license:"",do_not_record:!1,persons:[{id:18301,code:"RUVAU8",public_name:"Luis Eduardo de Souza Amorim",biography:"With a broad interest in programming language design and implementation, I'm currently a PostDoc at the Australian National University working on memory management and virtual machines. My previous work from my PhD at Delft University of Technology focused on syntax definition formalisms and parsing.",answers:[]}],links:[],attachments:[],answers:[]},{id:17927,guid:"b0858cdd-bc0e-5ceb-8072-74fdf07d9d1e",logo:"",date:"2022-07-28T16:30:00+00:00",start:"16:30",duration:"00:10",room:"Purple",slug:"juliacon-2022-17927-unlocking-julia-s-llvm-jit-compiler",url:"https://pretalx.com/juliacon-2022/talk/NEKFDC/",title:"Unlocking Julia's LLVM JIT Compiler",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Julia's compiler spends almost all of its time generating, optimizing, and compiling LLVM IR. Currently, much of this work is done under one giant lock, which is also held during type inference, reducing compiler throughput in a multithreaded environment. By using finer-grained locking and handling LLVM IR in a threadsafe manner, we can reduce contention of compilation resources. This work also leads into future JIT optimizations such as lazy, parallel, and speculative compilation of Julia code.",description:`Julia's JIT compiler converts Julia IR to LLVM IR, optimizes it, and converts it to machine code for efficient subsequent execution. However, much of this process relies on shared global resources, such as a global LLVM context, the pass manager that runs the optimization, and various data caches. This has necessitated the presence of a global lock to prevent multiple threads from simultaneously modifying this data. Furthermore, as generation of LLVM IR and type inference may co-recurse indefinitely, type inference also acquires and holds the same lock during its execution. This serialized compilation process increases the startup time of multithreaded environments (often referred to as time-to-first-plot, TTFP) and prevents our execution environment from performing more complex transformations, such as speculative and parallel compilation. \r
\r
Thus far, refactorings of our IR generation pipeline have reduced the number of global variables used in the compiler and added finer grained locks to our JIT stack in preparation for removing the global locks. At this stage, much of the remaining challenge in removing the global lock is in proving thread safety and progressively reducing the scope of the lock until the minimum amount of critical code is protected. Once that work has completed, work on speculative optimization and IR generation can begin, which should bring additional improvements to TTFP for situations without multiple contending compilation threads.`,recording_license:"",do_not_record:!1,persons:[{id:18337,code:"CVAUHS",public_name:"Prem Chintalapudi",biography:"M. Eng. student at MIT",answers:[]}],links:[],attachments:[],answers:[]},{id:17880,guid:"25a32ede-4906-5bd0-9d60-dbbc9318f381",logo:"",date:"2022-07-28T16:40:00+00:00",start:"16:40",duration:"00:10",room:"Purple",slug:"juliacon-2022-17880-metal-jl-a-gpu-backend-for-apple-hardware",url:"https://pretalx.com/juliacon-2022/talk/AAJJGP/",title:"Metal.jl - A GPU backend for Apple hardware",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"In this talk, updates on the development of a GPU backend for Apple hardware (specifically the M-series chipset) will be presented along with a brief showcase of current capabilities and interface. The novel compilation flow will be explained and compared to the other GPU backends as well as the benefits and limitations of both a unified memory model and Apple's Metal capabilities. A brief overview of Apple's non-GPU hardware accelerators and their potential will also be discussed.",description:"The release of Apple's M-series chipset brings new hardware into play for Julia to target. Base CPU functionality is already highly used within the community, but so far, the M1 chip's hardware accelerators have primarily been inaccessible to Julia programmers. Metal.jl has been developed as a GPU backend (like CUDA./, AMD.jl, and oneAPI.jl) specifically targeting the M-series GPUs. Given Apple's continued expansion of the M1 chipset and devotion to hardware accelerators, a Julia interface targeting these compute devices is becoming increasingly beneficial.",recording_license:"",do_not_record:!1,persons:[{id:18004,code:"ZK9JBM",public_name:"Max Hawkins",biography:"Max is an undergraduate Computer Engineering student at the University of Alabama interested in helping scientists easily and effectively utilize their computing hardware.",answers:[]},{id:2402,code:"9YQMAK",public_name:"Tim Besard",biography:"Tim Besard is a software engineer at Julia Computing, working on GPU support for the Julia language. He holds a Ph.D. in computer science engineering from Ghent University, Belgium, for research on abstractions to program hardware accelerators in high-level programming languages.",answers:[]}],links:[],attachments:[],answers:[]},{id:18174,guid:"1e2c0d4a-131b-5985-9564-84a7ebcfcd85",logo:"",date:"2022-07-28T16:50:00+00:00",start:"16:50",duration:"00:10",room:"Purple",slug:"juliacon-2022-18174-arrayallocators-jl-arrays-via-calloc-numa-and-aligned-memory",url:"https://pretalx.com/juliacon-2022/talk/SE8MEL/",title:"ArrayAllocators.jl: Arrays via calloc, NUMA, and aligned memory",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"ArrayAllocators.jl uses the standard array interface to allow faster `zeros` with `calloc`, allocation on specific NUMA nodes on multi-processor systems as well as aligned memory. The allocators are given as an argument to `Array{T}` in place of `undef`. Overall, this allows Julia to match the allocation performance of popular numerical libraries such as NumPy, which uses some of these techniques.\r\nIn this talk, we will also explore some of the unexpected properties of these allocation methods.",description:"Julia offers an extensible array interface that allows array types to wrap around C pointers obtained from specialized or operating system specific application programming interfaces while integrating into the garbage collection system. ArrayAllocators.jl uses this array interface to allow faster `zeros` with `calloc`, allocation on specific NUMA nodes on multi-processor systems, and the allocation of aligned memory for vectorization. The allocators are given as an argument to `Array{T}` or other subtypes of `AbstractArray` in place of the `undef` initializer to provide a familiar interface to the user. In this talk, I will describe how to use ArrayAllocators.jl to optimize applications via `calloc`, NUMA, and aligned memory.\r\n\r\nThe easy availability of these allocation methods allows Julia to match the performance and caveats of other libraries or code that uses these methods. For example, NumPy's implementation of `numpy.zeros` uses `calloc` by default which may make it appear that NumPy is out performing Julia for certain microbenchmarks. On some operating systems, the initial allocation is significantly faster than explicitly filling the array with zeros as is currently done in `Base` since the operating system may defer the actual allocation of the memory until a later time. Often the initial allocation time is similar to the allocation time of `undef` arrays.\r\n\r\nAnother application is to make Julia NUMA-aware by allocating memory on specific NUMA nodes.  I will demonstrate how to optimize the performance of common memory operations on systems with multiple NUMA nodes on modern processors, which may be counter-intuitive.\r\n\r\nA final application is to align memory to power-of-two byte boundaries. This is useful to assist advanced vectorization applications where 64-byte aligned memory may accelerate the use of AVX-512 instructions.\r\n\r\nFinally, I will discuss the integer overflow features of ArrayAllocators.jl and how other packages may extend ArrayAllocators.jl to easily add new ways of allocating memory for arrays.\r\n\r\nIn summary, ArrayAllocators.jl and its subpackages provide a familiar mechanism to allocate memory for arrays via low level methods in a familiar manner. This allows Julia programs to take advantage of advanced operating system features that may accelerate the initialization and use of the memory.",recording_license:"",do_not_record:!1,persons:[{id:10421,code:"USMVVE",public_name:"Mark Kittisopikul, Ph.D.",biography:`I am a Software Engineer II in Scientific Computing at the Janelia Research Campus of the Howard Hughes Medical Institute. My stated opinions are my own and not of my employer.\r
\r
I earned my PhD at UT Southwestern Medical Center studying Molecular Biophysics. I have done postdoctoral work in Cellular Biology.\r
\r
I enjoy cycling and being a parent.`,answers:[]}],links:[],attachments:[],answers:[]},{id:18020,guid:"ef6f5a61-abb6-5dc8-8614-82ae8ad1f678",logo:"",date:"2022-07-28T17:00:00+00:00",start:"17:00",duration:"00:30",room:"Purple",slug:"juliacon-2022-18020-compile-time-programming-with-comptime-jl",url:"https://pretalx.com/juliacon-2022/talk/DSB7E3/",title:"Compile-time programming with CompTime.jl",subtitle:"",track:null,type:"Talk",language:"en",abstract:"Inspired by the compile-time features of Zig, we present a CompTime.jl, a package that wraps Julia\u2019s features for generated functions into a seamless interface between compile-time and runtime semantics. The desire for this came from heavy use of @generated functions within Catlab.jl, and we have found that CompTime.jl makes our code more readable, maintainable, and debuggable. We will give a tutorial and then a brief peek into the implementation.",description:"CompTime.jl presents a macro, `@ct_enable`, that can be applied to a function, and provides a DSL within the function to mark parts that should be run at compile time, and parts that should be run at runtime. As with `@generated` functions, the code run at compile time can only depend on the types of the arguments. However, with this macro, arbitrary control structures (for loops, while loops, if statements, etc.) can be run at compile time and \u201Cunrolled\u201D, so that, for instance, only the body of the condition that succeeded in an if statement appears at runtime. Additionally, computation based on types that cannot be itself typechecked very well can be moved to compile time, and what is left to runtime can then be completely type checked, unlocking the power of the Julia compiler to optimize.\r\n\r\nThis does not present any new technical capabilities beyond what is already provided by generated functions; rather, the chief benefit is the many conveniences enabled by moving all the syntax-processing to general functions. For instance, the code generated for a specific set of argument types can be printed out and inspected, and in backtraces the line numbers associated with the generated code are meaningful, pointing to the correct line in the `@ct_enable`-decorated function whether the error happens at runtime or compile time. Thus, the experience of working with generated functions becomes accessible to a Julia user that knows nothing about syntax trees.\r\n\r\nFinally, if all of the CompTime annotations are stripped out of a `@ct_enable`-decorated function, one is left with a perfectly valid Julia function that runs completely at runtime. Thus, in situations where one expects to run the function only a couple times on each new datatype, the first-compile slowdown can be avoided.\r\n\r\nIn this talk, we will present a tutorial of how to use CompTime.jl, accessible to a novice Julia programmer with no previous knowledge of generated functions but of interest to all audiences. Then, at the end of the talk, we will take a peek under the hood of CompTime and show the audience a bit of the frightening delight that is writing code that generates code to generate code. This will mainly be as a fun brain-twister; however, the Julia programmer familiar with macro writing may learn a thing or two of interest.",recording_license:"",do_not_record:!1,persons:[{id:10127,code:"TY8PJL",public_name:"Owen Lynch",biography:"I'm a master's student at Utrecht University, studying probability and thermodynamics, and I also have been contributing to AlgebraicJulia for the last two years.",answers:[]}],links:[],attachments:[],answers:[]},{id:17996,guid:"68d316a9-eaec-5229-bf91-b62a6de1e03b",logo:"",date:"2022-07-28T17:30:00+00:00",start:"17:30",duration:"00:30",room:"Purple",slug:"juliacon-2022-17996-monitoring-performance-on-a-hardware-level-with-likwid-jl",url:"https://pretalx.com/juliacon-2022/talk/DAASVV/",title:"Monitoring Performance on a Hardware Level With LIKWID.jl",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Have you ever wondered how many FLOPS your CPU or GPU actually performs when executing (parts of) your Julia code? Or how much data it has read from main memory or a certain cache? Then this talk is for you! I will present LIKWID.jl (Like I Knew What I'm Doing), a Julia wrapper around the same-named performance benchmarkig suite, that allows you to analyse the performance of your Julia code by monitoring various hardware performance counters sitting inside of your CPU or GPU.",description:`In my talk I will first lay the ground by telling you everything you need to know about hardware performance counters and will then introduce you to LIKWID.jl. Specifically, I will explain how to install LIKWID, how to use LIKWID.jl's Marker API, i.e. how to mark certain regions in your Julia code for performance monitoring, and how to properly run your Julia code under LIKWID. We will then use these techniques to analyse a few illustrative Julia examples running on CPUs and an NVIDIA GPU. Finally, I will discuss potential pitfalls (e.g. when benchmarking multithreaded Julia code) and future plans.\r
\r
Disclaimer: LIKWID.jl works on Linux :) but not on Windows or macOS :(`,recording_license:"",do_not_record:!1,persons:[{id:4153,code:"R3SWQF",public_name:"Carsten Bauer",biography:"Theoretical Physicist - Scientific HPC Advisor - National High Performance Computing (NHR) - Paderborn Center for Parallel Computing (PC\xB2)",answers:[]}],links:[],attachments:[],answers:[]},{id:17969,guid:"f1455e42-f503-570d-930e-8e1a651f6804",logo:"",date:"2022-07-28T19:00:00+00:00",start:"19:00",duration:"00:30",room:"Purple",slug:"juliacon-2022-17969-platform-aware-programming-in-julia",url:"https://pretalx.com/juliacon-2022/talk/DQHQZ8/",title:"Platform-aware programming in Julia",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Heterogeneous computing resources, such as GPUs, TPUs, and FPGAs, are widely used to accelerate computations, or make them possible, in scientific/technical computing. We will talk about how loose addressing of heterogeneous computing requirements in programming language designs affects portability and modularity. We propose contextual types to answer the underlying research questions, where programs are typed by their execution platforms and Julia's multiple dispatch plays an essential role.",description:`The importance of heterogeneous computing in enabling computationally intensive solutions to problems addressed by scientific and technical computing applications is no longer new. In fact, heterogeneous computing plays a central role in the design of high-end parallel computing platforms for exascale computing. For this reason, the Julia community has concentrated efforts to support GPU programming through the JuliaGPU organization. Currently, there are packages that provide the functionality of existing GPU programming APIs, such as OpenCL, CUDA, AMD ROcm, and OneAPI, as well as high-level interfaces to launch common operations on GPUs (e.g. FFT). In particular, OneAPI is a recent cross-industry initiative to provide a unified, standards-based programming model for accelerators (XPUs).\r
\r
In our work, it is convenient to distinguish between package developers and application programmers, where the former provide the high-level functionality necessary for later ones to solve problems of interest to them. Both are interested in performing computations as quickly as possible, taking advantage of hardware features often purchased by application programmers from IaaS cloud providers. Thus, since application programmers prefer packages enabled to exploit the capabilities of the target execution platform, package developers are interested in optimizing the performance of critical performance functions by noting the presence of multicore support, SIMD extensions, accelerators, and so on. In fact, considering hardware features in programming is a common practice among HPC programmers.\r
\r
However, to deal with the large number of alternative heterogeneous computing resources available, package developers deal with portability, maintenance, and modularity issues. First, they need APIs that allow them to inspect hardware configurations during execution. However, there is no general alternative, as they alone do not cover all the architectural details that can influence programming decisions to accelerate the code. To avoid this, developers can give application programmers the responsibility of selecting the appropriate package version for the target architecture, or ask them to provide details about the target architecture through parameters, making programming interfaces more complex. Second, package developers are often required to interlace code for different architectures in the same function, making it difficult to make changes as accelerator technology evolves, such as when implementations should be provided to new accelerators. A common situation occurs when the programming API is deprecated, as has been the case with some Julia packages that use OpenCL.jl (e.g. https://github.com/JuliaEarth/ImageQuilting.jl/issues/16).\r
\r
We argue that the traditional view of programming language designers that programs should be viewed as abstract entities dissociated from the target execution platform is not adequate to a context in which programs must efficiently exploit heterogeneous computing resources provided by IaaS cloud providers, eager to sell their services. In fact, these features may vary between runs of the same program, as application programmers try to meet their schedules and satisfy their budget constraints. So, the design of programming languages should follow the assumption that the software is now closely related to the hardware on which it will run, still making it possible to control the level of independence in relation to hardware assumptions through abstraction mechanisms (in fact, independence in relation to the hardware is still needed most of the time). For that, we propose typing programs with their target execution platforms through a notion of contextual types.\r
\r
Contextual types are inspired by our previous work with HPC Shelf, a component-based platform to provide HPC services (http://www.hpcshelf.org). Surprisingly, they can free application programmers from making assumptions about target execution environments, focusing that responsibility on package developers in a modular and scalable way. In fact, contextual types help package developers write different, independent methods of the same function for different hardware configurations. In addition, other developers, as well as application programmers, can provide their own methods for specific hardware configurations not supported by the chosen package. To do this, the runtime system must be aware of the underlying features of the execution platform.\r
\r
We chose Julia as the appropriate language to evaluate our proposal for two main reasons. Firstly, Julia was designed with HPC requirements in mind, as it is primarily focused on scientific and technical computing applications. Second, it implements a multiple dispatch approach that fits contextual types into the task of selecting methods for different hardware configurations. In fact, multiple dispatch has a close analogy with HPC Shelf's contextual contract resolution mechanism.`,recording_license:"",do_not_record:!1,persons:[{id:18127,code:"3VFNZC",public_name:"Francisco Heron de Carvalho Junior",biography:`DSc in Computer Science from the Federal University of Pernambuco, Recife, Brazil\r
\r
Associate Professor, Department of Computing, Federal University of Cear\xE1, Fortaleza, Brazil\r
\r
Visiting researcher at Northeastern University, Boston, USA.\r
\r
Main areas of interest: programming languages and high performance computing\r
\r
Most recent project: http://www.hpcshelf.org\r
\r
Curriculum: http://lattes.cnpq.br/4164818158160492\r
\r
LinkedIn: https://www.linkedin.com/in/francisco-heron-de-carvalho-junior-6bb58949/`,answers:[]}],links:[],attachments:[],answers:[]},{id:17949,guid:"e59d70e8-4e8f-5884-8549-6f2d296e26a1",logo:"",date:"2022-07-28T19:30:00+00:00",start:"19:30",duration:"00:30",room:"Purple",slug:"juliacon-2022-17949-optimizing-floating-point-math-in-julia",url:"https://pretalx.com/juliacon-2022/talk/S8KUPP/",title:"Optimizing Floating Point Math in Julia",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Why did `exp10` get 2x faster in Julia 1.6? One reason is, unlike most other languages, Julia doesn't use the operating system-provided implementations for math (Libm). This talk will be an overview of improvements in Julia's math library  since version 1.5, and areas for future improvements. We will cover will be computing optimal polynomials, table based implementations, and bit-hacking for peak performance.",description:"In this talk we will cover the fundamental numerical techniques for implementing accurate and fast floating point functions. We will start with a brief review of how Floating Point math works. Then use the changes made to `exp` and friends (`exp2`, `exp10`, and  `expm1`) over the past two years as a demonstration for the main techniques of computing functions.\r\n\r\nSpecifically we will look at:\r\n* Range reduction\r\n* Polynomial kernels using the `Remez` algorithm\r\n* Fast polynomial evaluation\r\n* Table based methods\r\n* Bit manipulation (to make everything fast)\r\n\r\nWe will also discuss how to test the accuracy of implementations using [FunctionAccuracyTests.jl](https://github.com/JuliaMath/FunctionAccuracyTests.jl), and areas for future improvements in Base and beyond. Present and future work areas optimized routines are the Bessel Functions, cumulative distribution functions, and optimized elementary functions for [DoubleFloats.jl](https://github.com/JuliaMath/DoubleFloats.jl), and PRs across the entire package ecosystem are always welcome.",recording_license:"",do_not_record:!1,persons:[{id:18363,code:"QZAY7Y",public_name:"Oscar Smith",biography:"I graduated from Carleton College and studied math and computer science, and now work for JuliaComputing on analog circuit simulation. I also make math go vroom.",answers:[]}],links:[],attachments:[],answers:[]},{id:17930,guid:"af7a08af-2493-5296-b186-a327303acec1",logo:"",date:"2022-07-28T20:00:00+00:00",start:"20:00",duration:"00:30",room:"Purple",slug:"juliacon-2022-17930-juliasyntax-jl-a-new-julia-compiler-frontend-in-julia",url:"https://pretalx.com/juliacon-2022/talk/RKLTEP/",title:"JuliaSyntax.jl: A new Julia compiler frontend in Julia",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:`JuliaSyntax.jl is a new Julia language frontend designed for precise error reporting, speed and flexibility. In this talk we'll tour the JuliaSyntax parser implementation and tree data structures, highlighting benefits for users and tool builders. We'll discuss how to losslessly map Julia source text for character-precise error reporting and how a "parse stream" abstraction cleanly separates the parser from syntax tree creation while being 10x faster than Julia's reference parser.`,description:`JuliaSyntax aims to be a complete compiler frontend (parser, data structures and code lowering) designed for the growing needs of the julia community, as split broadly into users, tool authors and core developers.\r
\r
For users we need *interactivity* and *precision*\r
\r
* Speed: Bare parsing is 20x faster; parsing to a basic tree 10x faster, and parsing to Expr around 6x faster\r
* Robustness: The parse tree covers the full source text regardless of syntax errors so partially complete source text can be processed in use cases like editor tooling and REPL completions\r
* Precision: We map every character of the source text so highlighting of errors or other compiler diagnostics can be fully precise\r
\r
For tool authors, JuliaSyntax aims to be *accessible* and *flexible*\r
\r
* Lossless parsing accounts for all source text, including comments and whitespace so that tools can faithfully work with the source code.\r
* We support Julia source code versions different from the Julia version running JuliaSyntax itself so only one tooling deployment is needed per machine\r
* JuliaSyntax is hackable and accessible to the community, due to being written in Julia itself\r
* Layered tree data structures support various use cases from code formatting to semantic analysis.\r
\r
For core developers, JuliaSyntax aims to provide *familiarity* and *easy of integration*:\r
\r
* The code mirrors the structure of the flisp parser\r
* It depends only on Base\r
* The syntax tree data structures are hackable independently from the parser implementation.\r
\r
For a detailed description of the package aims and current status, see the source repository documentation on github at https://github.com/JuliaLang/JuliaSyntax.jl#readme`,recording_license:"",do_not_record:!1,persons:[{id:10496,code:"FAS33Q",public_name:"Chris Foster",biography:"I'm a long time enthusiastic user of Julia and enjoy contributing to various packages across the open source ecosystem, Julia standard libraries and compiler. I love hearing about people's fascinating technical computing adventures of all types! Find me at https://github.com/c42f or as Chris Foster/c42f on the julialang Zulip, slack or discourse.",answers:[]}],links:[],attachments:[],answers:[]}],Blue:[{id:18154,guid:"132899f1-a97a-5cca-aa2b-d153bb384f39",logo:"",date:"2022-07-28T12:30:00+00:00",start:"12:30",duration:"00:30",room:"Blue",slug:"juliacon-2022-18154-improvements-in-package-precompilation",url:"https://pretalx.com/juliacon-2022/talk/DUQQLN/",title:"Improvements in package precompilation",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Julia code can be precompiled to save time loading and/or compiling it on first execution. Precompilation is nuanced because Julia code comes in many flavors, including source text, lowered code, type-inferred code, and various stages of optimization to reach native machine code. We will summarize what has (and hasn't) previously been precompiled, some of the challenges posed by Julia's dynamism, the nature of some recent changes, and prospects for near-term extensions to precompilation.",description:`Package precompilation occurs when you first use a package or as triggered by changes to your package environment. The goal of precompilation is to re-use work that would otherwise have to be repeated each time you load a raw source file; potentially-saved work includes parsing the source text, type-inference, optimization, generation of LLVM IR, and/or compilation of native code.  While there are many cases in computing where a previously-calculated result can be recomputed faster than it can be retrieved from storage, code compilation is not (yet) one such case. Indeed, the time needed for compilation is the dominant contribution to Julia's *latency*, the delay you experience when you first execute a task in a fresh session.  In an effort to reduce this latency, Julia has long supported certain forms of precompilation.\r
\r
Package precompilation occurs in a clean environment with just the package dependencies pre-loaded, and the results are written to disk (*serialization*).  When loaded (*deserialization*), the results have to be "spliced in" to a running Julia session which may include a great deal of external code.  Several of the most-loved features of Julia---its method polymorphism, aggressive type specialization, and support for dynamic code development allowing redefinition and/or changes in dispatch priority---conspire to make precompilation a significant challenge.  Some examples include saving type-specialized code (which types should be precompiled?), code that may be valid in one environment but invalid in another (due to redefinition or having been superseded in dispatch priority), and code that needs to be compiled for types defined in external packages. While lowered code is essentially a direct translation of the raw source text, saving any later form of code requires additional information, specifically the types that methods should be specialized for.  This information can be provided manually through explicit \`precompile\` directives, or indirectly from the state of a session that includes all necessary and/or useful specializations.\r
\r
Julia versions prior to 1.8 provide exhaustive support for precompiling lowered code (allowing re-use of the results of parsing).   A subset of the results of type-inference could also be precompiled, but in practice much type-inferred code was excluded: it was not possible to save the results of type-inference for any method defined in a different package. That meant it was not possible to save the results of type-inference for new type-specializations of externally-defined methods. Finally, native code was not possible to precompile except by generating a custom "system image" using a tool like PackageCompiler.\r
\r
Julia 1.8 introduced the ability to save the results of type-inference for external methods, and thus provides exhaustive support for saving type-inferred code. As a result, packages generally seem to exhibit lower time-to-first task, with the magnitude of the savings varying considerably depending on the relative contributions of inference and native-code generation to experienced latency.\r
\r
To go beyond these advances, we have begun to build support for serialization and deserialization of native code at package level.  Native code would still be stored package-by-package (supporting Julia's famous composability), and this requires the ability to link this code after loading.  Different from static languages like C and C++, this linking must be compatible with Julia's dynamic features like late specialization and code-invalidation.  We will describe the progress made so far and the steps needed to bring this vision to fruition.`,recording_license:"",do_not_record:!1,persons:[{id:1179,code:"J9BSUH",public_name:"Tim Holy & Valentin Churavy",biography:"Tim Holy is the Alan A. and Edith L. Wolff Professor of Neuroscience at Washington University in St. Louis. Valentin Churavy is a Ph.D. student in MIT's Computer Science & Artificial Intelligence Laboratory. Both are long-time contributors to Julia and its package ecosystem.",answers:[]}],links:[],attachments:[],answers:[]},{id:17982,guid:"27fe277b-174a-5358-9b49-44d0a5178ea6",logo:"",date:"2022-07-28T13:00:00+00:00",start:"13:00",duration:"00:10",room:"Blue",slug:"juliacon-2022-17982-hunting-down-allocations-with-julia-1-8-s-allocation-profiler",url:"https://pretalx.com/juliacon-2022/talk/YHYSEM/",title:"Hunting down allocations with Julia 1.8's Allocation Profiler",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Ever written code that was too slow because of excessive allocations, but didn't know where in your code they were coming from? Julia 1.8 introduces a new Allocation Profiler for finding and understanding sources of allocations in your julia programs, providing stack traces and type info for allocation hotspots. In this talk we will introduce the allocation profiler, cover how to use it, and talk through a small success story in our own codebase.",description:`The Julia 1.8 release includes a sampling Allocation Profiler, producing a profile of sampled allocations from a running program, which you can use to understand, and hopefully reduce, the most expensive allocations in your program. The profiles are best viewed together with PProf.jl, which is a powerful (but complex) visual profile analysis tool.\r
\r
Using this new profiler to track down and eliminate allocations can help improve performance, but there are some gotchas to keep in mind. What sample rate should you be using to get an accurate view of your program's behavior? How should you interpret the results? How do you navigate pprof's interface? We'll introduce these topics with quick practical guidance for the budding allocation hunters in the audience.`,recording_license:"",do_not_record:!1,persons:[{id:1162,code:"JP9VJF",public_name:"Nathan Daly",biography:"Software Engineer at RelationalAI",answers:[]},{id:18392,code:"UVGKBU",public_name:"Pete Vilter",biography:"Works at RelationalAI.",answers:[]}],links:[],attachments:[],answers:[]},{id:17250,guid:"5d643380-7de6-5c9f-a5a1-d4d027c4d85c",logo:"",date:"2022-07-28T13:10:00+00:00",start:"13:10",duration:"00:10",room:"Blue",slug:"juliacon-2022-17250-highdimpde-jl-a-julia-package-for-solving-high-dimensional-pdes",url:"https://pretalx.com/juliacon-2022/talk/ZNEVTB/",title:"HighDimPDE.jl: A Julia package for solving high-dimensional PDEs",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"High-dimensional PDEs cannot be solved with standard numerical methods, as their computational cost increases exponentially in the number of dimensions. This problem, known as the curse of dimensionality, vanishes with HighDimPDE.jl. The package implements novel solvers that can solve non-local nonlinear PDEs in potentially up to 1000 dimensions.",description:`High-dimensional partial differential equations (PDEs) arise in a variety of scientific domains including physics, engineering, finance and biology. High-dimensional PDEs cannot be solved with standard numerical methods, as their computational cost increases exponentially in the number of dimensions, a problem known as the curse of dimensionality. HighDimPDE.jl is a Julia package that breaks down the curse of dimensionality in solving PDEs. Building upon the [SciML ecosystem](https://sciml.ai/), the package implements novel solvers that can solve non-local nonlinear PDEs in potentially up to thousands of dimensions. Already proposing two solvers with different pros and cons, it aims at hosting more.\r
\r
In this talk, we firstly introduce the package, briefly present the two currently implemented solvers, and showcase their advantages with concrete examples.`,recording_license:"",do_not_record:!1,persons:[{id:18096,code:"CEKMLK",public_name:"Victor Boussange",biography:"I\u2019m Victor, a fourth year Ph.D candidate in the Landscape Ecology Group at ETH Z\xFCrich and at the Swiss Federal Institute for Forest, Snow & Landscape (WSL), Switzerland. I am interested in understanding evolutionary processes that affect the dynamics of ecosystems and economic systems. I conduct my investigations with mathematical models capturing eco-evolutionary dynamics. In parallel, I develop machine learning methods to combine these models with empirical data and infer scientific knowledge. I believe that the combination of mechanistic models and machine learning provides a powerful approach to better understand and forecast the dynamics of real ecosystems and economies.",answers:[]}],links:[],attachments:[],answers:[]},{id:18143,guid:"307e0b15-5406-5629-82e7-3a324d5f623e",logo:"",date:"2022-07-28T13:20:00+00:00",start:"13:20",duration:"00:10",room:"Blue",slug:"juliacon-2022-18143-solving-transient-pdes-in-julia-with-gridap-jl",url:"https://pretalx.com/juliacon-2022/talk/JBVLSK/",title:"Solving transient PDEs in Julia with Gridap.jl",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"In this talk we present a new feature of Gridap.jl focusing on the solution of transient Partial Differential Equations (PDEs). We will show a new API that: a) leads to weak forms with very simple syntax, b) supports automatic differentiation, c) enables the solution of multi-field and DAE systems, and d) can be used in parallel computing through GridapDistributed.jl. We will showcase the novel features for a variety of applications in fluid and solid dynamics.",description:`Gridap is an open-source, finite element (FE) library implemented in the Julia programming language. The main goal of Gridap is to adopt a more modern programming style than existing FE applications written in C/C++ or Fortran in order to simplify the simulation of challenging problems in science and engineering and improve productivity in the research of new discretization methods. The library is a feature-rich general-purpose FE code able to solve a wide range of partial differential equations (PDEs), including linear, nonlinear, and multi-physics problems. Gridap is extensible and modular. One can implement new FE spaces, new reference elements, and use external mesh generators, linear solvers, and visualization tools. In addition, it blends perfectly well with other packages of the Julia package ecosystem, since Gridap is implemented 100% in Julia.\r
\r
In this presentation we highlight a new feature introduced in Gridap.jl during the last year, a new high-level API that allows the user to simulate complex transient PDEs with very few lines of code. This new API goes in line with the distinctive features of Gridap.jl, allowing for the definition of weak forms in a syntax that is very similar to the mathematical notation used in academic works. The new API has a series of noticeable features, namely: it supports ODEs of arbitrary order, provided that a solver for the specific order is implemented, allows automatic differentiation of all the jacobians associated to the trannsient problem, enables the solution of multi-field and Diferential Algebraic Equation (DAE) systems, and can be used in parallel computing through the extension of the API to the GridapDistributed.jl package.\r
\r
In JuliaCon2022 we will showcase this novel feature with a number of real applications in fluid and solid dynamics. The applications will include problems resulting in 1st and 2nd order ODEs, problems with constant and time-dependent coefficients, and problems with time-dependent geometries.`,recording_license:"",do_not_record:!1,persons:[{id:10350,code:"RHYTX3",public_name:"Oriol Colomes",biography:"Oriol Colomes is Assistant Progessor at TU Delft, in the Offshore Engineering section at the Civil Engineering and Geosciences faculty.",answers:[]}],links:[],attachments:[],answers:[]},{id:17956,guid:"dc102cb5-216b-5758-a466-552bb64e48ca",logo:"/media/juliacon-2022/submissions/Z9Y73V/logo256_oniouhN.png",date:"2022-07-28T13:30:00+00:00",start:"13:30",duration:"00:10",room:"Blue",slug:"juliacon-2022-17956-progradio-jl-projected-gradient-optimization",url:"https://pretalx.com/juliacon-2022/talk/Z9Y73V/",title:"Progradio.jl - Projected Gradient Optimization",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"Most (Mathematical) Optimization problems are subject to bounds on the decision variables. In general, a nonlinear cost function `f(x)` is to be minimized, with the vector `x` constrained by simple bounds `l <= x <= u`. The *Projected Gradient* class of methods is tailored for this very optimization problem. Our package includes various Projected Gradient methods, fully implemented in Julia. We make use of Julia's Iterator interface, allowing for user-defined termination criteria.",description:"",recording_license:"",do_not_record:!1,persons:[{id:18372,code:"9AMMJ7",public_name:"Eduardo M. G. Vila",biography:"PhD Student at Imperial College London",answers:[]}],links:[],attachments:[],answers:[]},{id:17281,guid:"618f5853-541c-5583-ab90-0b1a12e5877b",logo:"",date:"2022-07-28T13:40:00+00:00",start:"13:40",duration:"00:10",room:"Blue",slug:"juliacon-2022-17281-transformer-models-and-framework-in-julia",url:"https://pretalx.com/juliacon-2022/talk/KX9NAV/",title:"Transformer models and framework in Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"An introduction to the Transformers.jl and relative packages for building transformer models.",description:"I would talk about the new API design in Transformers.jl, from the new text encoder that build on top of TextEncoderBase.jl, to the new model implementation that build on top of NeuralAttentionlib.jl and the new pretrain model management API based on HuggingFaceApi.jl.",recording_license:"",do_not_record:!1,persons:[{id:4639,code:"SJNHPW",public_name:"Peter Cheng",biography:"A graduate student working on deep learning and natural language processing.",answers:[]}],links:[],attachments:[],answers:[]},{id:16942,guid:"16bb492a-533f-541b-a491-ff82a052b87c",logo:"",date:"2022-07-28T16:30:00+00:00",start:"16:30",duration:"00:10",room:"Blue",slug:"juliacon-2022-16942-automating-reinforcement-learning-for-solving-economic-models",url:"https://pretalx.com/juliacon-2022/talk/J7RCP7/",title:"Automating Reinforcement Learning for Solving Economic Models",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"I present a new package which aims to automate the process of using reinforcement learning to solve discrete-time heterogeneous-agent macroeconomic models. Models with discrete choice, matching, aggregate uncertainly, and multiple locations are supported. The pure-Julia package, tentatively named Bucephalus.jl, also defines a data structure for describing this class of models, allowing new solvers to be easily implemented and models to be defined once and solved many ways.",description:`Heterogeneous-agent macroeconomic models, though relatively recent in their development, have been applied across macroeconomics, and have contributed to our understanding of inequality, trade, business cycles, migration, epidemics, and the transmission of monetary policy.\r
\r
Conventional methods of solving these models, which generally require computing policy or value functions on a grid which covers the model's entire state space, are subject to a curse of dimensionality. High-dimensional state spaces make a model unfeasible to solve. Using neural networks instead of grids to approximate policy and value functions solves this problem, and has become an important and active area of research. Because these models must be trained by simulating agents and updating based on simulated outcomes, these solution methods are a form of reinforcement learning.\r
\r
At present, the ability to use reinforcement learning to solve economic models is limited to economists who are also trained in these techniques. Bucephalus.jl aims to make these techniques accessible by automating the process while remaining applicable to a broad class of models. The user describes a model using a simple model description syntax built on Julia macros. The models are then automatically compiled to a standard data structure, to which, in principle, many solvers could then be applied. I present a solver that uses deep reinforcement learning to solve for steady state, impulse responses, and transition paths.\r
\r
The package furthermore implements reinforcement learning techniques never before applied to this domain, including discrete-choice policy networks and nested generalized moments.`,recording_license:"",do_not_record:!1,persons:[{id:17874,code:"UNFA9C",public_name:"Jeffrey Sun",biography:"I am a graduate student in economics at Princeton University. I am interested in dynamic heterogeneous-agent spatial models and reinforcement learning techniques to solve them.",answers:[]}],links:[],attachments:[],answers:[]},{id:18092,guid:"de79db2e-cc6d-5bac-8c15-be3a74bd8923",logo:"",date:"2022-07-28T16:40:00+00:00",start:"16:40",duration:"00:10",room:"Blue",slug:"juliacon-2022-18092-bender-jl-a-utility-package-for-customizable-deep-learning",url:"https://pretalx.com/juliacon-2022/talk/7S9YZV/",title:"Bender.jl: A utility package for customizable deep learning",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:'A wide range of research on feedforward neural networks requires "bending" the chain rule during backpropagation. The package Bender.jl provides neural network layers (compatible with Flux.jl), which gives users more freedom to choose every aspect of the forward mapping. This makes it easy to leverage ChainRules.jl to compose a wide range of experiments, such as training binary neural networks, Feedback Alignment and Direct Feedback Alignment in just a few lines of code.',description:"In this lightning talk we will explore two different use cases of [Bender.jl](https://github.com/Rasmuskh/Bender.jl), namely training binary neural networks and training neural networks using the biologically motivated Feedback Alignment algorithm. Binary neural networks and feedback alignment might seem like very different areas of research, but from an implementation point of view they are very similar, as both amount to modifying the chain rule during backpropagation. Implementing a binary neural network requires modifying backpropagation in order to allow non-zero error signals to propagate through binary activation functions and feedback alignment requires modifying backpropagation to use a set of auxilary weights for transporting errors backwards (in order to avoid the biologically implausible weight symmetry requirement inherent to backpropagation). By allowing the user to specify the exact nature of the forward mapping when initializing a layer it is possible to leverage ChainRules.jl to easily implement these and similar experiments.",recording_license:"",do_not_record:!1,persons:[{id:18452,code:"NXZATT",public_name:"Rasmus Kj\xE6r H\xF8ier",biography:"I am a PhD student at Chalmers University of Technology.  My research interests are biologically motivated learning algorithms and energy based models.",answers:[]}],links:[],attachments:[],answers:[]},{id:18103,guid:"532f36af-9d84-559d-a396-8bbcbbf1d8a5",logo:"/media/juliacon-2022/submissions/Z7MXFS/intro_uz7fH3F.gif",date:"2022-07-28T16:50:00+00:00",start:"16:50",duration:"00:10",room:"Blue",slug:"juliacon-2022-18103-effortless-bayesian-deep-learning-through-laplace-redux",url:"https://pretalx.com/juliacon-2022/talk/Z7MXFS/",title:"Effortless Bayesian Deep Learning through Laplace Redux",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Treating deep neural networks probabilistically comes with numerous advantages including improved robustness and greater interpretability. These factors are key to building artificial intelligence (AI) that is trustworthy. A drawback commonly associated with existing Bayesian methods is that they increase computational costs. Recent work has shown that Bayesian deep learning can be effortless through Laplace approximation. This talk presents an implementation in Julia: `BayesLaplace.jl`.",description:`#### Problem: Bayes can be costly \u{1F625}\r
\r
Deep learning models are typically heavily under-specified in the data, which makes them vulnerable to adversarial attacks and impedes interpretability. Bayesian deep learning promises an intuitive remedy: instead of relying on a single explanation for the data, we are interested in computing averages over many compelling explanations. Multiple approaches to Bayesian deep learning have been put forward in recent years including variational inference, deep ensembles and Monte Carlo dropout. Despite their usefulness these approaches involve additional computational costs compared to training just a single network. Recently, another promising approach has entered the limelight: Laplace approximation (LA).\r
\r
#### Solution: Laplace Redux \u{1F929}\r
\r
While LA was first proposed in the 18th century, it has so far not attracted serious attention from the deep learning community largely because it involves a possibly large Hessian computation. The authors of this recent [NeurIPS paper](https://arxiv.org/abs/2106.14806) are on a mission to change the perception that LA has no use in DL: they demonstrate empirically that LA can be used to produce Bayesian model averages that are at least at par with existing approaches in terms of uncertainty quantification and out-of-distribution detection, while being significantly cheaper to compute. Our package [\`BayesLaplace.jl\`](https://github.com/pat-alt/BayesLaplace.jl) provides a light-weight implementation of this approach in Julia that allows users to recover Bayesian representations of deep neural networks in an efficient post-hoc manner.\r
\r
#### Limitations and Goals \u{1F6A9}\r
\r
The package functionality is still limited to binary classification models trained in Flux. It also lacks any framework for optimizing with respect to the Bayesian prior. In future work we aim to extend the functionality. We would like to develop a library that is at least at par with an existing Python library: [Laplace](https://aleximmer.github.io/Laplace/). Contrary to the existing Python library, we would like to leverage Julia's support for language interoperability to also facilitate applications to deep neural networks trained in other programming languages like Python an R. \r
\r
#### Further reading \u{1F4DA}\r
\r
For more information on this topic please feel free to check out my introductory blog post: [[TDS](https://towardsdatascience.com/go-deep-but-also-go-bayesian-ab25efa6f7b)], [[blog](https://www.paltmeyer.com/blog/posts/effortsless-bayesian-dl/)]. Presentation slides can be found [here](https://www.paltmeyer.com/LaplaceRedux.jl/dev/resources/juliacon22/presentation.html#/title-slide).`,recording_license:"",do_not_record:!1,persons:[{id:17382,code:"8DGYCX",public_name:"Patrick Altmeyer",biography:`I am an economist and computer scientist currently studying for a PhD in Trustworthy Artificial Intelligence (AI) at Delft University of Technology. My research is on the intersection of AI and Financial Economics. In particular, I'm interested in Explainable AI, Counterfactual Explanations, Bayesian ML and Causal Inference and their applications to Financial Economics.\r
\r
Previously, I worked as an economist for Bank of England where I was involved in research, monetary policy briefings and market intelligence. I hold bachelor's and master's degrees in Economics, Finance and Data Science.`,answers:[]}],links:[],attachments:[],answers:[]},{id:18081,guid:"802c0d48-d253-5983-b3d3-971224821573",logo:"/media/juliacon-2022/submissions/HPAHBV/image_4_g03MeGW.png",date:"2022-07-28T17:00:00+00:00",start:"17:00",duration:"00:10",room:"Blue",slug:"juliacon-2022-18081-large-scale-machine-learning-inference-with-banyanonnxruntime-jl",url:"https://pretalx.com/juliacon-2022/talk/HPAHBV/",title:"Large-Scale Machine Learning Inference with BanyanONNXRunTime.jl",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"BanyanONNXRunTime.jl is an open-source Julia package for running PyTorch/TensorFlow models on large distributed arrays. In this talk, we show how you can use BanyanONNXRunTime.jl with BanyanDataFrames.jl for running ML models on tabular data and with BanyanImages.jl for running ML models on image data.",description:`More information about BanyanONNXRunTime.jl can be found on GitHub:\r
https://github.com/banyan-team/banyan-julia\r
https://github.com/banyan-team/banyan-julia-examples`,recording_license:"",do_not_record:!1,persons:[{id:10346,code:"MQTPBB",public_name:"Caleb Winston",biography:"I'm Caleb. I'm currently studying Computer Science at the University of Washington and will be doing research at Stanford next year. My research interests are quite broad and I have published work in areas including both brain-computer interfaces and wet lab automation and I would be happy to chat about these things. I'm also currently working on https://BanyanComputing.com. Outside of CS, I love composing music and playing the alto sax in an ensemble group with my siblings.",answers:[]},{id:10424,code:"CJVEWU",public_name:"Cailin Winston",biography:null,answers:[]}],links:[],attachments:[],answers:[]},{id:18121,guid:"69658bfc-b6c2-5a6a-9a1d-9aed53cd661f",logo:"/media/juliacon-2022/submissions/DZFPGX/frame0240_UfuTcsB.png",date:"2022-07-28T17:10:00+00:00",start:"17:10",duration:"00:10",room:"Blue",slug:"juliacon-2022-18121-speedyweather-jl-a-16-bit-weather-model-with-machine-learning",url:"https://pretalx.com/juliacon-2022/talk/DZFPGX/",title:"SpeedyWeather.jl: A 16-bit weather model with machine learning",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"We present SpeedyWeather.jl, a global atmospheric model currently developed as a prototype for a 16-bit climate model incorporating machine learning for accuracy and computational efficiency on different hardware. SpeedyWeather.jl is designed for type flexibility with low precision, and automatic differentiation to replace parts of the model with neural networks for a more accurate representation of climate processes and computational efficiency.",description:`Computational resources are a major limitation to improve reliability in numerical predictions of weather and climate. Most simulations run on conventional CPUs in 64-bit floats, although some weather forecast centres now use 32 bits operationally for higher performance. Successful 16-bit simulations have been previously demonstrated with projects like ShallowWaters.jl, increasing performance by 4x with respect to a 64-bit simulation on Fujitsu\u2019s A64FX CPU. However, it remains to be seen whether these results can also be achieved for global atmospheric models, like those used for weather and climate simulation. A new model, SpeedyWeather.jl aims to address this question. As with ShallowWaters.jl, SpeedyWeather.jl aims to support hardware-accelerated low precision arithmetic, yet will be substantially more complex. Much like state-of-the-art numerical weather prediction models, SpeedyWeather.jl includes a \u201Cdynamical core\u201D for advancing forward the basic equations describing fluid flow in the Earth\u2019s atmosphere and \u201Cparametrizations\u201D for representing physical processes that take place below the scale of the model\u2019s spatial grid, such as the development of clouds from convective updrafts. As such, it is intended to be a simple model for exploring weather and climate simulation in the Julia ecosystem. SpeedyWeather.jl is, like ShallowWaters.jl,  fully type-flexible to support arbitrary number formats for performance and analysis (like Sherlogs.jl) simultaneously. This means the model development is precision-agnostic, which allows us to address the common problems of dynamic range and critical precision loss often incurred from using low-precision number formats. The aim of this project is to develop a prototype towards the first global 16-bit weather and climate models.\r
\r
Beyond numerical weather prediction, low-precision arithmetic is now routinely used in deep learning and neural networks. SpeedyWeather.jl is developed so that entire parts of the model may be replaced by artificial neural networks, thereby complementing conventional physics-based climate modelling with a data-driven approach. Such \u201Chybrid\u201D climate models promise to improve the representation of climate processes that are conventionally poorly resolved, either by training against higher resolution simulations or simulations based on more sophisticated, yet expensive, algorithms. In addition, hybrid models offer the prospect of fitting climate models to observational data. In order to train the neural network components of the model, SpeedyWeather.jl aims to be fully differentiable using automatic differentiation. Implementing parts of weather and climate models with artificial neural networks can also improve computational efficiency and facilitate low precision linear algebra.  This talk presents the concept, implementation details, challenges and first results in the development of SpeedyWeather.jl towards a hybrid model incorporating both differential equation solvers and machine learning.\r
\r
Co-Authors:\r
- Tom Kimpson (University of Oxford, UK)\r
- Alistair White and Maximilian Gelbrecht (Potsdam Institute for Climate Impact Research and Technical University of Munich, Germany)\r
- Sam Hatfield (European Centre for Medium-Range Weather Forecasts, Reading, UK)`,recording_license:"",do_not_record:!1,persons:[{id:4335,code:"A9SQSW",public_name:"Milan Kl\xF6wer",biography:"Post-Doctoral Research Assistant, University of Oxford, UK",answers:[]}],links:[],attachments:[],answers:[]},{id:17973,guid:"b2cc68e8-bbfe-5a6c-81ba-c7bcc4eb4bfa",logo:"",date:"2022-07-28T17:20:00+00:00",start:"17:20",duration:"00:10",room:"Blue",slug:"juliacon-2022-17973-explainableai-jl-interpreting-neural-networks-in-julia",url:"https://pretalx.com/juliacon-2022/talk/MFU9MN/",title:"ExplainableAI.jl: Interpreting neural networks in Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`In pursuit of interpreting black-box models such as deep image classifiers, a number of techniques have been developed that attribute and visualize the importance of input features with respect to the output of a model.\r
ExplainableAI.jl brings several of these methods to Julia, building on top of primitives from the Flux ecosystem. In this talk, we will give an overview of current features and show how the package can easily be extended, allowing users to implement their own methods and rules.`,description:"",recording_license:"",do_not_record:!1,persons:[{id:18371,code:"3CFNUV",public_name:"Adrian Hill",biography:"Adrian Hill is a PhD student in the Machine Learning Group at TU Berlin.",answers:[]}],links:[],attachments:[],answers:[]},{id:17748,guid:"0eb5152e-5dee-5ca5-88a5-bdab5b5a7334",logo:"",date:"2022-07-28T17:30:00+00:00",start:"17:30",duration:"00:10",room:"Blue",slug:"juliacon-2022-17748-training-spiking-neural-networks-in-pure-julia",url:"https://pretalx.com/juliacon-2022/talk/UTTHUM/",title:"Training Spiking Neural Networks in pure Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Training artificial neural networks to recapitulate the dynamics of biological neuronal recordings has become a prominent tool to understand computations in the brain. We present an implementation of a recursive-least squares algorithm to train units in a recurrent spiking network.  Our code can reproduce the activity of 50,000 neurons of a mouse performing a decision-making task in less than an hour of training time. It can scale to a million neurons on a GPU with 80 GB of memory.",description:`Spiking networks that operate in a fluctuation driven regime are a common way to model brain activity. Individual neurons within a spiking artificial neural network are trained to reproduce the spiking activity of individual neurons in the brain. In doing so, they capture the structured activity patterns of the recorded neurons, as well as the spiking irregularities and the trial-to-trial variability. Such trained networks can be analyzed in silico to gain insights into the dynamics and connectivity of cortical circuits underlying the recorded neural activity that would be otherwise difficult to obtain in vivo.\r
\r
The number of simultaneously recorded neurons in behaving animals has been increasing in the last few years at an exponential rate. It is now possible to simultaneously record from about 1000 neurons using electrophysiology in behaving animals, and up to 100,000 using calcium imaging. When combining several sessions of recordings, the amount of data becomes huge and could grow to millions of recorded neurons in the next few years. There is a need then for fast algorithms and code bases to train networks of spiking neurons on ever larger data sets.\r
\r
Here we use a recursive least-squares training algorithm (RLS; also known as FORCE; Sussillo and Abbott, 2009), adapted for spiking networks (Kim and Chow 2018, 2021), which uses an on-line estimation of the inverse covariance matrix between connected neurons to update the strength of plastic synapses.  We make the code more performant through a combination of data parallelism, leveraging of BLAS, use of symmetric packed arrays, reduction in storage precision, and refactoring for GPUs.\r
\r
Our goal is to train the synaptic current input to each neuron such that the resulting spikes follow the target activity pattern over an interval in time. We use a leaky integrate-and-fire neuron model with current-based synapses.  The peri-stimulus time histograms of the spike trains are converted to the equivalent target synaptic currents using the transfer function of the neuron model.  We treat every neuron\u2019s synaptic current as a read-out, which makes our task equivalent to training a recurrently connected read-out for each neuron. Since a neuron's synaptic current can be expressed as a weighted sum of the spiking activities of its presynaptic neurons, we adjust the strength of the incoming synaptic connections by the RLS algorithm in order to generate the target activity.\r
\r
This training scheme allows us to set up independent objective functions for each neuron and to update them in parallel. A CPU version of the algorithm partitions the neurons onto threads and uses the standard BLAS libraries to perform the matrix operations. As the vast majority of memory is consumed by the inverse covariance matrix, larger models can be accommodated by reducing precision for all state variables and using a packed symmetric matrix for the covariance (see SymmetricFormats.jl for the SymmetricPacked type definition). These memory-use optimizations also have the benefit of being faster too. For the GPU version, custom batched BLAS kernels were written for packed symmetric matrices (see BatchedBLAS.jl for the batched_spmv! and batched_spr! functions).\r
\r
We benchmarked on synthetic targets consisting of sinusoids with identical frequencies and random phases. For a model with one million neurons, 512 static connections per neuron, and 45 plastic connections per neuron, the CPU code took 1260 seconds per training iteration on a 48-core Intel machine and the GPU code took 48 seconds on an Nvidia A100. For this connectivity pattern, one million is the largest number of neurons (within a factor of two) that could fit in the 80 GB GPU. The CPU cores, with 768 GB of RAM, accommodated four million neurons with this connectivity.\r
\r
We also tested our algorithm's ability to learn real target functions using 50,000 neurons recorded in five different brain regions from a mouse performing a decision-making task.  The recording intervals were 3 sec long and spikes rates averaged 7 Hz.  Replacing the static connections with random Gaussian noise and using 256 plastic connections, the model achieved a correlation of 0.8 between the desired and learned currents in 30 minutes of training time.\r
\r
Our work enables one to train spiking recurrent networks to reproduce the spiking activity of huge data sets of recorded neurons in a reasonable amount of time. By doing so, it facilitates analyzing the relations between connectivity patterns, network dynamics and brain functions in networks of networks in the brain.  We also introduce two new Julia packages to better support packed symmetric matrices.`,recording_license:"",do_not_record:!1,persons:[{id:18189,code:"BJR7KW",public_name:"Ben Arthur",biography:"Principal Software Engineer in Scientific Computing at Howard Hughes Medical Institute's Janelia Research Campus",answers:[]},{id:18201,code:"XKYPBW",public_name:"Christopher Kim",biography:null,answers:[]}],links:[],attachments:[],answers:[]},{id:18130,guid:"92fe780c-40a1-5d18-af2c-94e89abd215a",logo:"",date:"2022-07-28T17:40:00+00:00",start:"17:40",duration:"00:10",room:"Blue",slug:"juliacon-2022-18130-simple-chains-fast-cpu-neural-networks",url:"https://pretalx.com/juliacon-2022/talk/9RFTHY/",title:"Simple Chains: Fast CPU Neural Networks",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`SimpleChains is an open source pure-Julia machine learning library developed by PumasAI and JuliaComputing in collaboration with Roche and the University of Maryland, Baltimore.\r
It is specialized for relatively small-sized models and NeuralODEs, attaining best in class performance for these problems. The performance advantage remains significant when scaling to tens of thousands of parameters, where it's still >5x faster than Flux or Pytorch while all use a CPU, even outperforming GPUs.`,description:`SimpleChains is a pure-Julia library that is simple in two ways:\r
1. All kernels are simple loops (it leverages LoopVectorization.jl for performance). \r
2. It only supports simple (feedforward) neural networks.\r
\r
It additionally manages memory manually, and currently relies on hand written pull back definitions.\r
In combination, these allow it to be 50x faster than Flux training an MNIST example on a 10980XE.\r
\r
This talk will focus on introducing the library, showing off a few examples, and explaining some of they "why" behind it's performance.`,recording_license:"",do_not_record:!1,persons:[{id:4370,code:"DNZRRM",public_name:"Chris Elrod",biography:"Chris Elrod is a frequent commenter on the Julia Discourse, Slack, and Zulip, as well as a contributor to the ecosystem, known in particular for LoopVectorization.jl and JuliaSIMD.",answers:[]}],links:[],attachments:[],answers:[]},{id:18085,guid:"1b794a29-1307-5bc9-b43d-8de1cef6e3a6",logo:"",date:"2022-07-28T19:00:00+00:00",start:"19:00",duration:"00:10",room:"Blue",slug:"juliacon-2022-18085-automated-geometric-theorem-proving-in-julia",url:"https://pretalx.com/juliacon-2022/talk/DFYH73/",title:"Automated Geometric Theorem Proving in Julia",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"This talk introduces [GeometricTheoremProver.jl](https://github.com/lucaferranti/GeometricTheoremProver.jl), a Julia package for automated deduction in Euclidean geometry. The talk will give a short overview of geometric theorem proving concepts and hands-on demos on how to use the package to write and prove statements in Euclidean geometry. A roadmap of the package for future development plans will also be presented.",description:`Geometry has been central in formal reasoning, with Euclid's *Elements* being the first example of axiomatic system. Centuries later, Euclidean geometry is still central e.g. in mathematical education as introduction to formal proofs. To make things more exciting, Tarski proved in early 1900 that Euclidean geometry is decidable, that is a computer program should be able to answer questions like "is this statement true?". This opened several interesting questions: How can I prove *efficiently* statements in Euclidean geometry? Can I generate *readable* proofs? During the talk, I will touch those questions while introducing [GeometricTheoremProver.jl](https://github.com/lucaferranti/GeometricTheoremProver.jl), a package for automated reasoning in Euclidean geometry written fully in Julia. The talk will combine a short overview of geometric theorem proving concepts with hands-on demos on how to use the package to write and prove statements in Euclidean geometry. Finally, the talk will also present a roadmap for the package, hopefully giving pointers to the interested listener on how to contribute.`,recording_license:"",do_not_record:!1,persons:[{id:12269,code:"PTCVCM",public_name:"Luca Ferranti",biography:"I am a phd student in computer science. I am enthusiastic about maths, computation, Julia and computational maths in Julia. More details on my [github page](https://github.com/lucaferranti), if you share some of interests and want to collaborate or chat, do not hesitate to contact me, I hang out fairly often on the Julia slack and zulip channels.",answers:[]}],links:[],attachments:[],answers:[]},{id:18156,guid:"1d31f0f2-850f-5809-a5c4-12d68bc546bb",logo:"",date:"2022-07-28T19:10:00+00:00",start:"19:10",duration:"00:10",room:"Blue",slug:"juliacon-2022-18156-simd-vectorized-implementation-of-high-order-irk-integrators",url:"https://pretalx.com/juliacon-2022/talk/VAZYBR/",title:"SIMD-vectorized implementation of high order IRK integrators",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"We present a preliminary version of a SIMD-vectorized implementation of the sixteenth order 8-stage implicit Runge-Kutta integrator  IRKGL16 implemented in the Julia package IRKGaussLegendre.jl. For numerical integrations of typical non-stiff problems performed in double precision, we show that a vectorized implementation of IRKGL16 that exploits the SIMD-based parallelism can clearly outperform high order explicit Runge-Kutta schemes available in the standard package DifferentialEquations.jl.",description:`We present a preliminary version of a SIMD-vectorized implementation of the sixteenth order implicit Runge-Kutta integrator IRKGL16 implemented in the Julia package IRKGaussLegendre.jl. \r
\r
The solver IRKGL16 is an implicit Runge-Kutta integrator of collocation type based on the Gauss-Legendre quadrature formula of 8 nodes. It is intended for high precision numerical integration of non-stiff systems of ordinary differential equations.  In its sequential implementation, the scheme has interesting properties (symplecticness and time-symmetry) that make it particularly useful for long-term integrations of conservative problems. Such properties are also very useful for Scientific Machine Learning applications, as gradients can be exactly calculated by  integrating backward in time the adjoint equations.\r
\r
For numerical integration of typical non-stiff problems with very high accuracy beyond the precision offered by double precision (i.e., standard IEEE binary64 floating precision) arithmetic our sequential implementation of IRKGL16 is more efficient than high order explicit Runge-Kutta schemes implemented in the standard package DifferentialEquations.jl. However,  our sequential implementation of IRKGL16 is generally unable to outperform them in double precision arithmetic. \r
\r
We show that a vectorized implementation of IRKGL16 that exploits the SIMD-based parallelism offered by modern processor can be more efficient than high order explicit Runge-Kutta methods even for double precision computations. We demonstrate that by comparing our vectorized implementation of IRKGL16 with a 9th order explicit Runge-Kutta method (Vern9 from DifferentialEquations.jl) for different benchmark problems.\r
\r
Our current implementation (https://github.com/mikelehu/IRKGL_SIMD.jl) depends on the Julia package SIMD.jl to efficiently perform computations on vectors with eight Float64 numbers. The right-hand side of the system of ODEs to be integrated has to be implemented as a generic function defined in terms of the arithmetic operations and elementary functions implemented for vectors in the package SIMD.jl. The state variables must be collected in an array of Float64 or Float32 floating point numbers. The SIMD-based vectorization process is performed automatically under the hood.`,recording_license:"",do_not_record:!1,persons:[{id:3318,code:"UNYAWF",public_name:"Mikel",biography:`Bachelor of Computer Science (1992) and Doctorate (2017) at the UPV / EHU.  2011-2012, professor  in the Department of Computer Science and Artificial Intelligence.  Since 2017, professor of the School of Engineering of Gipuzkoa in the Department of Applied Mathematics.\r
Within the field of Computer Science, he has developed the following lines of research:  efficient implementation of numerical integration methods applied to the simulation of the solar system.`,answers:[]},{id:21285,code:"MBVBUB",public_name:"Joseba Makazaga",biography:null,answers:[]},{id:21473,code:"3L7JKD",public_name:"Ander Murua",biography:null,answers:[]}],links:[],attachments:[],answers:[]},{id:17676,guid:"4fe14844-1d66-5841-9696-6aad41f596a5",logo:"",date:"2022-07-28T19:20:00+00:00",start:"19:20",duration:"00:10",room:"Blue",slug:"juliacon-2022-17676-zero-knowledge-proofs-of-shuffle-with-shuffleproofs-jl",url:"https://pretalx.com/juliacon-2022/talk/XJTDWH/",title:"Zero knowledge proofs of shuffle with ShuffleProofs.jl",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Many remote electronic voting systems use the ElGamal re-encryption mixnet as the foundation of their design, motivated by a number of ways authorities can be held accountable. In particular, zero-knowledge proofs of shuffle as implemented in the Verifiactum library offer an elegant and well-established solution. In ShuffleProofs.jl, I implement a Verificatum compatible verifier and prover for non-interactive zero-knowledge proofs of shuffle, making it more accessible, as I shall demonstrate.",description:`Zero-knowledge proofs (ZKP) are the key for making distributed applications privacy-preserving while keeping participants accountable. Widely used in remote electronic voting system designs and cryptocurrencies, they are still hard to understand, tinker with and thus are accessible only to a tiny minority of skilled cryptographers, dampening the creation of new innovative solutions. \r
\r
An exciting ZKP application is making a re-encryption mix in the ElGamal cryptosystem accountable for not adding, removing, or modifying ciphertexts. While multiple protocols exist for the purpose, none is as contested as the WikstromTerelius variant implemented in the Verificatum library used to make election systems verifiable in Estonia, Norway, Switzerland and elsewhere. But is far from optimal to tinker with as is implemented in Java. In ShuffleProofs.jl, I implement Verificatum compatible noninteractive zero-knowledge verifier and prover for correct re-encryption, improving its accessibility for non-practitioners.\r
\r
To demonstrate the usefulness and bring every listener on the same line, I shall discuss a most typical ElGamal voting system used widely as foundations for many designs representing it in only 30 lines of Julia code. After discussing the properties of the system, I will demonstrate how to add verifiability so that even if an adversary controlled the re-encryption mix server, it would not be able to add, remove or modify votes without being noticed. \r
\r
I shall also demonstrate how we can use the ShuffleProofs.jl to verify Verificatum generated proofs of shuffle, which can help independent auditors to verify real elections on the field. In addition, I shall touch a bit on how one can implement their own verifier as a finite state machine making ShuffleProofs.jl futureproof with all sorts of implementations. Lastly, I will recap and articulate some practices on how zero-knowledge proofs can be implemented in Julia and how they could be made accessible for wider audiences to tinker with.`,recording_license:"",do_not_record:!1,persons:[{id:3897,code:"BYKXMD",public_name:"Janis Erdmanis",biography:'I own a PhD degree titled "Quantum effects of superconducting phase" at TU Delft. Since then, I have found my passion in programming and designing cryptosystems. I like to expand boundaries and build frames where complexity becomes manageable. May be excited about job opportunities using Julia as the main driver.',answers:[]}],links:[],attachments:[],answers:[]},{id:18016,guid:"778b79af-68ab-563e-9c5d-fa7fa6082935",logo:"",date:"2022-07-28T19:30:00+00:00",start:"19:30",duration:"00:10",room:"Blue",slug:"juliacon-2022-18016-magnav-jl-airborne-magnetic-anomaly-navigation",url:"https://pretalx.com/juliacon-2022/talk/8GLBMW/",title:"MagNav.jl: airborne Magnetic anomaly Navigation",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"MagNav.jl is an open-source Julia package that contains a full suite of tools for aeromagnetic compensation and airborne magnetic anomaly navigation. This talk will describe the high-level functionalities of the package, then provide a brief tutorial using real flight data that is available within the package. The functionalities can be divided into the four essential components of MagNav: sensors (flight data), magnetic anomaly maps, aeromagnetic compensation models, and navigation algorithms.",description:"",recording_license:"",do_not_record:!1,persons:[{id:10451,code:"VAWVFX",public_name:"Albert R. Gnadt",biography:"Albert recently received his PhD from MIT AeroAstro and is now a postdoc in the Julia Lab within MIT CSAIL. His research is focused on improving airborne magnetic anomaly navigation using machine learning-based aeromagnetic compensation approaches (and the Julia programming language). Albert received his B.S. degree in mechanical engineering from UW\u2013Madison in 2015 and S.M. degree in aeronautics and astronautics from MIT in 2018. Albert previously worked on electric aircraft design as an NSF graduate research fellow, and he earned his private pilot license in 2020.",answers:[]}],links:[],attachments:[],answers:[]},{id:17879,guid:"61350183-e70c-5164-91de-a0d6b801b907",logo:"",date:"2022-07-28T19:40:00+00:00",start:"19:40",duration:"00:10",room:"Blue",slug:"juliacon-2022-17879-validating-a-tsunami-model-for-coastal-inundation",url:"https://pretalx.com/juliacon-2022/talk/UTT8SE/",title:"Validating a tsunami model for coastal inundation",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"How do we trust that a given fluid model is suitable for simulating water waves as they approach and wash over the land? This talk presents some of the benchmark tests used to validate a tsunami model. Using our [Julia implementation of a fluid model](https://github.com/justinmimbs/WaveTank.jl), we check how well it conserves mass, matches analytical solutions, and reproduces laboratory experiments.",description:`A computational model of a physical process requires careful validation before it can be trusted to tell something useful about the world. In this research, we did not set out to formulate a new model, but to implement an existing formulation in Julia. The tsunami model presented by Yamazaki et al. in [1] is a depth-averaged, nonhydrostatic fluid model with a free surface, capable of simulating tsunami waves as they transform and run up on land. Though the authors presented their validation results, we still needed a suite of tests to help verify that our implementation matches the specification, and that it is suitable for our application area.\r
\r
In this talk, we will explore the following kinds of validation tests for numerical tsunami models by walking through examples with our Julia implementation.\r
\r
- Conservation of mass\r
- Solution convergence\r
- Comparison to analytical solutions\r
- Comparison to laboratory experiments\r
\r
As a first-principles measure of validity, a fluid model needs to conserve mass--that is, as the model progresses over time, there should always be the same amount of fluid in the model.\r
\r
Another basic test of a numerical model is solution convergence. It is necessary to discretize space and time for a fluid model, and as the resolution increases (i.e., as the discretization size decreases) it is expected that the solutions converge.\r
\r
Centuries of study of fluid mechanics have provided analytical solutions to many idealized wave scenarios. These are useful for comparing against numerical models. We will look at the translation of a solitary wave (a wave that propagates without changing shape).\r
\r
Analytical wave theories can't describe all the ways that waves interact with complex bottom surfaces, so next we turn to laboratory experiments. Over recent decades, researchers have performed experiments in large wave tanks, generating waves for various scenarios and measuring the effects. We recreate several laboratory experiments with our model and compare the results.\r
\r
----\r
\r
[1] Yamazaki, Y., Kowalik, Z. and Cheung, K.F. (2009), Depth-integrated, non-hydrostatic model for wave breaking and run-up. International Journal for Numerical Methods in Fluids, 61: 473-497. https://doi.org/10.1002/fld.1952`,recording_license:"",do_not_record:!1,persons:[{id:17763,code:"ADFHVG",public_name:"Justin Mimbs",biography:"Justin Mimbs is a software engineer at ISEA TEK (Industrial & Systems Engineering Analysis Technologies) in Maitland, Florida.",answers:[]}],links:[],attachments:[],answers:[]},{id:18150,guid:"26b9460c-d222-54d7-bf8f-1755d40a3a1c",logo:"/media/juliacon-2022/submissions/U7WAAD/logo_JciFPRn.svg",date:"2022-07-28T19:50:00+00:00",start:"19:50",duration:"00:10",room:"Blue",slug:"juliacon-2022-18150-jcheck-jl-randomized-property-testing-made-easy",url:"https://pretalx.com/juliacon-2022/talk/U7WAAD/",title:"JCheck.jl: Randomized Property Testing Made Easy",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:'JCheck is a native Julia implementation of a randomized property testing (RPT) framework. It aims at integrating as seamlessly as possible to the Test.jl package in order to enable developers to easily use RPT along with more "traditional" approaches. Although a fair number of generators are included, designing novel ones for custom data types is a straightforward process. Additional features such as shrinkage and specification of "special" non-random input are available.',description:`[Slides](https://www.patrickfournier.ca/juliacon2022/)\r
\r
Since Julia's main purpose is technical computing, we believe its users could benefit from an easy-to-use framework for property testing. A lot of Julia code is in fact implementation of various kinds of abstract objects for which at least some theoretical properties are known beforehand. While randomized property testing alone is not usually sufficient for serious software development, it might definitely be a great addition to a battery of tests. For that reason, we designed JCheck.jl so it integrates seamlessly with Test.jl.\r
\r
To make JCheck agreeable to use, a lot of care has been put into the efficiency of the input generation process. Random inputs are reused to reduce the number of generated data to a minimum. "Built-in" generators which can be used as a building block for more complex ones have been designed to be as efficient as possible.\r
\r
JCheck can be extended to support custom types in 2 ways. Type unions of types for which generators are implemented are supported automatically. More intricate types are supported through method dispatch. Note that it is trivial to define a generator for a type for which we can already generate random instances.\r
\r
JCheck support so-called "special cases", i.e. non-random cases that are always checked.\r
\r
In order to make the analysis of failing cases easier, JCheck support shrinking. When such a case is detected, it will try to make it as simple as possible. Whether shrunk or not, failing cases can be serialized to a file to make further investigation easier.`,recording_license:"",do_not_record:!1,persons:[{id:18489,code:"JLHZAA",public_name:"Patrick Fournier",biography:"PhD candidate in mathematics @ STATQAM (Universit\xE9 du Qu\xE9bec \xE0 Montr\xE9al).",answers:[]}],links:[],attachments:[],answers:[]},{id:18129,guid:"129d5c13-d2f0-5094-b3da-e683eb9b190c",logo:"",date:"2022-07-28T20:00:00+00:00",start:"20:00",duration:"00:10",room:"Blue",slug:"juliacon-2022-18129-juliaup-the-julia-installer-and-version-multiplexer",url:"https://pretalx.com/juliacon-2022/talk/J9AX9Y/",title:"Juliaup - The Julia installer and version multiplexer",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"This talk will present a deep dive into juliaup, the upcoming new official Julia installer and version multiplexer. The talk will give a brief presentation of the features of Juliaup, and then dive into design decision, integration with existing system package managers and an outlook of planned future work.",description:"",recording_license:"",do_not_record:!1,persons:[{id:1038,code:"7JQFVF",public_name:"David Anthoff",biography:"David Anthoff is an environmental economist who studies climate change and environmental policy. His research has appeared in Nature, Science, the American Economic Review, Nature Climate Change, the Journal of the Association of Environmental and Resource Economists and other academic journals. He is an associate professor in the Energy and Resources Group at the University of California, Berkeley.",answers:[]}],links:[],attachments:[],answers:[]},{id:17976,guid:"a48ce12b-c640-536b-aecd-3909774e9946",logo:"",date:"2022-07-28T20:10:00+00:00",start:"20:10",duration:"00:10",room:"Blue",slug:"juliacon-2022-17976-contributing-to-open-source-with-technical-writing-",url:"https://pretalx.com/juliacon-2022/talk/8SWDQG/",title:"Contributing to Open Source with Technical Writing.",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"The goal of this talk is to enlighten members of the Julia ecosystem on how they can make an impact by contributing to open source with technical writing. While this talk would be targeted at beginners, there would be something for even the more experienced members.",description:`This talk would cover two main headings: Open Source and Technical Writing. It would also explore how they can relate to each other. The following aspects would be touched:\r
\r
- What Open Source is\r
- What Technical Writing is\r
- How to contribute to Open Source with Technical Writing\r
- How it helps the Julia Ecosystem\r
- Steps on beginning a Technical Writing Journey\r
- Tips`,recording_license:"",do_not_record:!1,persons:[{id:18386,code:"WCU3QG",public_name:"Ifihanagbara Olusheye",biography:"Ifihan is a Python/Julia developer and Technical Writer. She has a passion for communities and new technologies.",answers:[]}],links:[],attachments:[],answers:[]}],BoF:[{id:18730,guid:"71fd9096-4e44-5c7a-b215-df6a3da3e9d8",logo:"",date:"2022-07-28T12:30:00+00:00",start:"12:30",duration:"00:45",room:"BoF",slug:"juliacon-2022-18730-juliagpu",url:"https://pretalx.com/juliacon-2022/talk/RHYB8M/",title:"JuliaGPU",subtitle:"",track:"JuliaCon",type:"Birds of Feather",language:"en",abstract:`The JuliaGPU community welcomes both long-standing contributors and newcomers to a birth-of-the feather event on the state of the JuliaGPU ecosystem.\r
Voice your feedback and experiences.`,description:"",recording_license:"",do_not_record:!1,persons:[{id:903,code:"3C7UBC",public_name:"Valentin Churavy",biography:"asads",answers:[]},{id:2402,code:"9YQMAK",public_name:"Tim Besard",biography:"Tim Besard is a software engineer at Julia Computing, working on GPU support for the Julia language. He holds a Ph.D. in computer science engineering from Ghent University, Belgium, for research on abstractions to program hardware accelerators in high-level programming languages.",answers:[]}],links:[],attachments:[],answers:[]},{id:18063,guid:"a5e220bb-4db9-50ad-a6e3-40997135b2dc",logo:"",date:"2022-07-28T16:30:00+00:00",start:"16:30",duration:"01:30",room:"BoF",slug:"juliacon-2022-18063-julia-in-hpc",url:"https://pretalx.com/juliacon-2022/talk/QVESXM/",title:"Julia in HPC",subtitle:"",track:"JuliaCon",type:"Birds of Feather",language:"en",abstract:`The Julia HPC community has been growing over the last years with monthly meetings to coordinate development and to solve problems arising in the use of Julia for HPC.\r
\r
The Julia in HPC Birth of the Feather is an ideal opportunity to join the community and to discuss your experiences with using Julia in HPC`,description:"",recording_license:"",do_not_record:!1,persons:[{id:903,code:"3C7UBC",public_name:"Valentin Churavy",biography:"asads",answers:[]},{id:10503,code:"K9PVSE",public_name:"Johannes Blaschke",biography:null,answers:[]},{id:10161,code:"ZBB3MC",public_name:"Michael Schlottke-Lakemper",biography:"Michael is a group leader and research software engineer at the High-Performance Computing Center Stuttgart of the University of Stuttgart, Germany. His research focus is on numerical methods for adaptive multi-physics simulations, high-performance computing with Julia, and scientific machine learning.",answers:[]}],links:[],attachments:[],answers:[]},{id:16548,guid:"509cc18a-1750-5c06-a59d-4b69c43f1844",logo:"",date:"2022-07-28T19:00:00+00:00",start:"19:00",duration:"01:30",room:"BoF",slug:"juliacon-2022-16548-bof-julialang-en-espaol",url:"https://pretalx.com/juliacon-2022/talk/7M3BKA/",title:"BoF - JuliaLang en Espa\xF1ol",subtitle:"",track:"JuliaCon",type:"Birds of Feather",language:"en",abstract:`Enhorabuena, ha llegado el momento de tener un foro dedicado para los usuarios de JuliaLang en espa\xF1ol.\r
Discutiremos:\r
- foros y centros donde se usa Julia en espa\xF1ol\r
- materiales educativos (cursos, libros, art\xEDculos, video tutoriales), y planes a futuro\r
- diversidad, inclusi\xF3n y apoyo de hispano-parlantes`,description:`Vamos a abrir un espacio de discusi\xF3n donde los hispanoparlantes de JuliaLang se puedan conocer, compartirse, y coordinarse para que pueda crecer la comunidad de usuarios de Julia en espa\xF1ol. No importa tu nivel de proficiencia con Julia, aqu\xED le daremos la bienvenida a todas, todos y todes.\r
Trataremos de lidiar con cada tema durante 15-20 minutos cada uno y permitir retroalimentaci\xF3n por parte de todos para tener metas concretas al final de la junta a trav\xE9s de una discusi\xF3n estructurada y moderada.`,recording_license:"",do_not_record:!1,persons:[{id:1182,code:"JE89PF",public_name:"Miguel Raz Guzm\xE1n Macedo",biography:"Miguel Raz es un estudiante de f\xEDsica de la UNAM.",answers:[]},{id:4027,code:"HSUYYR",public_name:"Pamela Alejandra Bustamante Fa\xFAndez",biography:`Pamela Bustamante Fa\xFAndez is a PhD candidate from Pontificia Universidad Cat\xF3lica de Chile (Chile). She holds a Master in Industrial Engineering and a BSc degree with Distinction in Industrial Engineering from the Universidad del B\xEDo-B\xEDo. \r
She has been using Julia since her undergraduate days at Universidad del B\xEDo-B\xEDo, Chile. Co-author of IntroAJulia.jl`,answers:[]},{id:17360,code:"YUDY7W",public_name:"Agust\xEDn Covarrubias",biography:null,answers:[]},{id:17361,code:"XPJBKD",public_name:"Argel Ram\xEDrez Reyes",biography:null,answers:[]}],links:[],attachments:[],answers:[]}],JuMP:[{id:17229,guid:"c7b85805-c29b-52b7-b677-8026f9a3cfce",logo:"",date:"2022-07-28T16:30:00+00:00",start:"16:30",duration:"00:30",room:"JuMP",slug:"juliacon-2022-17229-improving-nonlinear-programming-support-in-jump",url:"https://pretalx.com/juliacon-2022/talk/XBX9BH/",title:"Improving nonlinear programming support in JuMP",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"In JuMP 1.0, support for nonlinear programming is a second-class citizen. You must use the separate `@NL` macros, the automatic differentiation engine is a JuMP-specific implementation that cannot be swapped for alternative implementations, and vector-valued nonlinear expressions are not supported. In this talk, we discuss our plans and progress to address these issues and make nonlinear programming a first-class citizen. This work is supported by funding from Los Alamos National Laboratory.",description:"",recording_license:"",do_not_record:!1,persons:[{id:10481,code:"QREN8R",public_name:"Oscar Dowson",biography:"Oscar Dowson is a core contributor to JuMP.",answers:[]}],links:[],attachments:[],answers:[]},{id:16937,guid:"d6455b63-b947-586a-98fd-3b82e3efc3f7",logo:"",date:"2022-07-28T17:00:00+00:00",start:"17:00",duration:"00:30",room:"JuMP",slug:"juliacon-2022-16937-benchmarking-nonlinear-optimization-with-ac-optimal-power-flow",url:"https://pretalx.com/juliacon-2022/talk/XQMLCH/",title:"Benchmarking Nonlinear Optimization with AC Optimal Power Flow",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"This work discusses some of the requirements for deploying non-convex nonlinear optimization methods to solve large-scale problems in practice. AC Optimal Power Flow is proposed as a proxy-application for testing the viability of nonlinear optimization frameworks for solving such problems. The current performance of several Julia frameworks for nonlinear optimization is evaluated using a standard benchmark library for AC Optimal Power Flow.",description:`The AC Optimal Power Flow problem (AC-OPF) is one of the most foundational optimization problems that arises in the design and operations of power networks. Mathematically the AC-OPF is a large-scale, sparse, non-convex nonlinear continuous optimization problem. In practice AC-OPF is most often solved to local optimality conditions using interior point methods. This project proposes AC-OPF as _proxy-application_ for testing the viability of different nonlinear optimization frameworks, as performant solutions to AC-OPF has proven to be a necessary (but not always sufficient) condition for solving a wide range of industrial network optimization tasks.\r
\r
### Objectives\r
* Communicate the technical requirements for solving real-world continuous non-convex mathematical optimization problems.\r
* Highlight scalability requirements for the problem sizes that occur in practice.\r
* Provide a consistent implementation for solving AC-OPF in different nonlinear optimization frameworks.\r
\r
### AC-OPF Implementations\r
This work adopts the mathematical model and data format that is used in the IEEE PES benchmark library for AC-OPF, [PGLib-OPF](https://github.com/power-grid-lib/pglib-opf). The Julia package [PowerModels](https://github.com/lanl-ansi/PowerModels.jl) is used for parsing the problem data files and making standard data transformations.\r
\r
The implementations of the AC-OPF problem in various Julia NonLinear Programming (NLP) frameworks are available in [Rosetta-OPF](https://github.com/lanl-ansi/rosetta-opf) project, which currently includes implementations in [JuMP](https://github.com/jump-dev/JuMP.jl), [NLPModels](https://github.com/JuliaSmoothOptimizers/NLPModels.jl), [Nonconvex](https://github.com/JuliaNonconvex/Nonconvex.jl), [Optim](https://github.com/JuliaNLSolvers/Optim.jl) and [Optimization](https://github.com/SciML/Optimization.jl). This work reports on the solution quality and runtime of solving the PGLib-OPF datasets with each of these NLP frameworks.`,recording_license:"",do_not_record:!1,persons:[{id:9513,code:"DNAPAH",public_name:"Carleton Coffrin",biography:"Carleton Coffrin is a staff scientist in Los Alamos National Laboratory\u2019s Advanced Network Science Initiative. His research interests focus on how optimization methods can be used to solve applications in infrastructure networks. His background spans many forms of optimization including mathematical programing, constraint programming, and local search. Recently Carleton has been exploring the potential of novel computing architectures such as, quantum computers, neuromorphic processors and memristors to solve optimization applications.",answers:[]}],links:[],attachments:[],answers:[]},{id:17243,guid:"aeb7c300-0ddc-559e-a483-14b257560a8e",logo:"",date:"2022-07-28T17:30:00+00:00",start:"17:30",duration:"00:30",room:"JuMP",slug:"juliacon-2022-17243-advances-in-transformations-and-nlp-modeling-for-infiniteopt-jl",url:"https://pretalx.com/juliacon-2022/talk/LEG8TJ/",title:"Advances in Transformations and NLP Modeling for InfiniteOpt.jl",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"InfiniteOpt.jl is built on a unifying abstraction for infinite-dimensional optimization problems that enable it to tackle a wide variety of problems in innovative ways. We present recent advances to InfiniteOpt.jl that significantly its flexibility to model/solve these challenging problems.  We have developed a general transformation API to facilitate diverse solution methodologies, and we have created an intuitive nonlinear interface that overcomes the current shortcomings of JuMP.jl.",description:"",recording_license:"",do_not_record:!1,persons:[{id:11334,code:"YNHAFQ",public_name:"Joshua Pulsipher",biography:"I am postdoc at Carnegie Mellon University specializing in infinite-dimensional optimization techniques.",answers:[]}],links:[],attachments:[],answers:[]},{id:18057,guid:"48e081ea-cc2e-5b11-9ace-4e0624de63b1",logo:"",date:"2022-07-28T19:00:00+00:00",start:"19:00",duration:"00:30",room:"JuMP",slug:"juliacon-2022-18057-the-juliasmoothoptimizers-jso-organization",url:"https://pretalx.com/juliacon-2022/talk/YTTXMK/",title:"The JuliaSmoothOptimizers (JSO) Organization",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"The JSO organization is a set of Julia packages for smooth, nonsmooth optimization, and numerical linear algebra intended to work consistently together and exploit the structure present in problems. It provides modeling facilities, widely useful known methods, either in the form of interfaces or pure Julia implementations, but also unique methods that are the product of active research. We review the main features of JSO, its current status, and hint at future developments.",description:"",recording_license:"",do_not_record:!1,persons:[{id:18432,code:"MN9YCG",public_name:"Dominique Orban",biography:`I am computational mathematician. My scientific interests span computational optimization, numerical analysis, numerical linear algebra, scientific computing, and modeling environments. I have a keen interest in the interplay between computational science and programming languages.\r
\r
My research focuses on the design, convergence analysis, numerical properties, practical implementation, and testing of algorithms for continuous optimization and their linear algebra kernels. I am equally interested in applying algorithms that I design to problems that arise in engineering and science.\r
\r
My research activities thus comprise tightly interconnected theoretical analyses of computational methods and high-quality implementations to aid in the modeling and solution of practical problems.`,answers:[]}],links:[],attachments:[],answers:[]},{id:18048,guid:"71c0e976-f323-5a81-8d79-53e5e4be675f",logo:"",date:"2022-07-28T19:30:00+00:00",start:"19:30",duration:"00:30",room:"JuMP",slug:"juliacon-2022-18048-pde-constrained-optimization-using-juliasmoothoptimizers",url:"https://pretalx.com/juliacon-2022/talk/UDKTPD/",title:"PDE-constrained optimization using JuliaSmoothOptimizers",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"In this presentation, we showcase a new optimization infrastructure within JuliaSmoothOptimizers for PDE-constrained optimization problems in Julia. We introduce PDENLPModels.jl a package that discretizes PDE-constrained optimization problems using finite elements methods via Gridap.jl. The resulting problem can then be solved by solvers tailored for large-scale optimization implemented in pure Julia such as DCISolver.jl and FletcherPenaltyNLPSolver.jl.",description:"The study of algorithms for optimization problems has become the backbone of data science and its multiple applications. Nowadays, new challenges involve ever-increasing amounts of data and model complexity. Examples include optimization problems constrained by partial differential equations (PDE) that are frequent in imaging, signal processing, shape optimization, and seismic inversion. In this presentation, we showcase a new optimization infrastructure to model and solve PDE-constrained problems in the Julia programming language. We build upon the JuliaSmoothOptimizers infrastructure for modeling and solving continuous optimization problems. We introduce PDENLPModels.jl a package that discretizes PDE-constrained optimization problems using finite elements methods via Gridap.jl. The resulting problem can then be solved by solvers tailored for large-scale optimization implemented in pure Julia such as DCISolver.jl and FletcherPenaltyNLPSolver.jl.",recording_license:"",do_not_record:!1,persons:[{id:18428,code:"EUXGZU",public_name:"Tangi Migot",biography:"Postdoctoral student at Polytechnique Montr\xE9al",answers:[]}],links:[],attachments:[],answers:[]},{id:18242,guid:"d6543a54-5e80-5568-b72f-0e88adce4758",logo:"",date:"2022-07-28T20:00:00+00:00",start:"20:00",duration:"00:30",room:"JuMP",slug:"juliacon-2022-18242-generalized-disjunctive-programming-via-disjunctiveprogramming",url:"https://pretalx.com/juliacon-2022/talk/L9SQZ9/",title:"Generalized Disjunctive Programming via DisjunctiveProgramming",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"We present a Julia package (DisjunctiveProgramming.jl) that extends the functionality in JuMP to allow modeling problems via logical propositions and disjunctive constraints. Logical propositions are converted into algebraic expressions by converting the Boolean expressions to Conjunctive Normal Form and then to algebraic inequalities. The package allows the user to specify the technique to reformulate the disjunctions (Big-M or Convex-Hull reformulation) into mixed-integer constraints.",description:`Modeling systems with discrete-continuous decisions is commonly done in algebraic form with mixed-integer programming models, which can be linear or nonlinear in the continuous variables. A more systematic approach to modeling such systems is to use Generalized Disjunctive Programming (GDP) (Chen & Grossmann, 2019; Grossmann & Trespalacios, 2013), which generalizes the Disjunctive Programming paradigm proposed by Balas (2018). GDP allows modeling systems from a logic-based level of abstraction that captures the fundamental rules governing such systems via algebraic constraints and logic. The models obtained via GDP can then be reformulated into the pure algebraic form best suited for the application of interest. The two main reformulation strategies are the Big-M reformulation (Nemhauser & Wolsey, 1999; Trespalacios & Grossmann, 2015) and the Convex-Hull reformulation (Lee & Grossmann, 2000), the latter of which yields tighter models than those typically used in standard mixed-integer programming (Grossmann & Lee, 2003).\r
\r
DisjunctiveProgramming.jl supports reformulations for disjunctions containing linear, quadratic, and/or nonlinear constraints. When using the Big-M reformulation, the user can specify the Big-M value to be used, which can either be general to the disjunction or specific to each constraint expression in the disjunction. Alternately, the user can allow the package to determine the tightest Big-M value based on the variable bounds and constraint functions using interval arithmetic (IntervalArithmetic.jl [Sanders, et al., 2022]). When the Convex-Hull reformulation is selected, the perspective function approximation from Furman, et al. (2020) is used for nonlinear constraints with a specified \u03F5 tolerance value. This is done by relying on manipulation of symbolic expressions via Symbolics.jl (Gowda, et al., 2022).`,recording_license:"",do_not_record:!1,persons:[{id:18595,code:"J7KDFG",public_name:"Hector D. Perez",biography:null,answers:[]}],links:[],attachments:[],answers:[]}],"Sponsored forums":[{id:21245,guid:"ebd1583a-2241-559d-a7ec-d93d19d8bcd9",logo:"",date:"2022-07-28T19:00:00+00:00",start:"19:00",duration:"00:45",room:"Sponsored forums",slug:"juliacon-2022-21245-julius-tech-sponsored-forum",url:"https://pretalx.com/juliacon-2022/talk/FSCXXS/",title:"Julius Tech Sponsored Forum",subtitle:"",track:null,type:"Sponsor forum",language:"en",abstract:"Enterprise adoption for Julia can be a difficult process for developers and engineers to champion. In this sponsored forum, we invite leading industry experts to talk about the common challenges organizations face when bringing Julia and Julia based solutions onboard. We will also discuss best practices and practical ways to approach integration.",description:`Enterprise adoption for Julia can be a difficult process for developers and engineers to champion. In this sponsored forum, we invite leading industry experts to talk about the common challenges organizations face when bringing Julia and Julia based solutions onboard. We will also discuss best practices and practical ways to approach integration. The audience will be provided the opportunity to submit questions as well.\r
\r
1. James Lee, Julius Technologies\r
2. Tom Kwong, Meta \r
3. Dr. Chris Rackauckas, Julia Computing\r
4. Jarrett Revels, Beacon Biosignals`,recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]}]}},{index:11,date:"2022-07-29",day_start:"2022-07-29T04:00:00+00:00",day_end:"2022-07-30T03:59:00+00:00",rooms:{Green:[{id:18136,guid:"d20b10c9-8db5-5af8-84aa-4de98b2c2809",logo:"",date:"2022-07-29T12:30:00+00:00",start:"12:30",duration:"00:30",room:"Green",slug:"juliacon-2022-18136-julia-wats-a-most-horrifying-colleciton-of-julia-corner-cases",url:"https://pretalx.com/juliacon-2022/talk/C3ZNN3/",title:"Julia WATs - a most horrifying colleciton of Julia corner cases",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Everyone else in this conference will rhapsodize about how Julia is amazing and can be improved - but *not ME!* And that's only because they haven't stared deep down into the abyss of programming language implementations and have it stare right back. Inspired by the Gary Bernhard 'Javascript WATs' talk, I've collected as many Julia WATs (via community crowdsourcing) as I can and I'd love to collect even more creepy code critters into my collection and show off the ones I have.",description:`If you don't feel horrified from looking at the code snippets that I will present in this presentation, I have failed my job. WATs are code snippets that show gnarly or unfortunate corner cases of the Julia language, and how some of these surprising gotchas can arise out of multiple design constraints.\r
\r
The idea of the talk is to Horrify, Explain, and Assuage viewers from as many code examples as possible and hopefully collect a few more from the community to establish a Great Julia House of Horrors.`,recording_license:"",do_not_record:!1,persons:[{id:1182,code:"JE89PF",public_name:"Miguel Raz Guzm\xE1n Macedo",biography:"Miguel Raz es un estudiante de f\xEDsica de la UNAM.",answers:[]}],links:[],attachments:[],answers:[]},{id:17947,guid:"026ae471-867c-5291-9038-507c9ab396b8",logo:"",date:"2022-07-29T13:00:00+00:00",start:"13:00",duration:"00:10",room:"Green",slug:"juliacon-2022-17947-which-methods-",url:"https://pretalx.com/juliacon-2022/talk/RQZBFB/",title:"which(methods)",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"I will talk about which methods get called by `which(methods)` calls. How does Julia decide? How fast does it decide? And when does it figure it all out?\r\nLet\u2019s take a lightning fast dive together into the complexities of the method selection algorithm we affectionately call multiple-dispatch.",description:`The semantics of multiple dispatch can sound simple and obvious at first glance. But there are lots of strange cases to consider when you start to really explore the details. So how do we do this in a mere few hundred lines of C code? What happens if two methods overlap in applicability? What happens when the user calls invoke instead? How do we track when something changes, after loading a new package or Reviseing an existing one?\r
I will walk through the process of taking the full list of methods in Julia and picking out exactly which method to call. Then take a look at how we extend that action to re-evaluate the results after every new method that gets added.`,recording_license:"",do_not_record:!1,persons:[{id:1057,code:"GKZDHU",public_name:"Jameson Nash",biography:"I work for Julia Computing on Julia compiler technology.",answers:[]}],links:[],attachments:[],answers:[]},{id:19354,guid:"7ab3621a-3ba0-5e5c-8674-cf72e4378d1c",logo:"",date:"2022-07-29T13:10:00+00:00",start:"13:10",duration:"00:10",room:"Green",slug:"juliacon-2022-19354-building-an-inclusive-and-fun-julia-community",url:"https://pretalx.com/juliacon-2022/talk/B9DJ9G/",title:"Building an inclusive (and fun!) Julia community",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`A critical component of any programming language\u2019s potential for impact is the diversity of its \r
community! A supportive, inclusive community draws in new learners, brings fresh perspectives \r
to package development, and ultimately expands the reach a language has.`,description:`In this talk, we focus on the advances in gender diversity that have been made by the Julia \r
community this year: from the development of the new beginner-level live course \u201CLearn Julia \r
with Us\u201D to the continued outreach, community building and mutual support by Julia Gender \r
Inclusive as a whole. \r
\r
Kyla and Julia will share their experiences in co-organizing Julia Gender Inclusive and an \r
equivalent group in the R community. The talk hopes to inspire and share tips for fostering a \r
community that is inclusive and accessible, encouraging underrepresented groups to learn and \r
lead with confidence, and creating an atmosphere that is supportive for all, no matter their \r
background!`,recording_license:"",do_not_record:!1,persons:[{id:19687,code:"HF37BY",public_name:"Kyla McConnell",biography:`Kyla McConnell and Julia M\xFCller are Ph.D. students at the University of Freiburg, where \r
they conduct quantitative psycholinguistic research and teach graduate-level statistics \r
and data skills. They co-organize two groups for gender inclusivity in programming: Julia\r
Gender Inclusive (@juliainclusive) and R-Ladies Freiburg (@RLadiesFreiburg). \r
Through these groups, they have fostered a passion for data science and statistical \r
education, particularly for underrepresented genders. You can find their many \r
workshops for beginners and more experienced programmers alike on the Julia \r
Programming Language and R-Ladies Global Youtube channels, and by following us on \r
Twitter (@McConnellKyla & @JuliaMuellerFr).`,answers:[]},{id:19688,code:"Q7GFPE",public_name:"Julia M\xFCller",biography:`Kyla McConnell and Julia M\xFCller are Ph.D. students at the University of Freiburg, where \r
they conduct quantitative psycholinguistic research and teach graduate-level statistics \r
and data skills. They co-organize two groups for gender inclusivity in programming: Julia\r
Gender Inclusive (@juliainclusive) and R-Ladies Freiburg (@RLadiesFreiburg). \r
Through these groups, they have fostered a passion for data science and statistical \r
education, particularly for underrepresented genders. You can find their many \r
workshops for beginners and more experienced programmers alike on the Julia \r
Programming Language and R-Ladies Global Youtube channels, and by following us on \r
Twitter (@McConnellKyla & @JuliaMuellerFr).`,answers:[]}],links:[],attachments:[],answers:[]},{id:16803,guid:"1aeba7ea-ec2e-5d52-ba53-5fce6815b5fb",logo:"",date:"2022-07-29T13:30:00+00:00",start:"13:30",duration:"00:30",room:"Green",slug:"juliacon-2022-16803-help-how-to-grow-a-corporate-julia-community-",url:"https://pretalx.com/juliacon-2022/talk/EKZHPS/",title:"Help! How to grow a corporate Julia community?",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"For many years we simply accepted the two language problem at our company and spent our time converting MATLAB/Python prototypes into C/C++/Java production code. But during the last two years we have been growing an internal Julia community from 3 initial enthusiasts to over 300 Julians. We would like to share our ongoing journey with you and inspire other Julians who want to kickstart similar communities at their company.",description:`ASML is 30.000 employee company which is the world leader on photo-lithographic system that are crucial for semiconductor manufacture. For many years we accepted the two language problem and spent our time converting MATLAB/Python prototypes into C/C++/Java production code. But during the last two years we have been growing an internal ASML Julia community from 3 initial enthusiasts to over 300 Julians. We would like to share our ongoing journey with you and inspire other Julians who want to kickstart similar communities at their company.\r
\r
Our journey included many obstacles, but we are now in a good position with Julia at ASML. Thanks to Julia\u2019s package manager and LocalRegistry.jl, it was easy to set up an internal registry. This led to a flourishing internal Julia package ecosystem with currently over 50 registered packages used by several of ASML\u2019s research and development departments. \r
\r
To grow further, we foresee plenty of challenges. Changing the software culture from a project-driven to an inner-source approach is one such challenge. Another challenge relates to deployment of Julia into all of our existing software platforms, ranging from embedded hardware systems to cloud services.\r
\r
By overcoming these challenges, we will finally solve the two language problem at ASML and bring different engineering competencies together. It shouldn\u2019t matter if you are a domain expert, data scientist, data engineer, software engineer, software architect, machine learning engineer, business analyst or anything else. If you can code then you can learn Julia and join in on the fun.`,recording_license:"",do_not_record:!1,persons:[{id:17745,code:"MQ8FSP",public_name:"Matthijs Cox",biography:`Born in The Netherlands. MSc. and PhD. at TU Eindhoven on Applied Physics.\r
\r
A physicist who loves to code. I taught myself data science and software development.\r
Currently I work at ASML on the R&D of sensor and algorithms software.`,answers:[]}],links:[],attachments:[],answers:[]},{id:21233,guid:"753929bf-9909-5322-8ff0-68ca4df6af80",logo:"",date:"2022-07-29T14:30:00+00:00",start:"14:30",duration:"00:45",room:"Green",slug:"juliacon-2022-21233-keynote-husain-attarwala",url:"https://pretalx.com/juliacon-2022/talk/9N9HZ3/",title:"Keynote  - Husain Attarwala",subtitle:"",track:"JuliaCon",type:"Keynote",language:"en",abstract:"Keynote  - Husain Attarwala, Moderna",description:"Keynote  - Husain Attarwala, Moderna",recording_license:"",do_not_record:!1,persons:[{id:21655,code:"ZTUXJE",public_name:"Husain Attarwala",biography:"Husain Attarwala is a clinical pharmacologist, pharmacometrician and a researcher in drug development. Currently, he is serving as Head of Clinical Pharmacology and Pharmacometrics at Moderna. His research focus on developing predictive models to guide clinical dose decisions for mRNA vaccines and therapeutics. Previously, Husain was a Principal Scientist at Alnylam Pharmaceuticals where his research helped guide dose selection for various novel siRNA therapeutics, 5 of which have received global regulatory approvals. He has obtained PhD and MS degrees in Pharmaceutical Sciences and Drug Delivery Systems from Northeastern University, and a Bachelors in Pharmacy from Al-Ameen college of pharmacy.",answers:[]}],links:[],attachments:[],answers:[]},{id:21243,guid:"451b3c82-8b11-5722-83ed-201e28f21e25",logo:"",date:"2022-07-29T15:15:00+00:00",start:"15:15",duration:"00:15",room:"Green",slug:"juliacon-2022-21243-relational-ai-sponsored-talk",url:"https://pretalx.com/juliacon-2022/talk/SFJBMG/",title:"Relational AI Sponsored Talk",subtitle:"",track:null,type:"Platinum sponsor talk",language:"en",abstract:"At RelationalAI, we are building the world\u2019s fastest, most scalable, most expressive, most open knowledge graph management system, built on top of the world\u2019s only complete relational reasoning engine that uses the knowledge and data captured in enterprise databases to learn and reason.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:20833,guid:"d4b85b04-1cb5-542d-91e3-f4d47b9dd7b3",logo:"",date:"2022-07-29T15:30:00+00:00",start:"15:30",duration:"00:30",room:"Green",slug:"juliacon-2022-20833-the-state-of-julia-in-2022",url:"https://pretalx.com/juliacon-2022/talk/SSUNVP/",title:"The State of Julia in 2022",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"An update on Julia from the core development team.",description:"",recording_license:"",do_not_record:!1,persons:[{id:20394,code:"9XGHYS",public_name:"Viral B Shah",biography:null,answers:[]}],links:[],attachments:[],answers:[]},{id:21374,guid:"24e382f6-a919-5087-a679-abb0f807dabb",logo:"",date:"2022-07-29T16:00:00+00:00",start:"16:00",duration:"00:10",room:"Green",slug:"juliacon-2022-21374-closing-remarks",url:"https://pretalx.com/juliacon-2022/talk/HRZUUY/",title:"Closing remarks",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"Closing remarks",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:18164,guid:"c2e384ec-d7e2-576f-8533-feb7f1c75038",logo:"",date:"2022-07-29T16:30:00+00:00",start:"16:30",duration:"00:10",room:"Green",slug:"juliacon-2022-18164-dagger-jl-development-and-roadmap",url:"https://pretalx.com/juliacon-2022/talk/8A83SB/",title:"Dagger.jl Development and Roadmap",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`Dagger.jl is a Julia library aiming to improve the way Julia users do distributed programming. With its functional task-focused API, distributed table and array implementations, and intelligent scheduler, Dagger is quickly becoming the de-facto distributed programming interface for many parts of our ecosystem.\r
\r
This talk is focused on Dagger's development over the last year, and where we see Dagger going over the next few years. I'll also provide examples of how to use Dagger's new features.`,description:"",recording_license:"",do_not_record:!1,persons:[{id:4385,code:"GRFD9D",public_name:"Julian P Samaroo",biography:`Research Software Engineer at MIT's JuliaLab.\r
\r
I'm the maintainer of Dagger.jl, AMDGPU.jl, and BPFnative.jl, and am dedicated to making Julia's heterogeneous computing support powerful and productive.`,answers:[]}],links:[],attachments:[],answers:[]},{id:18155,guid:"818666dd-8bbf-5232-9697-eb53f9b53bd0",logo:"",date:"2022-07-29T16:40:00+00:00",start:"16:40",duration:"00:10",room:"Green",slug:"juliacon-2022-18155-dtables-jl-quickstart-current-state-and-next-steps-",url:"https://pretalx.com/juliacon-2022/talk/ZA9RYG/",title:"DTables.jl - quickstart, current state and next steps!",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`DTables.jl is a distributed table implementation based on Dagger.jl. It aims to provide distributed and out-of-core tabular data processing for the Julia programming language. The DTables package consists of data structures, distributed algorithms and it's built to be compatible with our rich data processing ecosystem.\r
\r
The talk covers a quick intro on how to use the DTable, what functionality is currently available and what are our plans for the future!`,description:"",recording_license:"",do_not_record:!1,persons:[{id:18494,code:"HRXMAH",public_name:"Krystian Guli\u0144ski",biography:"https://github.com/krynju",answers:[]}],links:[],attachments:[],answers:[]},{id:18073,guid:"a50b1156-66cc-5661-96b9-da8ecd00511d",logo:"",date:"2022-07-29T16:50:00+00:00",start:"16:50",duration:"00:10",room:"Green",slug:"juliacon-2022-18073--besselk-jl-a-fast-differentiable-implementation-of-besselk-",url:"https://pretalx.com/juliacon-2022/talk/N3J9KR/",title:"`BesselK.jl`: a fast differentiable implementation of `besselk`",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"The modified Bessel function of the second kind, provided by `SpecialFunctions.jl` as `besselk`, is an important function in several fields. Despite its significance, convenient numerical implementations of its derivatives with respect to the order parameter are not easily available. In this talk, we discuss a solution to this problem that leverages Julia's exceptional automatic differentiation ecosystem to provide fast and accurate derivatives with respect to order.",description:"",recording_license:"",do_not_record:!1,persons:[{id:18441,code:"7WKFVY",public_name:"Christopher J Geoga",biography:"PhD student at Rutgers University, Dept. of Statistics",answers:[]}],links:[],attachments:[],answers:[]},{id:17998,guid:"936266a1-b2b5-50af-89cf-9ed293923f1f",logo:"",date:"2022-07-29T17:00:00+00:00",start:"17:00",duration:"00:10",room:"Green",slug:"juliacon-2022-17998-2022-update-diversity-and-inclusion-in-the-julia-community",url:"https://pretalx.com/juliacon-2022/talk/LZELWV/",title:"2022 Update: Diversity and Inclusion in the Julia community",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"In this talk, we will give an annual update on the current diversity and inclusion efforts underway in the community. We will also present stats from Google Analytics showing aggregate country of origin, gender, and age. These stats will help provide additional context for the continued challenge of D&I in the Julia community and will set the stage for the Julia Inclusive BoF session.",description:"D&I continues to be a challenge in technical communities around the world. While the Julia community has done a lot of work trying to address this challenge, the work is very much still ongoing. As part of our commitment to D&I, we have been providing yearly updates on the state of D&I in the Julia community (with a slight focus on gender diversity since we can get those stats from Google Analytics). We hope that this process keeps us accountable to continue to do more to promote equity and inclusion.",recording_license:"",do_not_record:!1,persons:[{id:1032,code:"UNR7XZ",public_name:"Logan Kilpatrick",biography:"Logan is the developer community advocate for the Julia programming language and was formerly the community manager. He is also on the Board of Directors at NumFOCUS and DEFNA. Outside of the Julia community, Logan is a senior technology advocate at PathAI leading ML and OSS advocacy.",answers:[]}],links:[],attachments:[],answers:[]},{id:18646,guid:"2afc52fc-b9fa-5a7d-a0bf-02720bc3140d",logo:"",date:"2022-07-29T17:10:00+00:00",start:"17:10",duration:"00:10",room:"Green",slug:"juliacon-2022-18646-the-juliacon-proceedings",url:"https://pretalx.com/juliacon-2022/talk/S8D3NM/",title:"The JuliaCon Proceedings",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"In this talk, we will present the JuliaCon proceedings, the purpose, scope, and target audience of this venue. The proceedings are a community-driven initiative to publish articles of interest to the research and developer communities gathered by JuliaCon, they do not require application processing fees nor a paywall on article, making both producing and accessing the articles possible for all. We will then give a quick tour of the reviewing and publication process which happen transparently in",description:"",recording_license:"",do_not_record:!1,persons:[{id:1216,code:"DK9KDB",public_name:"Mathieu Besan\xE7on",biography:`Mathieu Besan\xE7on is a researcher at the Zuse Institute Berlin, in the AI in Society, Science, and Technology department, associated with the MODAL-SynLab project and a member of the MATH+ Berlin Mathematics Research Center.\r
\r
His research interests span solution methods and software in MI(N)LP and convex optimization and in particular the SCIP framework and Frank-Wolfe related approaches.`,answers:[]},{id:4153,code:"R3SWQF",public_name:"Carsten Bauer",biography:"Theoretical Physicist - Scientific HPC Advisor - National High Performance Computing (NHR) - Paderborn Center for Parallel Computing (PC\xB2)",answers:[]},{id:1148,code:"AZXJH3",public_name:"Ranjan Anantharaman",biography:"I am a PhD candidate at the Julia Lab at MIT.",answers:[]},{id:903,code:"3C7UBC",public_name:"Valentin Churavy",biography:"asads",answers:[]}],links:[],attachments:[],answers:[]},{id:18166,guid:"90ac4474-23e9-58ea-80ae-19c3d0fe9dad",logo:"/media/juliacon-2022/submissions/7Q8WXA/4.ppp_r7A2hNr.png",date:"2022-07-29T17:20:00+00:00",start:"17:20",duration:"00:10",room:"Green",slug:"juliacon-2022-18166-interplay-between-chaos-and-stochasticity-in-celestial-mechanics",url:"https://pretalx.com/juliacon-2022/talk/7Q8WXA/",title:"Interplay between chaos and stochasticity in celestial mechanics",subtitle:"",track:null,type:"Lightning talk",language:"en",abstract:"This work is focused on the development of an open-source Julia package for the stochastic characterization and the study of chaotic motion in astrodynamics. We focus on the computation of various chaos indicators, among others Fast Lyapunov Indicators (FLI), Finite-Time Lyapunov exponents (FTLE) and Mean Exponential Growth factor of Nearby Orbits (MEGNO) and chaos indicators more in general.",description:`Chaotic behavior is omnipresent in celestial mechanics dynamical systems and it is relevant for both the understanding and leveraging the stability of planetary systems, inner solar system in particular. The quantification of the probability of impacts of near Earth objects after close encounters with celestial bodies; the possibility of designing robust low energy transfer trajectories, not limited to invariant manifolds but also leveraging the weak stability boundary for the design of the ballistic captures trajectories in time-dependent dynamical systems; the characterization of diffusion processes in Nearly-Integrable Hamiltonian systems in celestial mechanics. In order to have a robust description of chaos, therefore being able to describe chaotic motion in the context of dynamical systems characterized by parametric uncertanties, and in parallel being able to investigate the effect of random perturbations (e.g. Langevin equation, jump-diffusion processes) this work builds on \u201CPolynomial Stochastic Dynamic Indicators\u201D (Vasile, Manzi) in which tools from functional analysis, such as orthogonal polynomials (e.g. PolyChaos.jl) and more in general feature maps coming from the theory of support vector machine and kernel methods are used to approximate the functional describing a positive measure defining the state of the system.\r
\r
This probabilistic generalizations of existing chaos indicators will be computed for a number of dynamical systems (e.g. Duffing oscillator, circular and elliptic restricted three-body problem, etc.) and the relevance of uncertainty quantification for robust trajectory design will be discussed.\r
\r
This framework will be used to understand the effect of uncertainty and stochasticity, on the behaviour of both individual trajectories and ensambles of trajectories coming from the sampling of the probabilistic space; the influence of this in the overall goal of predicting chaotic dynamical systems characterized by parametric uncertainties will be assessed. Bifurcating phenomena and invariant sets in time-dependant dynamical systems will be discussed, particularly in this context of Lagrangian coherent structures.\r
\r
Moreover, the relation between memory effects in non-Markovian processes, fractional calculus and time-delay embedding will be outlined using the aforementioned tools.\r
\r
The computational efficiency of numerical integration schemes of Ordinary and Stochastic Differential Equations will be exploited to produce animations describing bifurcating phenomena and the chaotic nature of dynamical systems.`,recording_license:"",do_not_record:!1,persons:[{id:18492,code:"ZG9LNM",public_name:"Matteo Manzi",biography:"Matteo is an aerospace engineer with a strong interest in dynamical systems theory and complex systems theory. After conducting research in the Horizon2020 network Stardust Reloaded, working on the use of Artificial Intelligence for Uncertainty Quantification in Orbital Mechanics, and working as a Flight Dynamics Software Engineer for the Space Debris Office of the European Space Agency, he is currently the CEO of MOD SRLS, a company focused on quantitative DeFi, stochastic modelling and uncertainty quantification in space engineering, but also on the interplay between Artificial Intelligence and Blockchain technology for the development of research protocols promoting transparency and reproducibility of software and methodologies, including academic publishing, in the context of DeSci.",answers:[]}],links:[],attachments:[],answers:[]},{id:17999,guid:"68691412-87e4-5a45-bbeb-427675fbab02",logo:"",date:"2022-07-29T17:30:00+00:00",start:"17:30",duration:"00:10",room:"Green",slug:"juliacon-2022-17999-how-to-be-an-effective-julia-advocate-",url:"https://pretalx.com/juliacon-2022/talk/TSQ8XC/",title:"How to be an effective Julia advocate?",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"A major part of Julia's success as a language has come from a large community of user advocates. User advocacy continues to be one of the most effective outreach mechanisms and this talk aims to help improve the approach of those seeking to advocate for Julia.",description:`This talk will share the lessons learned after speaking, posting, and presenting about Julia over the last 2+ years. It doesn't matter if you are an expert user or a novice, these principles will allow you to effectively highlight the benefits of Julia in a way that is conducive to the audience being receptive to Julia. \r
\r
We will cover: \r
- How to frame Julia as a language\r
- Sharing use cases\r
- What to avoid\r
- Getting people involved\r
And more!`,recording_license:"",do_not_record:!1,persons:[{id:1032,code:"UNR7XZ",public_name:"Logan Kilpatrick",biography:"Logan is the developer community advocate for the Julia programming language and was formerly the community manager. He is also on the Board of Directors at NumFOCUS and DEFNA. Outside of the Julia community, Logan is a senior technology advocate at PathAI leading ML and OSS advocacy.",answers:[]}],links:[],attachments:[],answers:[]},{id:18146,guid:"ff658cd2-ec95-5fba-b7b9-01571d8f01c8",logo:"/media/juliacon-2022/submissions/QTN3ZY/diggity-marketing-SB0WARG16HI-unsplash_nCyH4LJ.jpeg",date:"2022-07-29T17:40:00+00:00",start:"17:40",duration:"00:10",room:"Green",slug:"juliacon-2022-18146-optimize-your-marketing-spend-with-julia-",url:"https://pretalx.com/juliacon-2022/talk/QTN3ZY/",title:"Optimize your marketing spend with Julia!",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`"Half the money I spend on advertising is wasted; the trouble is I don't know which half." (J.Wanamaker, 19th-century retailer)\r
Optimizing marketing spend is still difficult, but this talk introduces a modern marketing analysis: Media Mix Modelling (MMM).\r
We will combine the strength of Julia with Bayesian decision-making to optimize marketing spend for a hypothetical business.\r
Find more details in the associated [GitHub Repo](https://github.com/svilupp/JuliaCon2022/)`,description:`This talk requires no previous knowledge.\r
\r
Media Mix Modelling (MMM) is the go-to analysis for deciding how to spend your precious marketing budget. It has been around for more than half a century, and its importance is poised to increase with the rise of the privacy-conscious consumer.\r
\r
There are a few key marketing concepts that we will cover, e.g., ad stock, saturation and ROAS.\r
\r
We will leverage the power of Bayesian inference with Turing.jl to establish the effectiveness of our campaigns (/marketing channels). The main advantage of the Bayesian approach will be the quantification of  uncertainty, which we will channel into our decision-making when deciding on the budget allocations.\r
\r
The "optimal" spend strategy ("budget") will be found with the help of Metaheuristics.jl.\r
Overall, we will draw on Julia's core strengths, such as composability and speed.\r
\r
The implementation closely follows the methodology of the amazing Robyn package, but it leverages Bayesian inference for the marketing parameters. While there are many resources available for Python and R, I believe this is the first tutorial for MMM in Julia.\r
\r
Following the talk, you can use the provided notebook and scripts to replicate this analysis for your marketing budget.\r
\r
You can find the notebook, presentation and additional resources in the following repository: \r
- [GitHub Repo](https://github.com/svilupp/JuliaCon2022/) \r
- [PDF of the presentation](https://github.com/svilupp/JuliaCon2022/blob/main/MediaMixModellingDemo/presentation/presentation.pdf)\r
\r
Session photo thanks to <a href="https://unsplash.com/@diggitymarketing?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Diggity Marketing</a> on <a href="https://unsplash.com/s/photos/digital-marketing?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>`,recording_license:"",do_not_record:!1,persons:[{id:18488,code:"DLUFRL",public_name:"Jan Siml",biography:"I'm Head of Data and Product Insight at LexisNexis.",answers:[]}],links:[],attachments:[],answers:[]},{id:21376,guid:"1a9be814-f1fd-5661-913f-5b150f8ce51b",logo:"",date:"2022-07-29T18:00:00+00:00",start:"18:00",duration:"01:00",room:"Green",slug:"juliacon-2022-21376-gathertown-social-break",url:"https://pretalx.com/juliacon-2022/talk/XLZ7ZN/",title:"GatherTown -- Social break",subtitle:"",track:null,type:"Social hour",language:"en",abstract:"Join us on [Gather.town](http://gather.town/) for a social hour.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:18082,guid:"be213c75-3fdf-51ce-aa29-5e1f5f47827b",logo:"/media/juliacon-2022/submissions/ZMKHUZ/image_4_KS3cRLS.png",date:"2022-07-29T19:00:00+00:00",start:"19:00",duration:"00:30",room:"Green",slug:"juliacon-2022-18082-large-scale-tabular-data-analytics-with-banyandataframes-jl",url:"https://pretalx.com/juliacon-2022/talk/ZMKHUZ/",title:"Large-Scale Tabular Data Analytics with BanyanDataFrames.jl",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"BanyanDataFrames.jl is an open-source library for processing massive Parquet/CSV/Arrow datasets in your Virtual Private Cloud. One of the key goals of the project is to match the API of DataFrames.jl as much as possible. In this talk, we will provide an overview of BanyanDataFrames.jl and discuss challenges and success so far in achieving massively scalable data analytics with the Julia language.",description:`More information about BanyanDataFrames.jl can be found on GitHub:\r
https://github.com/banyan-team/banyan-julia\r
https://github.com/banyan-team/banyan-julia-examples`,recording_license:"",do_not_record:!1,persons:[{id:10346,code:"MQTPBB",public_name:"Caleb Winston",biography:"I'm Caleb. I'm currently studying Computer Science at the University of Washington and will be doing research at Stanford next year. My research interests are quite broad and I have published work in areas including both brain-computer interfaces and wet lab automation and I would be happy to chat about these things. I'm also currently working on https://BanyanComputing.com. Outside of CS, I love composing music and playing the alto sax in an ensemble group with my siblings.",answers:[]},{id:10424,code:"CJVEWU",public_name:"Cailin Winston",biography:null,answers:[]}],links:[],attachments:[],answers:[]},{id:17920,guid:"b12052f9-017a-566e-a9d4-5af2366858c9",logo:"",date:"2022-07-29T19:30:00+00:00",start:"19:30",duration:"00:30",room:"Green",slug:"juliacon-2022-17920-how-to-debug-julia-simulation-codes-odes-optimization-etc-",url:"https://pretalx.com/juliacon-2022/talk/VVTKRB/",title:"How to debug Julia simulation codes (ODEs, optimization, etc.!)",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"The ODE solver spit out dt<dtmin, what do you do? MethodError Dual{...}, what does it mean? Plenty of people ask these questions every day. In this talk I'll walk through the steps of debugging Julia simulation codes and help you get something working!",description:`Debugging simulation codes can be very different from "standard" or "simple" codes. There's many details that can show up that the user needs to be aware of. Thus while there have been many beginner tutorials in using Julia, and many tutorials on how to using SciML ecosystem tools like DifferentialEquations.jl, there has never been a tutorial that says "okay, I got this error when using Optim.jl, what do I do now?". Some major pieces have been written which condense such information, such as the DifferentialEquations.jl PSA on Discourse (https://discourse.julialang.org/t/psa-how-to-help-yourself-debug-differential-equation-solving-issues/62489), but we believe there remains many things to say.\r
\r
And also, a video walkthrough is simply the best way to "show some how I do it" so to speak. \r
\r
So let's do it! But what would this entail? There are many topics to cover, including:\r
\r
- How to read the gigantic stack traces that arise from dual number issues. Why does f(du,u::Array{Float64},p,t) fail with this error? Why can dual numbers cause issues in some mutating code? How do you use https://github.com/SciML/PreallocationTools.jl to solve these Dual number issues?\r
- When trying to debug code deep within some package context, how do you do it in a "nice" way (i.e. without the slow interpreted mode of Debugger.jl)? The answer is using Revise with tools like \`@show\` and \`x=Ref{Any}()\` and then in the package you can do \`Main.x[] = ...\`. Never seen this trick before? Well then you'll be interested in this talk. We'll showcase how to use these tricks in real-world contexts where such debugging arises.\r
- When you get dt<dtmin or other ODE solver exit warnings? What are you supposed to do? u'=u^2-u with u(0)=2, oh wait analytically that should error? How do I find out if my model is written incorrectly (it is) and how do I figure out what I should be changing?\r
- When doing optimization, say using GalacticOptim.jl or Flux.jl, what are these "Zygote does not support mutation" errors? Why do they exist and how do I work around them?\r
- Everyone is asking for an MWE. How do I make a good MWE? How do I figure out what in the package that is likely causing the issue, and use this to help developers help me?\r
\r
I will continue to grow the list by keeping tabs on what comes up the most often in Github issues and Discourse posts. At the end of the day, I hope this can be a video that is pasted onto thousands of Discourse questions to give people a much more in-depth view of how to fix issues, and potentially train the next generation of "Discourse answerers".`,recording_license:"",do_not_record:!1,persons:[{id:904,code:"WUWQQ3",public_name:"Chris Rackauckas",biography:`Research Affiliate and Co-PI of the Julia Lab at the Massachusetts Institute of Technology\r
Director of Modeling and Simulation at Julia Computing and Creator / Lead Developer of JuliaSim\r
Director of Scientific Research at Pumas-AI and Creator / Lead Developer of Pumas\r
Lead Developer of the SciML Open Source Software Organization\r
\r
Chris Rackauckas\r
\r
Chris' research and software is focused on Scientific Machine Learning (SciML): the integration of domain models with artificial intelligence techniques like machine learning. By utilizing the structured scientific (differential equation) models together with the unstructured data-driven models of machine learning, our simulators can be accelerated, our science can better approximate the true systems, all while enjoying the robustness and explainability of mechanistic dynamical models.\r
\r
Chris's recent work is focused on bringing personalized medicine to standard medical practice through the proliferation of software for scientific AI. Chris is at the cutting edge of mathematical methods for scientific simulation. He is the lead developer of the DifferentialEquations.jl solver suite along with over a hundred other Julia packages, earning him the inaugural Julia Community Prize, an outstanding paper award at the IEEE-HPEC conference on computational derivation for the efficient stochastic differential equation solvers, and front page features on many tech community sites. Chris' work on high performance differential equation solving is the engine accelerating many applications from the MIT-CalTech CLiMA climate modeling initiative to the SIAM Dynamical Systems award winning DynamicalSystems.jl toolbox (of which DifferentialEquations.jl was the runner-up). His work is credited for the 15,000x acceleration of NASA Launch Services simulations and recently demonstrated a 60x-570x acceleration over Modelica tools. For these achievements Chris received the United States Department of the Air Force Artificial Intelligence Accelerator Scientific Excellence Award.\r
\r
Chris brought these enhanced numerical approaches to the domain of pharmaceutical modeling and simulation as the creator and lead developer of Pumas. Pumas is scientific AI in clinical practice. Pumas makes it possible to predict the optimal medication dosage for individuals, reducing the costs and potential complications associated with treatments. Pumas is being used by many major pharmasceuticals to predict personalized safe dosage regimens by incorporating realistic biological models (quantitative systems pharmacology) and deep learning into the traditional nonlinear mixed effects (NLME) modeling framework. These efforts on Pumas led to the International Society of Pharmacology's (ISoP) Mathematical and Computational Special Interest Group Award at the American Conference of Pharmacology (ACoP) 2019 for his work on improved clinical dosing via Koopman Expectations, along with the ACoP 2020 Quality Award for his work with Pfizer on GPU-accelerated quantitative systems pharmacology to accelerate preclinical analysis by 175x. Notably, Moderna adopted Pumas in 2020 to accelerate crucial clinical trials, noting "Pumas has emerged as our 'go-to' tool for most of our analyses in recent months". For these achievements, Chris received the Emerging Scientist award from ISoP, the highest early career award in pharmacometrics.\r
\r
Chris started this work while completing his Masters and Ph.D. at the University of California, Irvine where he was awarded the Mathematical and Computational Biology institutional fellowship, the Graduate Dean's Fellowship, the National Science Foundation's Graduate Research Fellowship, the Ford Predoctural Fellowship, the NIH T32 Predoctural Training Grant, the Center for Complex Biological Systesms Opportunity Award, and the Data Science Initiative Summer Fellowship. His research with his advisor, Dr. Qing Nie, focused on the methods for simulating stochastic biological models and detailing how the randomness inherent in biological organisms can be controlled using stochastic analysis. Chris bridged the gap between theory and practice by having a "wet lab bench" in Dr. Thomas Schilling's lab, where these methodologies were tested on zebrafish. Fluorescence Light Microscopy (FLIM) measurements of retinoic acid in the zebrafish hindbrain showed that the predicted control proteins could attenuate inherent biological randomness. The result was a verified mathematical theory for controlling the randomness in biological signaling. Chris received the Kovalevsky Outstanding Ph.D. Thesis Award from the Department of Mathematics upon graduation and was showcased in an interview "Interdisciplinary Case Study: How Mathematicians and Biologists Found Order in Cellular Noise" in Cell Press's iScience.\r
\r
As an undergraduate at Oberlin College, Chris was awarded the NSF S-STEM scholarship and the Margaret C. Etter Student Lecturer Award by the American Crystallographic Association, an award usually given for PhD dissertations, for his work on 3+1 dimensional incommensurate crystal structure identification of H-acid. This award was given for Service Crystallography for its potential impact on industrial dye manufacturing.`,answers:[]}],links:[],attachments:[],answers:[]},{id:18028,guid:"08acd7a2-de66-5edb-9e79-987f9408207f",logo:"",date:"2022-07-29T20:00:00+00:00",start:"20:00",duration:"00:30",room:"Green",slug:"juliacon-2022-18028-scaling-up-training-of-any-flux-jl-model-made-easy",url:"https://pretalx.com/juliacon-2022/talk/LJRHQR/",title:"Scaling up Training of Any Flux.jl Model Made Easy",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"In this talk, we will be discussing some of the state of the art techniques to scale training of ML models beyond a single GPU, why they work and how to scale your own ML pipelines. We will be demonstrating how we have scaled up training of Flux models both by means of data parallelism and by model parallelism. We will be showcasing ResNetImageNet.jl and DaggerFlux.jl to accelerate training of deep learning and scientific ML models such as PINNs and the scaling it achieves.",description:`With the scale of the datasets and the size of the models growing rapidly, one cannot reasonably train these models on a single GPU.  It is no secret that that training big ML models - be they large language models, image recognition tasks, large PINNs etc - requires an immense amount of hardware, and engineering knowledge.\r
\r
So far, our tools in FluxML have been limited to training on a single GPU, and there is a pressing need for tooling that can scale up training beyond a single GPU. This is important not just for current Deep Learning models but also to scale training of scientific machine learning models as we see more sophisticated neural surrogates emerge for simulations and modelling. To fulfil this need, we have developed some tools that can reliably and generically scale training of differentiable pipelines beyond a single machine or GPU device. We will be showcasing [ResNetImageNet.jl](https://github.com/DhairyaLGandhi/ResNetImageNet.jl) and [DaggerFlux.jl](https://github.com/FluxML/DaggerFlux.jl) which uses Dagger.jl to accelerate training of various model types and the scaling it achieves.`,recording_license:"",do_not_record:!1,persons:[{id:1160,code:"83D8SQ",public_name:"Dhairya Gandhi",biography:"I am a data scientist at Julia Computing, and also the core developer in the FluxML ecosystem.",answers:[]}],links:[],attachments:[],answers:[]},{id:21380,guid:"95eb8154-cfdb-5cc4-bb42-2158d2abe79e",logo:"",date:"2022-07-29T20:30:00+00:00",start:"20:30",duration:"01:00",room:"Green",slug:"juliacon-2022-21380-gathertown-social-break",url:"https://pretalx.com/juliacon-2022/talk/FSDULA/",title:"GatherTown -- Social break",subtitle:"",track:null,type:"Social hour",language:"en",abstract:"Join us on [Gather.town](http://gather.town/) for a social hour.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]}],Red:[{id:17962,guid:"6a7c8859-8bbb-525c-ad90-0d086b3d1723",logo:"",date:"2022-07-29T12:30:00+00:00",start:"12:30",duration:"00:30",room:"Red",slug:"juliacon-2022-17962-fractional-order-computing-and-modeling-with-julia",url:"https://pretalx.com/juliacon-2022/talk/UQNLK3/",title:"Fractional Order Computing and Modeling with Julia",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"As the generalization of classical calculus and differential equations, fractional calculus and fractional differential equations are important areas since their invention, to provide a comprehensive Differential Equations package, [SciFracX](https://github.com/SciFracX) is here to explore fractional order area with Julia. In 2022 JuliaCon, we will talk about the progress we have made in FractionalDiffEq.jl and FractionalCalculus.jl, how Julia helped us speed up fractional order modeling and com",description:'In 1695, a letter from L\'Hopital to Leibniz represented the birth of the fractional calculus, "Can the meaning of derivatives with integer order be generalized to derivatives with non-integer orders? What if the order will be 1/2?", Leibniz replied in September 30, 1965: "It will lead to a paradox, from which one day useful consequences will be drawn".\r\n	\r\nFractional order computing and modeling has become a more and more appealing topic especially recent decades, natural models usually can be more elaborated in fractional order area. Dating back to Leibniz and L\'Hopital raised the "non-integer" calculus question, many giants of science have make hard work on fractional calculus to promote its further development. Fractional calculus are very helpful in describing linear viscoelasticity, acoustics, rheology, polymeric chemistry, and so forth. Moreover, fractional derivatives have been proved to be a very suitable tool for the description of memory and hereditary properties of various materials and processes.\r\n\r\nSciML organization has done outstanding work in numerical solvers for differential equations, but there are still some kinds of differential equations that SciML has [not supported yet](https://github.com/SciML/DifferentialEquations.jl/issues/461), as the generalization of integer order differential equations, fractional calculus and fractional differential equations began to attract increasing interest for its important role in science and engineering since early 20th century. While most of the numerical software are programmed using Matlab and are not well maintained, users didn\'t have unifying tools to help with fractional order modeling and computing, being inspired by SciML, we initiated SciFracX organization. Our mission is to make the fractional order computing and modeling more easier using Julia, speed up researches and provides powerful scientific researching tools. Right now, there are four Julia packages in this organization: FractionalSystems.jl, FractionalCalculus.jl, FractionalDiffEq.jl and FractionalTransforms.jl. We would introduce the FractionalSystems.jl, FractionalDiffEq.jl and FractionalCalculus.jl packages.\r\n\r\nThe [FractionalSystems.jl](https://github.com/SciFracX/FractionalSystems.jl) package is a package focus on fractional order control, inspired by [FOMCON](https://fomcon.net/) and [FOTF](https://www.mathworks.com/matlabcentral/fileexchange/60874-fotf-toolbox) toolbox, FractionalSystems.jl aims at providing fractional order modeling with Julia. Building on [ControlSystems.jl](https://github.com/JuliaControl/ControlSystems.jl), FractionalSystems.jl provides similar  functionalities with ControlSystems.jl, mainly time domain and frequency domain modeling and analysis. While FractionalSystems.jl is only several months old, there are still a lot we need to do in the future.\r\n\r\nThe [FractionalDiffEq.jl](https://github.com/SciFracX/FractionalDiffEq.jl) package follows the design pattern of DifferentialEquations.jl. To solve a problem, we first define a ```***Problem``` according to our model, then pass the defined problem to ```solve``` function and choose an algorithm to solve our problem.\r\n\r\n```julia\r\nprob = ***Problem(fun, \u03B1, u0, T)\r\n#prob = ***Problem(parrays, oarrays, RHS, T)\r\nsolve(prob, h, Alg())\r\n```\r\n\r\nNow, FractionalDiffEq.jl is capable of solving fractional order ODE, PDE, DDE, integral equations and nonlinear FDE systems, what impressed us the most is two times speedup compared to MATLAB when we were trying to solve the same problem in Julia(Didn\'t use any performance optimization)\r\n\r\n[FractionalCalculus.jl](https://github.com/SciFracX/FractionalCalculus.jl) has supports for common sense of fractional derivative and  integral, including Caputo, Riemann Liouville, Hadamard and Riesz sense etc. To keep it simple and stupid, we use two intuitive function ```fracdiff``` for fractional derivative and ```fracint``` for fractional integral. All we need to do is to pass the function, order, specific point, step size and which algorithm we want to use.\r\n\r\n```julia\r\nfracdiff(fun, \u03B1, point, h, Alg())\r\n```\r\n\r\n```julia\r\nfracint(fun, \u03B1, point, h, Alg())\r\n```\r\n\r\nBy using Julia in fractional order computing and modeling, we indeed observed amazing progress in no matter [the speed](http://scifracx.org/FractionalDiffEq.jl/dev/system_of_FDE/#System-of-fractional-differential-equations) or the ease of use in fractional order modeling and computing.\r\n\r\nWhile there are no such similar organizations in Python or R community doing high performance computing in fractional order area, the future of SciFracX is promising, we envision a bright future for using Julia in fractional order area. Our work of next round is clear:\r\n\r\n* Keep adding more high performance algorithms.\r\n* Make the usage of API more simple and elegant.\r\n* Write more illustrative documents for usability. \r\n* Integrate with the SciML ecosystem to provide users more useful features.',recording_license:"",do_not_record:!1,persons:[{id:16490,code:"3AZBYK",public_name:"Qingyu Qu",biography:"Developer and maintainer of [SciFracX](https://github.com/SciFracX), interested in differential equations and fractional order modeling.",answers:[]}],links:[],attachments:[],answers:[]},{id:17959,guid:"ab2c3943-c683-525b-8dbf-75b924858d91",logo:"/media/juliacon-2022/submissions/X89FYS/PSFs.jl_Demo_ldm8gKK.png",date:"2022-07-29T13:00:00+00:00",start:"13:00",duration:"00:30",room:"Red",slug:"juliacon-2022-17959-pointspreadfunctions-jl-optical-point-spread-functions",url:"https://pretalx.com/juliacon-2022/talk/X89FYS/",title:"PointSpreadFunctions.jl - optical point spread functions",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Various ways of calculating three-dimensional optical point spread functions (PSFs) are presented. The methods account for the vector nature of the optical field as well as phase aberrations. Quantitative comparisons in terms of speed and accuracy will be presented.",description:`Methods of calculating optical point spread functions (PSFs) calculated by the toolbox https://github.com/RainerHeintzmann/PointSpreadFunctions.jl\r
are presented. These methods range from propagating field components via the angular spectrum method using Fourier-transforms to a version that applies spatial constraints in each propagation step to avoid wrap-around effects. Another method starts with the analytical solution, sinc(r), with r denoting the distance to the focus, of a related scalar problem, which is then modified to account for various influences of high-NA aplanatic optical systems.\r
The toolbox supports aberrations as specified via Zernike coefficients.\r
\r
The toolbox also contains practical tools such as a PSF distillation tool which automatically identifies single point sources and averages their measured images with sub-pixel precision.\r
\r
Future directions may include ways to identify aberrations from measured PSFs. \r
The toolbox will also be extended towards supporting a wider range of microscopy modes.`,recording_license:"",do_not_record:!1,persons:[{id:10334,code:"CNV3SE",public_name:"Rainer Heintzmann",biography:`Rainer Heintzmann works as a research head and university professor at the Leibniz Institute of Photonic Technology and the Friedrich Schiller University Jena.\r
His research focuses on imaging cellular function at high resolution. His group develops techniques to measure multidimensional information in small biological objects such as cells, cellular organelles or other small structures of interest. A further interest is in computer-based reconstruction methods.\r
Software packages in Julia and other languages are developed for scientific computing and visualization with a special focus on optics and deconvolution.`,answers:[]},{id:9921,code:"U3YH9P",public_name:"Felix Wechsler",biography:`[Felix Wechsler](https://felixwechsler.science/) is a PhD student at the Leibniz Institute of Photonic Technology and the Friedrich Schiller University of Jena. Before that, Felix obtained Bachelor degrees in physics and informatics where he worked on Light Field Microscopy and Schlieren Imaging.\r
In his master thesis, he developed a novel kaleidoscopic microscope, the Kaleidomicroscope.\r
His recent work is implemented in Julia Lang and he is maintainer of several microscopy related packages written in Julia Lang.`,answers:[]}],links:[],attachments:[],answers:[]},{id:17195,guid:"82e3ef46-7021-58f2-8156-561fd77614dc",logo:"/media/juliacon-2022/submissions/ZSCNR7/logo_YlQUJC4.png",date:"2022-07-29T16:30:00+00:00",start:"16:30",duration:"00:30",room:"Red",slug:"juliacon-2022-17195-control-systems-analysis-and-design-with-juliacontrol",url:"https://pretalx.com/juliacon-2022/talk/ZSCNR7/",title:"Control-systems analysis and design with JuliaControl",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"The Julia language is uniquely suitable for control-systems analysis and design. Features like a mathematical syntax, powerful method overloading, strong and generic linear algebra, arbitrary-precision arithmetics, all while allowing high performance, creates a compelling platform to build a control ecosystem upon. We will present the JuliaControl packages and illustrate how they make use of Julia to enable novel and sophisticated features while keeping implementations readable and maintainable.",description:`The control engineer typically carries a large metaphorical toolbox, full of both formal algorithms and heuristic methods. Mathematical modeling, simulation, system identification, frequency-domain analysis and uncertainty modeling and quantification are typical examples of elements of a control-design workflow, all of which may be required to complete a control project. Bits and pieces of this workflow have been present in open-source packages for a long time, but a comprehensive and integrated solution has previously been limited to proprietary and/or legacy languages. \r
\r
[JuliaControl](https://github.com/JuliaControl/) has been around since 2015, and has steadily grown into a highly capable, open-source ecosystem for control using linear methods. With comparatively low effort, algorithms and data structures in the ecosystem have been made generic with respect to the number type used, opening the doors for high-precision arithmetics, uncertainty propagation, automatic differentiation and symbolic computations in every step of the control workflow from simulation to design and verification. We believe that this feature is unique among control software, and will demonstrate its usefulness to the control theorist and engineer with a few examples.\r
\r
While JuliaControl is largely limited in scope to linear control methods, the full breadth of the scientific computing ecosystem in Julia is just around the corner, offering nonlinear optimization, optimal control, and equation-based modeling and simulation. In this talk, we will demonstrate how JuliaControl interoperates with [ModelingToolkit](https://github.com/SciML/ModelingToolkit.jl/) and the [DifferentialEquations](https://diffeq.sciml.ai/stable/) ecosystem to extend the scope of the capabilities to simulation and design for nonlinear control systems.\r
\r
Finally, we will share some of the control-related developments in the proprietary [JuliaSim](https://juliacomputing.com/products/juliasim/) platform, offering advanced functionality like controller autotuning, nonlinear Model-Predictive Control (MPC) and LMI-based methods (Linear Matrix Inequality) for robust analysis and design.`,recording_license:"",do_not_record:!1,persons:[{id:4444,code:"DGDNGV",public_name:"Fredrik Bagge Carlson",biography:"I received my MSc and PhD 2019 from the Dept. Automatic Control in Lund, Sweden, working within the fields of control, machine learning and robotics. I have since spent a year with the Acoustic Research Laboratory at NUS and subsequently made the transition to industry, working with dynamic modeling, control and programming-language design in a robotics context. I am now working with Julia Computing on software tools for acausal modeling, simulation, optimization and control in the Julia programming language.",answers:[]}],links:[],attachments:[],answers:[]},{id:17904,guid:"0660ead0-0d68-5bc7-8969-36243aa58dc7",logo:"/media/juliacon-2022/submissions/HU8FVH/juliacon_EFHHMx8.gif",date:"2022-07-29T17:00:00+00:00",start:"17:00",duration:"00:30",room:"Red",slug:"juliacon-2022-17904-explaining-black-box-models-through-counterfactuals",url:"https://pretalx.com/juliacon-2022/talk/HU8FVH/",title:"Explaining Black-Box Models through Counterfactuals",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"We propose [`CounterfactualExplanations.jl`](https://www.paltmeyer.com/CounterfactualExplanations.jl/dev/): a package for explaining black-box models through counterfactuals. Counterfactual explanations are based on the simple idea of strategically perturbing model inputs to change model predictions. Our package is novel, easy-to-use and extensible. It can be used to explain custom predictive models including those developed and trained in other programming languages.",description:`### The Need for Explainability \u2B1B\r
\r
Machine learning models like deep neural networks have become so complex, opaque and underspecified in the data that they are generally considered as black boxes. Nonetheless, they often form the basis for data-driven decision-making systems. This creates the following problem: human operators in charge of such systems have to rely on them blindly, while those individuals subject to them generally have no way of challenging an undesirable outcome:\r
\r
> \u201CYou cannot appeal to (algorithms). They do not listen. Nor do they bend.\u201D\r
> \u2014 Cathy O'Neil in *Weapons of Math Destruction*, 2016\r
\r
### Enter: Counterfactual Explanations \u{1F52E}\r
\r
Counterfactual Explanations can help human stakeholders make sense of the systems they develop, use or endure: they explain how inputs into a system need to change for it to produce different decisions. Explainability benefits internal as well as external quality assurance. Explanations that involve realistic and actionable changes can be used for the purpose of algorithmic recourse (AR): they offer human stakeholders a way to not only understand the system's behaviour, but also strategically react to it. Counterfactual Explanations have certain advantages over related tools for explainable artificial intelligence (XAI) like surrogate eplainers (LIME and SHAP). These include:\r
\r
- Full fidelity to the black-box model, since no proxy is involved. \r
- Connection to Probabilisitic Machine Learning and Causal Inference.\r
- No need for (reasonably) interpretable features.\r
- Less susceptible to adversarial attacks than LIME and SHAP.\r
\r
### Problem: Limited Availability in Julia Ecosystem \u{1F614}\r
\r
Software development in the space of XAI has largely focused on various global methods and surrogate explainers with implementations available for both Python and R. In the Julia space we have only been able to identify one package that falls into the broader scope of XAI, namely [\`ShapML.jl\`](https://github.com/nredell/ShapML.jl). Support for Counterfactual Explanations has so far not been implemented in Julia. \r
\r
### Solution: \`CounterfactualExplanations.jl\` \u{1F389}\r
\r
Through this project we aim to close that gap and thereby contribute to broader community efforts towards explainable AI. Highlights of our new package include:\r
\r
- **Simple and intuitive interface** to generate counterfactual explanations for differentiable classification models trained in Julia, Python and R.\r
- **Detailed documentation** involving illustrative example datasets and various counterfactual generators for binary and multi-class prediction tasks.\r
- **Interoperability** with other popular programming languages as demonstrated through examples involving deep learning models trained in Python and R (see [here](https://www.paltmeyer.com/CounterfactualExplanations.jl/dev/tutorials/interop/)).\r
- **Seamless extensibility** through custom models and counterfactual generators (see [here](https://www.paltmeyer.com/CounterfactualExplanations.jl/dev/tutorials/models/)). \r
\r
### Ambitions for the Package \u{1F3AF}\r
\r
Our goal is to provide a go-to place for counterfactual explanations in Julia. To this end, the following is a non-exhaustive list of exciting future developments we envision:\r
\r
1. Additional counterfactual generators and predictive models.\r
2. Additional datasets for testing, evaluation and benchmarking.\r
3. Improved preprocessing including native support for categorical features.\r
4. Support for regression models.\r
\r
The package is designed to be extensible, which should facilitate contributions through the community.\r
\r
### Further Resources \u{1F4DA}\r
\r
For some additional colour you may find the following resources helpful:\r
\r
- [Slides](https://www.paltmeyer.com/CounterfactualExplanations.jl/dev/resources/juliacon22/presentation.html#/title-slide).\r
- [Blog post](https://towardsdatascience.com/individual-recourse-for-black-box-models-5e9ed1e4b4cc) and [motivating example](https://www.paltmeyer.com/CounterfactualExplanations.jl/dev/cats_dogs/).\r
- Package docs: [[stable]](https://pat-alt.github.io/CounterfactualExplanations.jl/stable), [[dev]](https://pat-alt.github.io/CounterfactualExplanations.jl/dev).\r
- [GitHub repo](https://github.com/pat-alt/CounterfactualExplanations.jl).`,recording_license:"",do_not_record:!1,persons:[{id:17382,code:"8DGYCX",public_name:"Patrick Altmeyer",biography:`I am an economist and computer scientist currently studying for a PhD in Trustworthy Artificial Intelligence (AI) at Delft University of Technology. My research is on the intersection of AI and Financial Economics. In particular, I'm interested in Explainable AI, Counterfactual Explanations, Bayesian ML and Causal Inference and their applications to Financial Economics.\r
\r
Previously, I worked as an economist for Bank of England where I was involved in research, monetary policy briefings and market intelligence. I hold bachelor's and master's degrees in Economics, Finance and Data Science.`,answers:[]}],links:[],attachments:[],answers:[]},{id:18004,guid:"cd91acfa-ec58-5816-a714-e0ad1196f89c",logo:"",date:"2022-07-29T17:30:00+00:00",start:"17:30",duration:"00:30",room:"Red",slug:"juliacon-2022-18004-building-an-immediate-mode-gui-imgui-from-scratch",url:"https://pretalx.com/juliacon-2022/talk/GXTYSA/",title:"Building an Immediate-Mode GUI (IMGUI) from scratch",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:`Broadly, there are two paradigms of interfacing with a UI library to create a Graphical User Interface (GUI) - Retained-Mode (RM) and Immediate-Mode (IM). This talk is for anyone who wants to understand how to make an immediate-mode GUI from scratch. I will explain the inner workings of an immediate-mode UI library and show one possible way to implement simple widgets like buttons, sliders, and text-boxes from scratch.\r
\r
Link: https://github.com/Sid-Bhatia-0/SimpleIMGUI.jl`,description:`Needless to say, Graphical User Interfaces (GUIs) are used in a wide variety of applications. For example, several desktop applications like web browsers, computer games etc. have some form of a GUI. Typically, a GUI has some widgets like buttons, text-boxes etc. and the user can interact with those widgets with the help of a mouse or a keyboard in order to use the application.\r
\r
Broadly, there are two paradigms of interfacing with a UI library to create a GUI - Retained-Mode (RM) and Immediate-Mode (IM). This talk is for anyone who wants to understand how to make an immediate-mode GUI from scratch. I will attempt to explain the inner workings of an immediate-mode UI library and show one possible way to implement simple widgets like buttons, sliders, and text-boxes from scratch.\r
\r
We will look at one possible way to structure the render loop for a desktop application and dive deeper into input handling and widget interaction. The goal is to strip out as many unnecessary features as possible and explain the barebones structure of how to make an IMGUI from scratch. For this purpose, I will stick to the lightweight libraries GLFW.jl (to create and manage windows) and SimpleDraw.jl (to draw the user interface).\r
\r
SimpleIMGUI.jl: https://github.com/Sid-Bhatia-0/SimpleIMGUI.jl\r
Supplementary material: https://github.com/Sid-Bhatia-0/JuliaCon2022Talk`,recording_license:"",do_not_record:!1,persons:[{id:11534,code:"SYTUPE",public_name:"Siddharth Bhatia",biography:"-",answers:[]}],links:[],attachments:[],answers:[]},{id:17984,guid:"a5299778-b0f0-51d0-9ec2-92ee146209db",logo:"/media/juliacon-2022/submissions/878K9K/logo_rL3VOk5.png",date:"2022-07-29T19:00:00+00:00",start:"19:00",duration:"00:30",room:"Red",slug:"juliacon-2022-17984-genedrive-jl-simulate-and-optimize-biological-interventions",url:"https://pretalx.com/juliacon-2022/talk/878K9K/",title:"GeneDrive.jl: Simulate and Optimize Biological Interventions",subtitle:"",track:null,type:"Talk",language:"en",abstract:"This talk introduces GeneDrive.jl, a package designed to study the effect of biotic and abiotic interactions on metapopulations, outlining functionalities and use cases. GeneDrive.jl is a 3-part framework for building and analyzing simulations wherein organisms are subjected to anthropogenic and environmental change. It includes: (1) Data models that exploit the power of Julia's type system. (2) Dynamic models that build on DifferentialEquations.jl. (3) Decision models that employ JuMP.jl.",description:`Understanding and controlling biological dynamics is a concern in arenas as diverse as public health, agriculture, or conservation. Both environmental and human factors influence those dynamics, often in complex ways. Decisions about the timing, magnitude, and location where interventions are required to control the presence of harmful organisms \u2013 be they disease vectors, crop pests, or invasive species \u2013 must be made amid this ever-changing reality of biotic and abiotic interactions. \r
\r
The GeneDrive.jl package facilitates replicable, scalable, and extensible computational experiments on the topic of biological dynamics and control by drawing on several pre-existing tools within the Julia ecosystem. It formalizes Julia data structures to store information and dispatch methods unique to species and genotype, enabling the straightforward incorporation of empirical knowledge. Once constructed, problems can be solved using either dynamic or optimization methods by building on the extensively developed DifferentialEquations.jl and JuMP.jl packages. \r
\r
This one-time specification of the experimental data, on which both ODE and optimization solving algorithms can be called, encourages experimentation with operational levers in addition to biological ones. GeneDrive.jl employs mathematical programming for its optimization routines rather than the optimal control approaches more common in the biological sciences. This enables the inclusion of more detailed genetic and ecological information than would otherwise be tractable. \r
\r
The origin of this package\u2019s name, gene drives, are DNA sequences that spread through a population at higher frequencies than Mendelian inheritance patterns. These tools furnish a promising new approach to the mitigation of diseases carried by mosquito vectors and circumvent the problems of traditional prevention practices (e.g., growing insecticide resistance). GeneDrive.jl is applicable to biological tools beyond gene drive (see examples in the documentation), however, it is named in honor of this new technological horizon.`,recording_license:"",do_not_record:!1,persons:[{id:3940,code:"QTQ3YB",public_name:"Valeri Vasquez",biography:`PhD candidate, University of California Berkeley \r
MS, Electrical Engineering and Computer Sciences\r
MS, Energy and Resources`,answers:[]}],links:[],attachments:[],answers:[]}],Purple:[{id:18035,guid:"424fae97-13bb-5299-a800-1c3de4e046da",logo:"/media/juliacon-2022/submissions/KKBXAZ/hello-julia_dzCQKrs.png",date:"2022-07-29T12:30:00+00:00",start:"12:30",duration:"00:30",room:"Purple",slug:"juliacon-2022-18035-reproducible-publications-with-julia-and-quarto",url:"https://pretalx.com/juliacon-2022/talk/KKBXAZ/",title:"Reproducible Publications with Julia and Quarto",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Quarto is an open-source scientific and technical publishing system that builds on standard markdown with features essential for scientific communication. The system has support for reproducible embedded computations, equations, citations, crossrefs, figure panels, callouts, advanced layout, and more. In this talk we'll explore the use of Quarto with Julia, describing both integration with IJulia and the Julia VS Code extension, as well as areas for future improvement and exploration.",description:`Quarto is an open-source scientific and technical publishing system that builds on standard markdown with features essential for scientific communication. One of the most important enhancements is embedded computations, which enable documents to be fully reproducible. There are also a wide variety of technical authoring features including equations, citations, crossrefs, figure panels, callouts, advanced layout, and more. In this talk we'll explore the use of Quarto with Julia, describing both integration with IJulia and the Julia VS Code extension, as well as areas for future improvement and exploration.\r
\r
Quarto is built on Pandoc and as a result can target dozens of output formats including HTML, PDF, MS Word, OpenOffice, and ePub. Quarto also includes a project system that enables publishing collections of documents as a blog, full website, or book. Output formats are extensible, making it possible to create Journal ready LaTeX and HTML output from the same source code. Several examples of creating these output types with Julia will be presented, and we will take advantage of integration between the Quarto and Jupyter VS Code extensions to demonstrate productive workflows.\r
\r
After reviewing the basics of the system and presenting examples, we'll dive more into the technical details of how Quarto works. One of the things that makes Pandoc so capable is that it is not merely a markdown system but rather a generalized system for computing on documents. We'll describe the Pandoc AST for documents and how users of Quarto can write filters to transform the AST during rendering. Examples of filters authored with both Lua (the Pandoc embedded language for filters) and Julia (via the PandocFilters.jl package) will be presented.\r
\r
Embedded computations present the opportunity for fully reproducible workflows, but also create new performance challenges. The system needs to support expensive, long-running computations but at the same time interactive and iterative use (especially for content authoring). Quarto includes a variety of facilities for managing these tradeoffs, including daemonized Jupyter kernels for interactive use, caching computations, and the ability to freeze computational documents. We'll demonstrate using all of these techniques with Julia, and discuss their benefits, drawbacks, and potential for future improvement.\r
\r
Quarto interfaces with embedded Julia code using its Juptyer computational engine and the IJulia kernel. Documents can be authored in either a plain text markdown format or as Jupyter notebooks. There are several other literate programming systems available in the Julia ecosystem (Pluto, Neptune, Weave.jl, etc.) which have their own benefits and tradeoffs. We'll discuss why we chose IJulia along with an exploration of how we could integrate with other systems.`,recording_license:"",do_not_record:!1,persons:[{id:18419,code:"SRH9KJ",public_name:"J.J. Allaire",biography:"J.J. Allaire is the founder of RStudio and the creator of the RStudio IDE. J.J. is an author of several packages in the R Markdown publishing ecosystem including rmarkdown, flexdashboard, learnr, and distill. J.J. is now the technical lead of the Quarto project, which aims to apply the lessons learned from 10 years of R Markdown to create a new system that is fundamentally multi-language and multi-engine.",answers:[]}],links:[],attachments:[],answers:[]},{id:18008,guid:"0d29e3d4-9273-5719-9400-71b6f98e974e",logo:"",date:"2022-07-29T13:00:00+00:00",start:"13:00",duration:"00:10",room:"Purple",slug:"juliacon-2022-18008-wheretraits-jl-has-now-a-disambiguity-resolution-system-",url:"https://pretalx.com/juliacon-2022/talk/ME9GW8/",title:"WhereTraits.jl has now a disambiguity resolution system!",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`When [WhereTraits.jl](https://github.com/jolin-io/WhereTraits.jl) was published 2 years ago, the key missing feature was to address ambiguations between traits function definitions. It is implemented now!\r
\r
If you as a user encounter a trait conflict, you are now prompted with a concrete example resolution. You simply specify an ordering between the traits and everything is resolved automatically for you.\r
A feature only available in WhereTraits - even normal julia functions cannot do this.`,description:`Method disambiguation is one of the top julia problems which can become tricky to resolve. This is especially true, if one of your dependent packages defined one conflicting part, and another package defined the other part. As a user, you just want to say that the one function should be used instead of the other. Unfortunately, that is not possible, and instead you have to look into the actual source code and implement a resolution yourself.\r
\r
The same problem occurs to traits, and maybe even more pronounced. If your function has two different traits specializations, let's say one for \`MyAwesomeTrait\` and another for \`GreatGreatTrait\`, it is unclear what to do if your type is both a MyAwesomeTrait and a GreatGreatTrait. You will get exactly such a Method Disambiguation Error.\r
\r
WhereTraits.jl resolved this difficulty in its most recent release by adding extra support for an ordering between traits, which is used for automatic disambiguation. I.e. the user gets exactly the mentioned power of deciding that the one trait should be preferred over the other. And all this without any performance penalty. The disambiguation system is defined such that traits definition and traits ordering can be in different packages and can be defined multiple times, making the system very flexible and generic.\r
\r
This new feature is outstanding as even normal Julia function dispatch does not support it.\r
\r
In this talk I am going to present this new feature, and explain how it is implemented.`,recording_license:"",do_not_record:!1,persons:[{id:4390,code:"MJPZGQ",public_name:"Stephan Sahm",biography:`Stephan Sahm founded [Jolin.io](https://www.jolin.io), an IT consultancy for high-performant data/ml pipelines powered by Julia. He also organises the biggest Julia meetup in Germany, Julia-User-Group-Munich.\r
With 10 years experience in data science and 5 years in IT consultancy and data-startups, he strives to bring tomorrows best practice into todays business.\r
\r
Julia packages developed by Stephan Sahm: Continuables.jl, WhereTraits.jl, ExprParsers.jl, TypeClasses.jl, ExtensibleEffects.jl and more.`,answers:[]}],links:[],attachments:[],answers:[]},{id:21254,guid:"5be4901e-aa4c-5ac8-8239-844317607fab",logo:"",date:"2022-07-29T13:10:00+00:00",start:"13:10",duration:"00:05",room:"Purple",slug:"juliacon-2022-21254-invenia-sponsored-talk",url:"https://pretalx.com/juliacon-2022/talk/FTMX73/",title:"Invenia Sponsored Talk",subtitle:"",track:null,type:"Silver sponsor talk",language:"en",abstract:"We are a team of scientists and engineers working together to solve the social, economic and environmental issues that we face in the world today.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:21240,guid:"a423ee61-6869-5dcf-8857-2f44fa38c365",logo:"",date:"2022-07-29T13:15:00+00:00",start:"13:15",duration:"00:45",room:"Purple",slug:"juliacon-2022-21240-juliacon-experiences",url:"https://pretalx.com/juliacon-2022/talk/PTFQER/",title:"Juliacon Experiences",subtitle:"",track:null,type:"BoF (45 mins)",language:"en",abstract:"This session hosts all of this year's experience talks.",description:"",recording_license:"",do_not_record:!1,persons:[{id:18505,code:"R7DNJC",public_name:"Julia Frank",biography:`Undergraduate physics student (starting an MSc Physics degree in May 2022) from Canada. \r
Blogging about Julia Language and physics.`,answers:[]},{id:18503,code:"AKYARE",public_name:"Agustin Covarrubias",biography:"Estudiante de ingenier\xEDa en UC | Chile que hace un poco de todo, nada especialmente bien. Trabajo como Jefe de Plataformas Digitales en la Fundaci\xF3n Am\xE9rica Transparente.",answers:[]},{id:18480,code:"KE7RJF",public_name:"Valeria Perez",biography:`Valeria P\xE9rez is a 24 year-old mexican programmer living in Monterrey, M\xE9xico. She studied Applied Mathematics at the Tecnol\xF3gico Aut\xF3nomo de M\xE9xico (ITAM). She graduated in 2020 and worked at the Instituto Mexicano del Seguro Social (IMSS) the largest health provider in M\xE9xico as a junior developer helping with models regarding the COVID-19 pandemic. Currently, she is working in her bachelor thesis and looking to work developing software for techonology companies. \r
Valeria knows how to program in R, Python and Julia. She is a fluent speaker and writer in English and Spanish. Her passions include gender equality, dance, running and reading.`,answers:[]},{id:10410,code:"MCGB3X",public_name:"Saranjeet Kaur Bhogal",biography:`Saranjeet is a Statistician based in India. She has written the first draft of the R Development Guide under the mentorship of Heather Turner and Micheal Lawrence, funded by the R Foundation. Furthermore, she is supporting Heather Turner in the work on the outreach of the R Development Guide at the Digital Infrastructure Incubator at Code for Science & Society. Saranjeet has also worked with the Julia Language organization for Google Summer of Code 2020. She is eager to learn about open source and open science practices. Saranjeet co-founded the Research Software Engineering (RSE) Asia Association during her participation in the Cohort 4 of the Open Life Science program, to promote the RSE community and profession in the Asia region. She is being mentored by Michelle Barker to build the RSE Asia community. Recently she has been selected in the founding committee of NumFOCUS Project Incubator. This Incubator is designed to support the growth of open source scientific projects and communities.\r
Personal website: https://saranjeetkaur.github.io/About-Me/`,answers:[]},{id:18469,code:"SXHELN",public_name:"Marina Cagliari",biography:"I am a PhD student who works in cosmology and the analysis of cosmological surveys.",answers:[]},{id:17382,code:"8DGYCX",public_name:"Patrick Altmeyer",biography:`I am an economist and computer scientist currently studying for a PhD in Trustworthy Artificial Intelligence (AI) at Delft University of Technology. My research is on the intersection of AI and Financial Economics. In particular, I'm interested in Explainable AI, Counterfactual Explanations, Bayesian ML and Causal Inference and their applications to Financial Economics.\r
\r
Previously, I worked as an economist for Bank of England where I was involved in research, monetary policy briefings and market intelligence. I hold bachelor's and master's degrees in Economics, Finance and Data Science.`,answers:[]},{id:18440,code:"LCUASZ",public_name:"Garrek Stemo",biography:"PhD candidate in physical chemistry and molecular science at the Nara Institute of Science and Technology.",answers:[]},{id:18437,code:"3EY8FS",public_name:"Jeremiah Lasquety-Reyes",biography:"Jeremiah Lasquety-Reyes is a digital market analyst based in Hamburg, Germany. He uses R and Python on a daily basis, but has recently started to turn his sights on Julia, especially for the purpose of agent-based modeling.",answers:[]},{id:18424,code:"BQF8LN",public_name:"Dr. Vikas Negi",biography:"I currently work as a Metrology Design Engineer at ASML in the Netherlands. I love coding, and my language of choice is Julia. Besides that, I occasionally tinker with my Raspberry Pi. My other hobbies include listening to podcasts (big fan of Lex Fridman) during long walks, running and watching new shows/documentaries on Netflix. I am also a proud owner of a custom built PC and a Xbox One S. Whenever time permits, I dabble with Web 3.0 and blockchain based technologies. Curious to know more? Feel free to visit my web3 powered [site](https://vikasnegi.eth.link/).",answers:[]},{id:18417,code:"JFZQZ7",public_name:"Martin Smit",biography:`Hello, my name is Jacobus Smit, but you can call me Martin (derived from my second name). My pronouns are he/him. I just finished the Oxford Master's in Mathematical Sciences (OMMS) at St Cross college and will be starting my PhD in the Socially Intelligent Artificial Systems group at the University of Amsterdam.\r
\r
I love computational mathematics and statistics, especially their applications to social sciences such as economics and sociology. I author and maintain the TernaryPlots.jl.`,answers:[]},{id:18411,code:"NFBXZN",public_name:"F\xE1bio Rodrigues Sodr\xE9",biography:`Analista programador web, gamer, apaixonado por leitura e futebol\r
Gestor da Unidade de Gest\xE3o da Informa\xE7\xE3o | Secretaria Adjunta da Tecnologia da Informa\xE7\xE3o do Maranh\xE3o - SEATI / MA - Brasil`,answers:[]},{id:18295,code:"BVRHH3",public_name:"Arturo Erdely",biography:"Profesor de tiempo completo en la Universidad Nacional Aut\xF3noma de M\xE9xico (UNAM), miembro nivel 1 del Sistema Nacional de Investigadores (CONACYT - M\xE9xico), Actuario y Doctor en Ciencias Matem\xE1ticas (UNAM).",answers:[]},{id:18035,code:"3FZJ7K",public_name:"Olga Eleftherakou",biography:"Born in 1999 in Athens, Greece. A postgraduate student in Applied Statistics (fields of Data Science and Biostatistics) with a Bachelor's degree in Statistics and Actuarial Science, University of Piraeus. Passionate about Machine Learning. Currently learning Julia language by myself.",answers:[]},{id:1158,code:"E77THB",public_name:"Charlie Kawczynski",biography:"Charlie earned his Ph.D. in mechanical engineering at UCLA, where he studied and developed software to simulate computational liquid metal magnetohydrodynamic flows for magnetic confined fusion energy reactors. Since then, he's been developing a climate model, in Julia, from the ground up at Caltech in the CliMA project. For more details, see https://clima.caltech.edu/.",answers:[]}],links:[],attachments:[],answers:[]},{id:17107,guid:"827ef6f8-0442-5a19-9778-a8e7ed6581ee",logo:"",date:"2022-07-29T16:30:00+00:00",start:"16:30",duration:"00:30",room:"Purple",slug:"juliacon-2022-17107-metaheuristics-jl-towards-any-optimization",url:"https://pretalx.com/juliacon-2022/talk/8LRJVY/",title:"Metaheuristics.jl: Towards Any Optimization",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Real-world problems require sophisticated methodologies providing feasible and efficient solutions. Metaheuristics are algorithms proposed to approximate those optimal solutions in a short time, making them suitable for applications where saving time is important. Metaheuristics.jl package implements relevant state-of-the-art algorithms for constrained, multi-, many-objective and bilevel optimization. Moreover,  performance indicators are implemented in this package.",description:"This talk presents the main features of Metaheuristics.jl, which is a package for global optimization to approximate solutions for single-, multi-, and many-objective optimization. Several examples are given to illustrate the implementation and the resolution of the different optimization problems.",recording_license:"",do_not_record:!1,persons:[{id:18008,code:"QHWSLS",public_name:"Jes\xFAs-Adolfo Mej\xEDa-de-Dios",biography:"Jes\xFAs Mej\xEDa is a Ph.D. student from the Artificial Intelligence Research Institute at the University of Veracruz (IIIA-UV). He received a BSc degree in mathematics from the University of Veracruz and obtained a master\u2019s degree with an honorific mention in Artificial Intelligence from CIIA-UV. His research interests include Numerical Analysis, Bilevel Optimization, and Intelligent Computing.",answers:[]}],links:[],attachments:[],answers:[]},{id:17902,guid:"77c35388-fbc0-5d2e-aa55-2db005df03aa",logo:"",date:"2022-07-29T17:00:00+00:00",start:"17:00",duration:"00:30",room:"Purple",slug:"juliacon-2022-17902-inferopt-jl-combinatorial-optimization-in-ml-pipelines",url:"https://pretalx.com/juliacon-2022/talk/P7XJCV/",title:"InferOpt.jl: combinatorial optimization in ML pipelines",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:`We present InferOpt.jl, a generic package for combining combinatorial optimization algorithms with machine learning models. It has two purposes:\r
\r
- Increasing the expressivity of learning models thanks to new types of structured layers.\r
- Increasing the efficiency of optimization algorithms thanks to an additional inference step.\r
\r
Our library provides wrappers for several state-of-the-art methods in order to make them compatible with Julia's automatic differentiation ecosystem.`,description:`### Overview\r
\r
We focus on a generic prediction problem: given an instance \`x\`, we want to predict an output \`y\` that minimizes the cost function \`c(y)\` on a feasible set \`Y(x)\`. When \`Y(x)\` is combinatorially large, a common approach in the literature is to exploit a surrogate optimization problem, which is usually a Linear Program (LP) \`max_y \u03B8\u1D40y\`.\r
\r
A typical use of InferOpt.jl is integrating the optimization problem (LP) into a structured learning pipeline of the form \`x -> \u03B8 -> y\`, where the cost vector \`\u03B8 = \u03C6_w(x)\` is given by an ML encoder. Our goal is to learn the weights \`w\` in a principled way. To do so, we consider two distinct paradigms:\r
\r
1. *Learning by experience*, whereby we want to minimize the cost induced by our pipeline using only past instances \`x\`.\r
2. *Learning by imitation*, for which we have "true" solutions \`y\` or cost vectors \`\u03B8\` associated with each past instance \`x\`.\r
\r
We provide a unified framework to derive well-known loss functions, and we pave the way for new ones. Our package will be open-sourced in time for JuliaCon 2022.\r
\r
### Related works\r
\r
InferOpt.jl gathers many previous approaches to derive (sub-)differentiable layers in structured learning:\r
\r
- [_Differentiation of Blackbox Combinatorial Solvers_](https://arxiv.org/pdf/1912.02175.pdf) for linear interpolations of piecewise constant functions\r
- [_Learning with Fenchel-Young Losses_](https://arxiv.org/abs/1901.02324) for regularized optimizers and the associated structured losses\r
- [_Learning with Differentiable Perturbed Optimizers_](https://arxiv.org/abs/2002.08676) for stochastically-perturbed optimizers\r
- [_Structured Support Vector Machines_](https://pub.ist.ac.at/~chl/papers/nowozin-fnt2011.pdf) for cases in which we have a distance on the output space\r
- [_Smart "Predict, then Optimize"_](https://arxiv.org/abs/1710.08005) for two-stage decision frameworks in which we know past true costs\r
\r
In addition, we provide several tools for directly minimizing the cost function using smooth approximations.\r
\r
### Package content\r
\r
Since we want our package to be as generic as possible, we do not make any assumption on the kind of algorithm used to solve combinatorial problems. We only ask the user to provide a callable \`maximizer\`, which takes the cost vector \`\u03B8\` as argument and returns a solution \`y\`: regardless of the implementation, our wrappers can turn it into a differentiable layer.\r
\r
As such, our approach is different from that of [DiffOpt.jl](https://github.com/jump-dev/DiffOpt.jl), in which the optimizer has to be a convex [JuMP.jl](https://github.com/jump-dev/JuMP.jl) model. It is also different from [ImplicitDifferentiation.jl](https://github.com/gdalle/ImplicitDifferentiation.jl), which implements a single approach for computing derivatives (whereas we provide several), and does not include structured loss function.\r
\r
All of our wrappers come with their own forward and reverse differentiation rules, defined using [ChainRules.jl](https://github.com/JuliaDiff/ChainRules.jl). As a result, they are compatible with a wide range of automatic differentiation backends and machine learning libraries. For instance, if the encoder \`\u03C6_w\` is a [Flux.jl](https://github.com/FluxML/Flux.jl) model, then the wrapped optimizer can also be included as a layer in a \`Flux.Chain\`.\r
\r
### Examples\r
\r
We include various examples and tutorials to apply this generic framework on concrete problems. Since our wrappers are model- and optimizer-agnostic, we can accommodate a great variety of algorithms for both aspects.\r
\r
On the optimization side, our examples make use of:\r
\r
- Mixed-Integer Linear Programs;\r
- Shortest path algorithms;\r
- Scheduling algorithms;\r
- Dynamic Programming.\r
\r
On the model side, we exploit the following classes of predictors:\r
\r
- Generalized Linear Models;\r
- Convolutional Neural Networks;\r
- Graph Neural Networks.`,recording_license:"",do_not_record:!1,persons:[{id:10588,code:"PJVBLC",public_name:"Guillaume Dalle",biography:"PhD student at \xC9cole des Ponts (France), working on machine learning and operations research with applications to railway planning.",answers:[]},{id:18303,code:"3T8PAH",public_name:"Louis Bouvier",biography:"PhD student in Machine Learning and Operations Research at CERMICS, Ecole des Ponts.",answers:[]},{id:18312,code:"ZME37L",public_name:"L\xE9o Baty",biography:null,answers:[]}],links:[],attachments:[],answers:[]},{id:16864,guid:"33ca0e9d-d4a2-5a43-9818-fafa44716c52",logo:"/media/juliacon-2022/submissions/YMFXKE/pp_pxvtPHr.jpg",date:"2022-07-29T17:30:00+00:00",start:"17:30",duration:"00:10",room:"Purple",slug:"juliacon-2022-16864-time-to-say-goodbye-to-good-old-pca",url:"https://pretalx.com/juliacon-2022/talk/YMFXKE/",title:"Time to Say Goodbye to Good Old PCA",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`In this talk, I present ProjectionPursuit.jl, a package that is designed to address the limitation of PCA, that is the lack of flexibility for dimension reduction. I also discuss the background of projection pursuit, why the result of PCA could be misleading, and compare projection pursuit and PCA with some data examples.\r
An alternative title of this talk is \u201CBring Your Own Objective Function: Why PCA can be a bad idea?\u201D.`,description:"Principal Component Analysis (PCA) is arguably the most popular dimension reduction method in practice. The basic idea of PCA is to reduce the dimension of original data while retaining as much variance as possible. While sometimes effective, in practice PCA has some pitfalls, especially when the components of interest of the data are orthogonal to the leading principal components. A possible alternative, the projection pursuit technique, was proposed by Kruskal (1972) and Friedman and Tukey (1974). However, unlike PCA, projection pursuit does not have a closed-form solution, and thus computational complexity limits its prevalence. In this talk, we present the Julia package, ProjectionPursuit.jl, which combines the new computational tools needed to implement the high-dimensional projection pursuit and the lightning speed of Julia. We show that with the help of this package, one can easily implement the idea of projection pursuit to various applications.",recording_license:"",do_not_record:!1,persons:[{id:17715,code:"FXRKZS",public_name:"Yijun Xie",biography:"Yijun is currently a Senior Data Scientist at Shopify. Prior to joining Shopify, Yijun also worked as a Data Scientist at the Royal Bank of Canada. Yijun obtained his Ph.D. in Statistics from the University of Waterloo, and his research focuses on functional data analysis and dimension reduction.",answers:[]}],links:[],attachments:[],answers:[]},{id:18125,guid:"8cd5a92e-02eb-5700-b30c-e08842bb793e",logo:"",date:"2022-07-29T17:40:00+00:00",start:"17:40",duration:"00:10",room:"Purple",slug:"juliacon-2022-18125-regressionformulae-jl-familiar-formula-syntax-for-regression",url:"https://pretalx.com/juliacon-2022/talk/HFG3AW/",title:"RegressionFormulae.jl: familiar `@formula` syntax for regression",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"StatsModels.jl provides the `@formula` mini-language for conveniently specifying table-to-matrix transformations for statistical modeling.  [RegressionFormulae.jl](https://github.com/kleinschmidt/RegressionFormulae.jl) extends this mini-language with additional syntax that users coming from other statistical modeling ecosystems such as R may be familiar with.  This package also serves as a template for developers wish to expand the StatsModels.jl `@formula` syntax in their own packages.",description:'StatsModels.jl provides the `@formula` mini-language for conveniently specifying table-to-matrix transformations for statistical modeling.  This mini-language is designed with extensibility and composability in mind, using normal Julia mechanisms of multiple dispatch to implement additional syntax both inside StatsModels.jl and in external packages.  RegressionFormulae.jl takes advantage of this extensibility to provide _additional syntax_ that is familiar to many users of other statistical software (e.g., R) in an "opt-in" manner, without forcing _all_ downstream packages that depend on StatsModels.jl/`@formula` to support this syntax.\r\n\r\nThe StatsModels.jl `@formula` syntax is based on the Wilkinson-Rogers Formula Notation which has been a widely-used standard in multi-factor regression modeling since it was first described in Wilkinson and Rogers (1973).  The basic syntax includes operators for _addition_ (`+`) and _crossing_ (`&` and `*`) of regressors, as well as the `~` operator to link outcome and regressor terms.  As the conventions around this syntax have evolved in the last 50 years, other systems have introduced additional operators.\r\n\r\nRegressionFormulae.jl expands the StatsModels.jl `@formula` to support two commonly-used operators from R: `^` (incomplete crossing) and `/` (nesting).  Specifically, it implements\r\n- `(a + b + c + ...) ^ n` to create all interactions up to `n`-way, corresponding to an incomplete cross of `a, b, c, ...`.\r\n- `a / b` to create `a + a & b`, which results in a "nested" model of `b`, with a separate coefficient for `b` for each level of `a`\r\n\r\nBoth of these operators are particularly useful for creating _interpretable_ models.  Models with high-order interactions are extremely challenging to interpret and require considerable care, and are prone to over-fitting since the number of coefficients grows very quickly with additional terms participating in the interactions.  The incomplete cross `^` syntax can ameliorate these difficulties, limiting the highest degree of the resulting interaction terms and reducing the overall number of predictors.  Nesting (`a / b`) similarly provides an alternative to fully crossed models (`a * b`) that is more directly interpretable in situations where the analytic questions are focused on the effects of a predictor `b` within each individual level of some other variable `a`, without concern for direct _comparison_ of these effects to each other.\r\n\r\nFinally, this syntax is implemented in a way that does not _require_ other modeling packages that use `@formula` to support them, or even _prevent_ other packages from defining _alternative_ meaning to the `^` or `/` operators.  Within a `@formula`, the special syntax is implemented by methods like\r\n\r\n```julia\r\nfunction StatsModels.apply_schema(\r\n    t::FunctionTerm{typeof(/)},\r\n    ...\r\n```\r\n\r\nand \r\n\r\n```julia\r\nfunction Base.:(/)(outer::CategoricalTerm, inner::AbstractTerm)\r\n    ...\r\n```\r\n\r\nThe result of this is that if RegressionFormulae.jl is not loaded, then `/` and `^` inside a `@formula` behave exactly as they normally would (e.g., as calls the normal Julia functions `/` and `^`).  Moreover, if a user loads RegressionFormulae.jl at the same time as some other package that defines special syntax for `/` or `^` (for `RegressionModel`), they will receive a warning about method redefinition or method ambiguity.',recording_license:"",do_not_record:!1,persons:[{id:4393,code:"SLNRF8",public_name:"Dave Kleinschmidt",biography:"Research scientist at Beacon Biosignals, recovering academic.",answers:[]},{id:3828,code:"3EFERC",public_name:"Phillip Alday",biography:"Phillip is a neuroscientist and contributor to the MixedModels.jl ecosystem. Additionally, he has contributed substantially to Effects.jl and StandardizedPredictors.jl",answers:[]}],links:[],attachments:[],answers:[]},{id:18069,guid:"7d7a2865-359c-5131-a82f-576072b467bf",logo:"",date:"2022-07-29T17:50:00+00:00",start:"17:50",duration:"00:10",room:"Purple",slug:"juliacon-2022-18069-random-utility-models-with-discretechoicemodels-jl",url:"https://pretalx.com/juliacon-2022/talk/DHYP8U/",title:"Random utility models with DiscreteChoiceModels.jl",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Random utility models are widely used in social science. While most statistical software, including Julia, has some facilities for estimating multinomial logit models, more advanced models such as mixed logit models and models with different utility functions for different outcomes generally require specific choice modeling software. This presentation describes a new package, DiscreteChoiceModels.jl, which provides flexible and high-performance multinomial and forthcoming mixed logit estimation.",description:`Random utility models are ubiquitous in fields including economics, transportation, and marketing [1]. Estimation of simple multinomial logit models is available in many statistical packages, including Julia via Econometrics.jl [2], more advanced choice models are generally fit with choice-model-specific packages e.g., [3], [4]. These packages allow more-flexible utility specifications by allowing utility function definitions to vary over outcomes, and by allowing additional forms of random utility model, such as the mixed logit model which allows random parameter variation [5].\r
\r
DiscreteChoiceModels.jl provides such a package for Julia. It has an intuitive syntax for specifying discrete-choice models, allowing users to directly write out utility functions. For instance, the code below specifies the Swissmetro example mode-choice mode distributed with Biogeme [3]:\r
\r
    multinomial_logit(\r
        @utility(begin\r
            1 ~ \u03B1train + \u03B2travel_time * TRAIN_TT / 100 + \u03B2cost * (TRAIN_CO * (GA == 0)) / 100\r
            2 ~ \u03B1swissmetro + \u03B2travel_time * SM_TT / 100 + \u03B2cost * SM_CO * (GA == 0) / 100\r
            3 ~ \u03B1car + \u03B2travel_time * CAR_TT / 100 + \u03B2cost * CAR_CO / 100\r
        end),\r
        :CHOICE,\r
        data,\r
        availability=[\r
            1 => :avtr,\r
            2 => :avsm,\r
            3 => :avcar,\r
        ]\r
    )\r
\r
Within the utility function specification (@utility), the first three lines specify the utility functions for each of the three modes specified by the CHOICE variable: train, car, and the hypothetical Swissmetro. Any variable starting with \u03B1 or \u03B2 is treated as a coefficient to be estimated, while other variables are assumed to be data columns. The remainder of the model specification indicates that the choice is indicated by the variable CHOICE, what data to use, and, optionally, what columns indicate availability for each alternative.\r
\r
Mixed logit models\r
\r
Support for mixed logit models is under development. Mixed logit models will specify random coefficients as distributions from Distributions.jl [6]. For instance, to specify that \u03B1train should be normally distributed with mean 0 and standard deviation 1 as starting values, you would add\r
\r
    \u03B1train = Normal(0, exp(0))\r
\r
with the exponent indicating that the value will be exponentiated to ensure that the standard deviation will always be positive.\r
\r
Performance\r
\r
Julia is designed for high-performance computing, so a major goal of DiscreteChoiceModels.jl is to estimate models more quickly than other modeling packages. To that end, two multinomial logit models were developed and benchmarked using three packages\u2014DiscreteChoiceModels.jl, Biogeme [3], and Apollo [4], using default settings for all three packages. The first model is the Swissmetro example from Biogeme, with 6,768 observations, 3 alternatives, and 4 free parameters. The second is a vehicle ownership model using the 2017 US National Household Travel Survey, with 129,696 observations, 5 alternatives, and 35 free parameters. All runtimes are the median of 10 runs, and executed serially on a quad-core Intel i7 with 16GB of RAM, running Debian 11.1. DiscreteChoiceModels.jl outperforms other packages when used with a DataFrame, while using Dagger introduces distributed computing overhead on a single machine.\r
\r
  Model               DiscreteChoiceModels.jl: DataFrame   DiscreteChoiceModels.jl: Dagger   Biogeme   Apollo\r
  ------------------- ------------------------------------ --------------------------------- --------- --------\r
  Swissmetro          188ms                                2047ms                            252ms     824ms\r
  Vehicle ownership   35.1s                                46.9s                             163.4s    227.2s\r
\r
References\r
\r
[1] M. Ben-Akiva and S. R. Lerman, Discrete choice analysis: Theory and application to travel demand. MIT Press, 1985.\r
\r
[2] J. B. S. Calder\xF3n, \u201CEconometrics.jl,\u201D Proc JuliaCon Conf, doi: 10.21105/jcon.00038.\r
\r
[3] M. Bierlaire, \u201CA short introduction to PandasBiogeme,\u201D Ecole Poltechnique F\xE9d\xE9rale de Lausanne, Lausanne, TRANSP-OR 200605, Jun. 2020. Available: https://transp-or.epfl.ch/documents/technicalReports/Bier20.pdf\r
\r
[4] S. Hess and D. Palma, \u201CApollo: A flexible, powerful and customisable freeware package for choice model estimation and application,\u201D J Choice Model, doi: 10.1016/j.jocm.2019.100170.\r
\r
[5] K. Train, Discrete Choice Methods with Simulation. Cambridge, UK: Cambridge University Press, 2009.\r
\r
[6] M. Besan\xE7on et al., \u201CDistributions.jl: Definition and Modeling of Probability Distributions in the JuliaStats Ecosystem,\u201D J Stat Soft, doi: 10.18637/jss.v098.i16.`,recording_license:"",do_not_record:!1,persons:[{id:18439,code:"AVA9TW",public_name:"Matthew Wigginton Bhagat-Conway",biography:`Matthew Bhagat-Conway is an Assistant Professor in the Department of City and Regional Planning. His research interests are in travel behavior, urban transportation, and statistical methods for transportation data analysis. He is also jointly appointed in the Odum Institute for Research in the Social Sciences, where he is available to assist researchers with statistics and data analysis.\r
\r
Dr. Bhagat-Conway has a PhD and MA in Geography from Arizona State University, and a BA in Geography from the University of California, Santa Barbara. Prior to graduate school, he was a software developer and project manager for Conveyal, a public transport planning consulting firm, and a fellow in the Data Science for Social Good fellowship at the University of Chicago.`,answers:[]}],links:[],attachments:[],answers:[]}],Blue:[{id:17955,guid:"89d83814-73f0-5569-ab7e-54af627dbd63",logo:"",date:"2022-07-29T12:30:00+00:00",start:"12:30",duration:"00:10",room:"Blue",slug:"juliacon-2022-17955-a-fresh-approach-to-open-source-voice-assistant-development",url:"https://pretalx.com/juliacon-2022/talk/H3N8UN/",title:"A Fresh Approach to Open Source Voice Assistant Development",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"We present JustSayIt.jl, a software and high-level API for offline, low latency and secure translation of human speech to computer commands or text, leveraging the Vosk Speech Recognition Toolkit. The API includes an unprecedented, highly generic extension to the Julia programming language, which allows to declare arguments in standard function definitions to be obtainable by voice. As a result, it empowers any programmer to quickly write new commands that take arguments from human voice.",description:`Leading software companies have heavily invested in voice assistant software since the dawn of the century. However, they naturally prioritize use cases that directly or indirectly bring economic profit. As a result, their developments cover, e.g., the needs of the entertainment sector abundantly, but those of academia and software development only poorly. There is particularly little support for Linux, whereas it is the preferred operating system for many software developers and computational scientists. The open source voice assistant project MyCroft fully supports Linux, but provides little tools that appear helpful for productive work in academia and software development; moreover, adding new skills to MyCroft seems to be complex for average users and appears to require considerable knowledge about the specificities of MyCroft. [JustSayIt.jl](https://github.com/omlins/JustSayIt.jl) addresses these shortcomings by providing a lightweight framework for easily extensible, offline, low latency, highly accurate and secure speech to command or text translation on Linux, MacOS and Windows.\r
\r
[JustSayIt](https://github.com/omlins/JustSayIt.jl)'s high-level API allows to declare arguments in standard Julia function definitions to be obtainable by voice, which constitutes an unprecedented, highly generic extension to the Julia programming language. For such functions, [JustSayIt](https://github.com/omlins/JustSayIt.jl) automatically generates a wrapper method that takes care of the complexity of retrieving the arguments from the speakers voice, including interpretation and conversion of the voice arguments to potentially any data type. [JustSayIt](https://github.com/omlins/JustSayIt.jl) commands are implemented with such voice argument functions, triggered by a user definable mapping of command names to functions. As a result, it empowers programmers without any knowledge of speech recognition to quickly write new commands that take their arguments from the speakers voice. Moreover, [JustSayIt](https://github.com/omlins/JustSayIt.jl) unites the Julia and Python communities by using both languages: it leverages Julia's performance and metaprogramming capabilities and Python's larger ecosystem where no Julia package is considered suitable. [JustSayIt](https://github.com/omlins/JustSayIt.jl) relies on PyCall.jl and Conda.jl, which renders installing and calling Python packages from within Julia almost trivial. [JustSayIt](https://github.com/omlins/JustSayIt.jl) is ideally suited for development by the world-wide open source community as it provides an intuitive high-level API that is readily understandable by any programmer and unites the Python and Julia community.\r
\r
[JustSayIt](https://github.com/omlins/JustSayIt.jl) implements a novel algorithm for high performance context dependent recognition of spoken commands which leverages the [Vosk Speech Recognition Toolkit](https://github.com/alphacep/vosk-api/). A specialized high performance recognizer is defined for each function argument that is obtainable by voice and has a restriction on the valid input. In addition, when beneficial for recognition accuracy, the recognizer for a voice argument is generated dynamically depending on the command path taken before the argument. To enable minimal latency for single word commands (latency refers here to the time elapsed between a command is spoken and executed), the latter can be triggered in certain conditions upon bare recognition of the corresponding sounds without waiting for silence as normally done for the confirmation of recognitions. Thus, [JustSayIt](https://github.com/omlins/JustSayIt.jl) is suitable for commands where a perceivable latency would be unacceptable, as, e.g., mouse clicks. Single word commands' latency is typically in the order of a few milliseconds on a regular notebook. [JustSayIt](https://github.com/omlins/JustSayIt.jl) achieves this high performance using only one CPU core and can therefore run continuously without harming the computer usage experience.\r
\r
In conclusion, [JustSayIt](https://github.com/omlins/JustSayIt.jl) demonstrates that the development of our future voice assistants can take a fresh and new path that is neither driven by the priorities and economic interests of global software companies nor by a small open source community of speech recognition experts; instead, the entire world-wide open source community is empowered to contribute in shaping our future daily assistants.`,recording_license:"",do_not_record:!1,persons:[{id:4264,code:"QTKXPY",public_name:"Samuel Omlin",biography:"Computational Scientist and responsible for Julia computing at the Swiss National Supercomputing Centre (CSCS), ETH Zurich",answers:[]}],links:[],attachments:[],answers:[]},{id:17893,guid:"d12a0f08-3bde-5ac5-9726-fed142f0efad",logo:"",date:"2022-07-29T12:40:00+00:00",start:"12:40",duration:"00:10",room:"Blue",slug:"juliacon-2022-17893-implicitdifferentiation-jl-differentiating-implicit-functions",url:"https://pretalx.com/juliacon-2022/talk/DTHTBC/",title:"ImplicitDifferentiation.jl: differentiating implicit functions",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:`We present a Julia package for differentiating through functions that are defined implicitly. It can be used to compute derivatives for a wide array of "black box" procedures, from optimization algorithms to fixed point iterations or systems of nonlinear equations.\r
Since it mostly relies on defining custom chain rules, our code is lightweight and integrates nicely with Julia's automatic differentiation and machine learning ecosystem.`,description:`### Introduction\r
\r
Differentiable programming is a core ingredient of modern machine learning, and it is one of the areas where Julia truly shines. By defining new kinds of differentiable layers, we can hope to increase the expressivity of deep learning pipelines without having to scale up the number of parameters.\r
\r
For instance, in structured prediction settings, domain knowledge can be encoded into optimization problems of many flavors: linear, quadratic, conic, nonlinear or even combinatorial. In domain adaptation, differentiable distances based on optimal transport are often computed using the Sinkhorn fixed point iteration algorithm. Last but not least, in differential equation-constrained optimization and neural differential equations, one often needs to obtain derivatives for solutions of nonlinear equation systems with respect to equation parameters.\r
\r
Note that these complex functions are all defined *implicitly*, through a condition that their output must satisfy. As a consequence, differentiating said output (e.g. the minimizer of an optimization problem) with respect to the input (e.g. the cost vector or constraint matrix) requires the automatization of the implicit function theorem.\r
\r
### Related works\r
\r
When trying to differentiate through iterative procedures, unrolling the loop is a natural approach. However, it is computationally demanding and it only works for pure Julia code with no external "black box" calls. On the other hand, using the implicit function theorem means we can decouple the derivative from the function itself: see [_Efficient and Modular Implicit Differentiation_](https://arxiv.org/abs/2105.15183) for an overview of the related theory.\r
\r
In the last few years, this implicit differentiation paradigm has given rise to several Python libraries such as [OpenMDAO](https://github.com/OpenMDAO/OpenMDAO), [cvxpylayers](https://github.com/cvxgrp/cvxpylayers) and [JAXopt](https://github.com/google/jaxopt). In Julia, the most advanced one is [DiffOpt.jl](https://github.com/jump-dev/DiffOpt.jl), which allows the user to differentiate through a [JuMP.jl](https://github.com/jump-dev/JuMP.jl) optimization model. A more generic approach was recently experimented with in [NonconvexUtils.jl](https://github.com/JuliaNonconvex/NonconvexUtils.jl): our goal with [ImplicitDifferentiation.jl](https://github.com/gdalle/ImplicitDifferentiation.jl) is to make it more efficient, reliable and easily usable for everyone.\r
\r
### Package content\r
\r
Our package provides a simple toolbox that can differentiate through any kind of user-specified function \`x -> y(x)\`. The only requirement is that its output be characterized with a condition of the form \`F(x,y(x)) = 0\`.\r
Beyond the generic machinery of implicit differentiation, we also include several use cases as tutorials: unconstrained and constrained optimization, fixed point algorithms and nonlinear equation systems, etc.\r
\r
### Technical details\r
\r
The central construct of our package is a wrapper of the form\r
\`\`\`julia\r
struct ImplicitFunction{O,C}\r
    forward::O\r
    conditions::C\r
end\r
\`\`\`\r
where \`forward\` computes the mapping \`x -> y(x)\`, while \`conditions\` corresponds to \`(x,y) -> F(x, y)\`. By defining custom pushforwards and pullbacks, we ensure that \`ImplicitFunction\` objects can be used with any [ChainRules.jl](https://github.com/JuliaDiff/ChainRules.jl)-compatible automatic differentiation backend, in forward or reverse mode.\r
\r
To attain maximum efficiency, we never actually store a full jacobian matrix: we only reason with vector-jacobian and jacobian-vector products. Thus, when solving linear systems (which is a key requirement of implicit differentiation), we exploit iterative Krylov subspace methods for their ability to handle lazy linear operators.`,recording_license:"",do_not_record:!1,persons:[{id:10588,code:"PJVBLC",public_name:"Guillaume Dalle",biography:"PhD student at \xC9cole des Ponts (France), working on machine learning and operations research with applications to railway planning.",answers:[]},{id:3814,code:"PFTTSC",public_name:"Mohamed Tarek",biography:"Scientist at PumasAI Inc.",answers:[]}],links:[],attachments:[],answers:[]},{id:17834,guid:"e4ef546d-8918-54a0-a4e7-6c5f13fb3d9a",logo:"/media/juliacon-2022/submissions/FZ38VW/Plate_25_old_4KYrheV.png",date:"2022-07-29T12:50:00+00:00",start:"12:50",duration:"00:10",room:"Blue",slug:"juliacon-2022-17834-du-bois-data-visualizations-a-julia-recipe",url:"https://pretalx.com/juliacon-2022/talk/FZ38VW/",title:"Du Bois Data Visualizations: A Julia Recipe",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"We introduce a new plotting package allowing users to easily  create publication-quality figures in W.E.B. Du Bois\u2019s unique style of data visualizations. A groundbreaking sociologist and historian, Du Bois collected data on Black Georgia residents in the late 19th century and designed over 60 eye-catching graphs to depict these data at the 1900 Paris Exposition. We showcase our package by replicating the original figures exactly and by revisiting them with new data.",description:`This collection of plotting recipes uses the Makie.jl plotting package to recreate some of Du Bois\u2019s most famous and complex data visualizations on the state of African-Americans at the turn of the 20th century.   In additional to replicating the original, users can easily create figures with their own data in the same style and format, ready for publication. \r
W.E.B. Du Bois (b. 1868, d. 1963) was a sociologist, historian, and civil rights activist. Du Bois originally presented these plates at the 1900 Paris Exposition. He and his team of researchers at Atlanta University collected data on Black Georgia residents in order to create a comprehensive view of the quality of life and aggregate characteristics of what was at the time the largest African-American population in any U.S. state. Using these data, DuBois and his team created two series of data visualizations, 63 plates in total, six of which are recreated by this package. They are unusual in both shape and color palette as they were meant to capture viewers\u2019 attention at the Paris Exposition \u2013 a venue where audiences might not otherwise stop at a table with information on African-American populations if not for eye-catching data visualizations. \r
A number of groups and individuals have contributed to the project that is digitizing and recreating these plates. The Du Boisian Visualization Toolkit, from the Dignity + Debt Network, provides information on Du Bois\u2019s most-used color palettes and fonts. Multiple R packages, style guides, Excel Tableau, and Python replications, and other resources have been contributed to this project to replicate the original figures. Our package contributes on two fronts. We present the first replication using Julia. Second. More importantly, our package is designed to allow the user to present their own data instead of merely replicating the originals. \r
We have attached one picture that shows one example of what users can obtain from our package.\r
\r
References\r
Du Bois, W. E. B., Battle-Baptiste, W., & Rusert, B. (2018). W.E.B du Bois's Data Portraits: Visualizing Black America. W.E.B. Du Bois Center at the University of Massachusetts Amherst.\r
Link to Makie.jl package: https://makie.juliaplots.org/stable/\r
Link to Du Bois challenge and original exhibits: https://github.com/ajstarks/dubois-data-portraits/tree/master/challenge`,recording_license:"",do_not_record:!1,persons:[{id:18214,code:"QADPRP",public_name:"Eirik Brandsaas & Kyra Sadovi",biography:"Eirik Brandsaas is an economist at the Board of Governors of the Federal Reserve System. Kyra Sadovi is a research assistant at the Board of Governors.",answers:[]},{id:18264,code:"MTJCCL",public_name:"Eirik Brandsaas",biography:"Economist at the Federal Reserve Board of Governors. Primary research area is computational macroeconomics, with a focus on household finance, housing, and family economics.",answers:[]}],links:[],attachments:[],answers:[]},{id:17743,guid:"479a8dad-9cf2-5641-871e-ef18042cda7f",logo:"/media/juliacon-2022/submissions/V3NPES/aog_demo_YKNlEXE.png",date:"2022-07-29T13:00:00+00:00",start:"13:00",duration:"00:10",room:"Blue",slug:"juliacon-2022-17743-data-analysis-and-visualization-with-algebraofgraphics",url:"https://pretalx.com/juliacon-2022/talk/V3NPES/",title:"Data Analysis and Visualization with AlgebraOfGraphics",subtitle:"",track:"JuliaCon",type:"Lightning talk",language:"en",abstract:"Based on the Makie library, AlgebraOfGraphics offers visualizations for common analyses (frequency table, 1- or 2-D histogram and kernel density, linear and non-linear regression...), as well as functions to express how the data should be processed, grouped, styled, and visualized. These building blocks can be combined using the `*` and `+` operators, thus forming a rich algebra of visualizations. The unified syntax layer simplifies the creation of AlgebraOfGraphics-based UIs for data analysis.",description:`In this talk, I will give an overview of the Algebra of Graphics approach to data visualizations in Julia.\r
\r
Algebra of Graphics is an adaptation of the Grammar of Graphics\u2014a declarative language to define visualizations by mapping columns of a dataset to plot attribtues\u2014to the Julia programming language and philosophy, with some important differences.\r
\r
I will first discuss the key components of AlgebraOfGraphics (data selection, mapping of data to plot attributes, analysis and visualization selection) and show how they can be combined multiplicatively (by merging information) or additively (by drawing distinct visualizations on separate layers).\r
\r
Then, I will delve into the AlgebraOfGraphics philosophy. The aim of AlgebraOfGraphics is to empower users to produce visualizations that answer _questions_ about their data. This is achieved via _reusable building blocks_, which the users define based on their knowledge of the data. Rich visualizations can be built by combining these building blocks: I will demonstrate this technique on an example dataset. I will also show how AlgebraOfGraphics attempts to lessen the cognitive burden on the user by providing opinionated graphical defaults as well as wide format support. That way, the user can focus on the question at hand, rather than visual fine-tuning or data wrangling.\r
\r
As the AlgebraOfGraphics syntax is uniform, it can be used as the backend to a Graphical User Interface for data analysis and visualization. I will show a prototype of such a GUI, based on AlgebraOfGraphics, web technologies, and the web-based backend of Makie.`,recording_license:"",do_not_record:!1,persons:[{id:4267,code:"RB8YD8",public_name:"Pietro Vertechi",biography:`I completed my PhD in neuroscience at Champalimaud Research. There, my research work revolved around the inference of hidden states in tasks performed by both biological and artificial agents. Currently, I am working on novel methods for intelligible artificial intelligence.\r
\r
An overview of my open source work can be found on my [GitHub page](https://github.com/piever).`,answers:[]}],links:[],attachments:[],answers:[]},{id:21250,guid:"7b6d6b3c-b64f-580d-aa52-3f3fb3c780e9",logo:"",date:"2022-07-29T13:25:00+00:00",start:"13:25",duration:"00:05",room:"Blue",slug:"juliacon-2022-21250-quera-computing-sponsor-talk",url:"https://pretalx.com/juliacon-2022/talk/ENV8KX/",title:"QuEra Computing Sponsor Talk",subtitle:"",track:null,type:"Silver sponsor talk",language:"en",abstract:"QuEra is a neutral-atom based quantum computing startup located in the heart of Boston near Harvard University.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]},{id:18123,guid:"896fc1ff-dfdd-5ff2-9650-55606704314d",logo:"",date:"2022-07-29T13:30:00+00:00",start:"13:30",duration:"00:30",room:"Blue",slug:"juliacon-2022-18123-working-with-firebase-in-julia",url:"https://pretalx.com/juliacon-2022/talk/HFNKTC/",title:"Working with Firebase in Julia",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:`In this talk, I intend to discuss about the use of Firebase in Julia through Firebase.jl \r
https://github.com/ashwani-rathee/Firebase.jl\r
A lot of databases are well supported in Julia but support for Firebase is rather limited, which is an issue. We want to attract more younger people towards Julian community, but a big chunk of these people prefer to use Firebase in their relatively small size projects. Through this talk, I want to demonstrate how to use Firebase.jl for project developement.`,description:"Firebase.jl is the solution for working with Firebase with the Julia programming language. Firebase.jl provides support for realtime database, cloud firestore, storage, authentication which are quite useful in small and large size projects alike.",recording_license:"",do_not_record:!1,persons:[{id:18471,code:"JL7ETD",public_name:"Ashwani Rathee",biography:"Julian",answers:[]}],links:[],attachments:[],answers:[]},{id:18030,guid:"c190270f-5d03-59e5-9e70-be13d111bdcc",logo:"/media/juliacon-2022/submissions/BH8WSR/Screenshot_2022-04-10_at_12.45.36_ezj55PR.png",date:"2022-07-29T16:30:00+00:00",start:"16:30",duration:"00:30",room:"Blue",slug:"juliacon-2022-18030-interactive-julia-data-dashboards-with-genie",url:"https://pretalx.com/juliacon-2022/talk/BH8WSR/",title:"Interactive Julia data dashboards with Genie",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"Genie provides a powerful set of features for fast and easy creation of interactive data dashboards, helping data and research scientists to design, build, and publish production ready interactive apps and dashboards using pure Julia. In this talk we'll explain and demonstrate how to build a production ready, powerful data dashboard, going from 0 to live in 20 minutes!",description:"Building upon over 5 years of experience with open source web development with Julia, Genie's powerful dashboarding features allow Julia users to develop and publish data apps without needing to use any web development techniques. Genie exposes a smooth workflow and rich programming APIs that allow data and research scientists to control all the aspects of building and deploying data apps and dashboards using only their favourite programming language: Julia.",recording_license:"",do_not_record:!1,persons:[{id:4345,code:"3MGMJN",public_name:"Adrian Salceanu",biography:'Computer Scientists and software developer with over 20 years of experience creating full stack web and data centric applications. Creator of Genie, the highly productive Julia web application. Julia open source contributor since 2017. Author of "Julia Programming Projects" (Packt, 2018) and co-author "Julia Programming Complete Reference Guide" (Packt, 2019).',answers:[]},{id:18421,code:"WHHKUJ",public_name:"Helmut H\xE4nsel",biography:"I am a data scientist for process development at Merck KGaA (Darmstadt, Germany). In this function I use Genie/Stipple in two major projects. This allows me to contribute to the Stipple packages from time to time.",answers:[]}],links:[],attachments:[],answers:[]},{id:17989,guid:"2d340267-dd53-5243-be29-d3a64d281fa4",logo:"/media/juliacon-2022/submissions/SHU83W/Screen_Shot_2022-04-08_at_7.05.24_PM_XO3hz9j.png",date:"2022-07-29T17:00:00+00:00",start:"17:00",duration:"00:30",room:"Blue",slug:"juliacon-2022-17989-declarative-data-transformation-via-graph-transformation",url:"https://pretalx.com/juliacon-2022/talk/SHU83W/",title:"Declarative data transformation via graph transformation",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:"SQL is far from the only declarative paradigm for specifying the dynamics of data! The field of graph transformation formalizes a generalization of term rewriting systems that is visual, intuitive, and applicable to a wide array of data structures, including Catlab's ACSet datatypes. We will describe the basic theory of graph transformation and show how our implementation in Catlab.jl can be applied to e-graph equality saturation and general agent-based model simulations.",description:`What data structure is able to characterize the process of transforming data? Certainly a pointer to a function is sufficient, but this is opaque, making static analysis difficult and lowering code intelligibility. SQL statements offer more transparency at the cost of some expressivity, yet this is still difficult to read and interpret as complexity scales. The graph transformation paradigm expresses data update, addition, and deletion in terms of rewrite rules, which are combinatorial structures characterizing patterns of a data for matching or replacement.\r
\r
Graph rewriting techniques are specified in the notoriously abstract language of category theory, although historically concrete implementations have been restricted to labelled graphs. Catlab.jl is an applied category theory package which has recently added a performant implementation of graph rewriting (double, single, and sesqui pushout paradigms) at a novel level of generality, allowing a generic interface to the major application areas of graph rewriting: graph languages (rewriting defines a graph grammar), graph relations (rewriting is a relation between input and output data structures), and graph transition systems (rewriting evolves a system in time).\r
\r
The scientific community particularly benefits from its code being interpretable and having a straightforward semantics. Just like many low level data manipulations are made safer and more transparent when redescribed as SQL operations, we argue that many data transformation applications would benefit from replacing arbitrary code with a set of declarative rewrite rules. We demonstrate this through some complex applications constructed from these building blocks. This includes an extended example of an epidemiological agent based model (in collaboration with epidemiologist Sean Wu, a research scientist at the Institute for Health Metrics and Evaluation) and an example of equational laws defining an e-graph data structure, with rewrite rules inducing an equality saturation procedure for free. The pattern-based API is easy to use and interpret - no category theory is needed to understand or use these tools!`,recording_license:"",do_not_record:!1,persons:[{id:18394,code:"HRUXFN",public_name:"Kristopher Brown",biography:"Postdoctoral researcher at UF working with James Fairbanks.",answers:[]}],links:[],attachments:[],answers:[]},{id:18044,guid:"68058f2a-32f9-5464-b98b-07b2d5c6f7c7",logo:"",date:"2022-07-29T17:30:00+00:00",start:"17:30",duration:"00:30",room:"Blue",slug:"juliacon-2022-18044-how-to-recover-models-from-data-using-datadrivendiffeq-jl",url:"https://pretalx.com/juliacon-2022/talk/F3J8QM/",title:"How to recover models from data using DataDrivenDiffEq.jl",subtitle:"",track:"JuliaCon",type:"Talk",language:"en",abstract:`In this talk, we will address the problem of data-driven estimation and approximation of completely or partially unknown systems using DataDrivenDiffEq.jl.\r
We will start by giving a short introduction to the field of symbolic regression in general followed by an example of its practical use.\r
Here we learn how to \r
(a) set up a DataDrivenProblem,\r
(b) use ModelingToolkit.jl to incorporate prior knowledge,\r
(c) use different algorithms to recover the underlying equations.`,description:`How do we model the friction in the joint of a robot, biological feedback signal, or the influence of seemingly unrelated parameters on our dynamical system? \r
\r
With the rise of machine learning the classical domain of modeling is becoming more and more driven by data. While the automated discovery of possibly complex relations can help in gaining new insights, classical equations still dominate state-of-the-art machine learning models in terms of extrapolation capabilities and explainability. DataDrivenDiffEq.jl provides a unified application programming interface to define and solve these problems. It brings together operator-based inference, sparse, and symbolic regression to bridge the gap from black to white-box models. \r
\r
After a brief theoretical introduction to the theory of system identification, currently implemented algorithms, and their underlying models we will explore the conceptual layer of the software. Within the Hands-on example, we will see how DataDrivenDiffEq.jl API mimics the mathematical formulation, builds upon and extends ModelingToolkit.jl, SymbolicUtils.jl, and Symbolics.jl to allow expression-based modeling, and seamlessly integrates into the Scientific Machine Learning ecosystem to \`solve\` a variety of estimation problems.`,recording_license:"",do_not_record:!1,persons:[{id:16564,code:"UJ8U9C",public_name:"Carl Julius Martensen",biography:"Julius is currently a PhD candidate at the Otto-von-Guericke University in Magdeburg and an Intern at Pumas-AI. His research evolves around data-driven system identification using scientific machine learning.",answers:[]}],links:[],attachments:[],answers:[]}],BoF:[{id:18086,guid:"efd38716-7199-5e59-b73b-8321deaf9bdc",logo:"",date:"2022-07-29T12:30:00+00:00",start:"12:30",duration:"01:30",room:"BoF",slug:"juliacon-2022-18086-julia-for-space-engineering",url:"https://pretalx.com/juliacon-2022/talk/AG7CGF/",title:"Julia for Space Engineering",subtitle:"",track:"JuliaCon",type:"Birds of Feather",language:"en",abstract:`On paper, Julia and its ecosystem are a perfect match for space engineering. We have got all the cool tools at our disposal (DifferentialEquations.jl, ModellingToolkit.jl, SatelliteToolbox.jl, and many more). The number of people working on great Julia-based solutions for space engineering are increasing year over year. What else do we need to gain orbital velocity? More documentation? A killer app?\r
Let's have a discussion, come up with a plan, and let's go light this candle!`,description:"",recording_license:"",do_not_record:!1,persons:[{id:10348,code:"KDTCJJ",public_name:"Helge Eichhorn",biography:`I am working on reimagining space exploration with Open Source at [JuliaAstro](https://github.com/JuliaAstro), [JuliaSpace](https://github.com/JuliaSpace), and [OpenAstrodynamics](https://github.com/openastrodynamics).\r
\r
Currently serving as Head of Product Innovation at [Telespazio Germany](https://www.telespazio.de/).`,answers:[]},{id:18447,code:"NYBGVS",public_name:"Jorge A. P\xE9rez-Hern\xE1ndez",biography:"I'm a Software Engineer at Telespazio Germany GmbH. In 2021 I graduated from the Physics PhD from the National Autonomous University of Mexico, UNAM. I'm interested in astrodynamics, celestial mechanics, orbit determination, and Solar System dynamics.",answers:[]}],links:[],attachments:[],answers:[]},{id:18152,guid:"4e15d347-f76c-5473-a6a3-ad6ac4cb63ff",logo:"",date:"2022-07-29T16:30:00+00:00",start:"16:30",duration:"01:30",room:"BoF",slug:"juliacon-2022-18152-production-data-engineering-in-julia",url:"https://pretalx.com/juliacon-2022/talk/PWSDHS/",title:"Production Data Engineering in Julia",subtitle:"",track:"JuliaCon",type:"Birds of Feather",language:"en",abstract:"Many Julia community members have faced common challenges while building Julia-based distributed data processing pipelines within production contexts. Furthermore, we believe that Julia is uniquely well-positioned to pioneer new approaches to dataflow orchestration that are currently dominated by monolithic frameworks. In this BoF, Julia's nascent Data Engineering community will swap experiences and identify opportunities to collaborate on open-source next-generation data engineering tools.",description:`Julia has already succeeded by empowering many scientists and engineers to author their own high-performance compute kernels without the usual ergonomics/composability sacrifices that high-performance code often entails. However, actually leveraging these kernels within production contexts often requires packaging them into an automated service, usually within the context of wider automated pipelines. It is not surprising that in the past few years, many new capabilities and packages have emerged that facilitate this by enabling Julia to be executed atop Kubernetes, interop with tabular data sources/sinks via Apache Arrow, and integrate with other popular cloud-native technologies. This blossoming ecosystem within the wider Julia community demonstrates both the desire and opportunity for Julia's usage in production data engineering contexts.\r
\r
Topics of discussion for this BoF include:\r
\r
- current data engineering efforts/challenges faced by industry Julia users maintaining production systems\r
- containerization of Julia processes and Julia-functions-as-a-service\r
- executing Julia-based jobs/services via Kubernetes\r
- Julia-centric workflow/dataflow orchestration\r
- the intersection of Julia's tabular data ecosystem and enterprise data architectures\r
\r
Our goal is two-fold:\r
\r
- uncover the shared data engineering problems, tools, and opportunities that characterize Julia's nascent Data Engineering community\r
- identify concrete opportunities for open-source and cross-organization collaboration (hackathons, blogs, package development, etc.)`,recording_license:"",do_not_record:!1,persons:[{id:2401,code:"AQLMAC",public_name:"Curtis Vogt",biography:"I have been working with Julia since 2015 and have made a variety of contributions to the ecosystem. I am a member of the Julia Community Prize committee and work for Beacon Biosignals as a Principal Software Architect.",answers:[]},{id:18552,code:"DJTFHE",public_name:"Jacob Quinn",biography:null,answers:[]},{id:4291,code:"VAVNMG",public_name:"Jarrett Revels",biography:null,answers:[]}],links:[],attachments:[],answers:[]}],JuMP:[{id:17972,guid:"b7a48338-cdbf-55b1-a0b0-d1b677b8a129",logo:"",date:"2022-07-29T16:30:00+00:00",start:"16:30",duration:"00:30",room:"JuMP",slug:"juliacon-2022-17972-diffopt-jl-differentiating-your-favorite-optimization-problems",url:"https://pretalx.com/juliacon-2022/talk/CUJU8K/",title:"DiffOpt.jl differentiating your favorite optimization problems",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"DiffOpt aims at differentiating optimization problems written in MathOptInterface. Moreover, everything \u201Cjust works\u201D in JuMP. The current framework is based on existing techniques for differentiating the solution of optimization problems with respect to the input parameters. We will show the current state of the package that supports Quadratic Programs and Conic Programs. Moreover, we will highlight how other packages are used to keep the library generic and efficient.",description:"Joint work with: Mathieu Besan\xE7on, Beno\xEEt Legat, Akshay Sharma.",recording_license:"",do_not_record:!1,persons:[{id:11335,code:"LRPWKX",public_name:"Joaquim Dias Garcia",biography:"Researcher and developer at PSR. Based in Brasil. Working with Power Systems, Stochastic Optimization, Bilevel Optimization, Reinforcement Learning. JuMP developer.",answers:[]}],links:[],attachments:[],answers:[]},{id:18019,guid:"6caacfd7-c53c-5c67-8970-51640e78e031",logo:"",date:"2022-07-29T17:00:00+00:00",start:"17:00",duration:"00:10",room:"JuMP",slug:"juliacon-2022-18019-recent-developments-in-parametricoptinterface-jl",url:"https://pretalx.com/juliacon-2022/talk/L79WHV/",title:"Recent developments in ParametricOptInterface.jl",subtitle:"",track:"JuMP",type:"Lightning talk",language:"en",abstract:"ParametricOptInterface.jl is a MathOptInterface extension that helps users deal with parameters in MOI/JuMP. The package started as a GSOC project in 2020 and has seen some new developments in recent months. The goal of this talk is to show the current state of ParametricOptInterface amid the JuMP ecosystem as well as to show some interesting use cases of the package.",description:"",recording_license:"",do_not_record:!1,persons:[{id:4268,code:"PCLZTQ",public_name:"Guilherme Bodin",biography:"Guilherme is an engineer at PSR and an avid contributor to packages in the JuMP ecosystem since the beginning of his master's degree.",answers:[]}],links:[],attachments:[],answers:[]},{id:17980,guid:"946fe6ba-4c79-5390-b2b9-f1019e07e8c9",logo:"",date:"2022-07-29T17:10:00+00:00",start:"17:10",duration:"00:10",room:"JuMP",slug:"juliacon-2022-17980-risk-budgeting-portfolios-from-simulations",url:"https://pretalx.com/juliacon-2022/talk/NPHSNW/",title:"Risk Budgeting Portfolios from simulations",subtitle:"",track:"JuMP",type:"Lightning talk",language:"en",abstract:"Risk budgeting is a portfolio strategy where each asset contributes a pre-specified amount to the total portfolio risk. We propose a numerical framework in JuMP that uses only simulations of returns for estimating risk budgeting portfolios, and provide a Sample Average Approximation algorithm. We leveraged automatic differentiation and JuMP's modeling flexibility to build a clear and concise code. We also report on memory issues encountered when solving for every day in a 14 year horizon.",description:"",recording_license:"",do_not_record:!1,persons:[{id:18389,code:"J8F3ML",public_name:"Bernardo Freitas Paulo da Costa",biography:"Professor of Mathematics at UFRJ, Brazil",answers:[]}],links:[],attachments:[],answers:[]},{id:17076,guid:"1e9ecada-7cde-5dae-bee2-58611fb74ff3",logo:"",date:"2022-07-29T17:20:00+00:00",start:"17:20",duration:"00:10",room:"JuMP",slug:"juliacon-2022-17076-optimising-fantasy-football-with-jump",url:"https://pretalx.com/juliacon-2022/talk/QNAEBY/",title:"Optimising Fantasy Football with JuMP",subtitle:"",track:"JuMP",type:"Lightning talk",language:"en",abstract:"Fantasy Premier League is an online fantasy sports game where you select a team of 15 players and score points based on their performance each week. You have a finite budget and each player costs a certain amount, plus a number of other constraints which makes this an optimisation problem that JuMP can solve. In this talk I will work through this problem and show how each constraint is translated into the JuMP language. It will be a fun introduction to optimisation in an alternative domain.",description:"",recording_license:"",do_not_record:!1,persons:[{id:9239,code:"BPSXJZ",public_name:"Dean Markwick",biography:`I've been using Julia user since 2015 and maintain a number of packages from HawkesProcesses.jl to a number of data API wrappers. \r
\r
In my day job I\u2019m currently an electronic trading quant working on both principal and algo execution. I build models, analyse data and construct algorithms to try and get the best prices in the market with the lowest impact.\r
\r
Outside of my day job I enjoy writing about technology and sports on my blog.`,answers:[]}],links:[],attachments:[],answers:[]},{id:18074,guid:"84230c2f-cd08-5cf1-900f-4a280cd0d333",logo:"",date:"2022-07-29T17:30:00+00:00",start:"17:30",duration:"00:10",room:"JuMP",slug:"juliacon-2022-18074-stochastic-optimal-control-with-markovbounds-jl",url:"https://pretalx.com/juliacon-2022/talk/QJ8YRN/",title:"Stochastic Optimal Control with MarkovBounds.jl",subtitle:"",track:"JuMP",type:"Lightning talk",language:"en",abstract:"We present MarkovBounds.jl -- a meta-package to SumOfSquares.jl which enables the computation of guaranteed bounds on the optimal value of a large class of stochastic optimal control problems via a high-level, practitioner-friendly interface.",description:`The optimal control of stochastic processes is arguably one of the most fundamental questions in the context of decision-making under uncertainty. When the controlled process is a jump-diffusion process characterized by polynomial data (drift- and diffusion coefficient, jumps, etc.), it is well known that polynomial optimization and the machinery of the moment-sum-of-squares (SOS) hierarchy provides a systematic way to construct informative (and often tight) convex relaxations for the associated optimal control problems. While the JuMP ecosystem offers with SumOfSquares.jl in principle everything that is required to study stochastic optimal control problems from this perspective, it remains a cumbersome and error-prone process to translate a concrete stochastic optimal control problem into its SOS relaxation. Moreover, this translation process requires expert knowledge, rendering it inaccessible to a large audience. MarkovBounds.jl is intended to close this gap by providing a high-level interface which allows the user to define stochastic optimal control problems in symbolic form using for example DynamicPolynomials.jl or Symbolics.jl, and automates subsequent translation to associated SOS relaxations.  Finite and (discounted) infinite horizon problems are supported as well as several common objective function types. Furthermore, MarkovBounds.jl supports the combination of standard SOS relaxations with discretization approaches to tighten the relaxations. \r
\r
In this talk, we will briefly review the conceptual ideas behind constructing SOS relaxations for stochastic optimal control problems and showcase the use of MarkovBounds.jl for the optimal control of populations in a predator-prey system, expression of protein in a stochastic bio circuit and the bounding of rare event probabilities.`,recording_license:"",do_not_record:!1,persons:[{id:10514,code:"39MLZ3",public_name:"Flemming Holtorf",biography:"Flemming is a PhD student at MIT working on computational techniques for uncertainty quantification and optimization under uncertainty.",answers:[]}],links:[],attachments:[],answers:[]},{id:17220,guid:"53dfcf13-16ca-57f0-957f-1cfa022ed4fd",logo:"",date:"2022-07-29T19:00:00+00:00",start:"19:00",duration:"00:30",room:"JuMP",slug:"juliacon-2022-17220-streamlining-nonlinear-programming-on-gpus",url:"https://pretalx.com/juliacon-2022/talk/8QUDVW/",title:"Streamlining nonlinear programming on GPUs",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"We propose a prototype for a vectorized modeler written in pure Julia, targeting the resolution of large-scale nonlinear optimization problems. The prototype has been designed to evaluate seamlessly the problem's expression tree with GPU accelerators. We discuss the implementation and the challenges we have encountered, as well as preliminary results comparing our prototype together with JuMP's AD backend.",description:"How fast can you evaluate the derivatives of a nonlinear optimization problem? Most real-world optimization instances come with thousands of variables and constraints; in such a large-scale setting using sparse automatic differentiation (AD) is often a non-negotiable requirement. It is well known that by choosing appropriately the partials (for instance with a coloring algorithm) the evaluations of the Jacobian and of the Hessian in sparse format translate respectively to one vectorized forward pass and one vectorized forward-over-reverse pass. Thus, any good AD library should be able to efficiently visit back and forth the problem's expression tree. In this talk, we propose a prototype for a vectorized modeler, where the expression tree is manipulating vector expressions. By doing so, the forward and the reverse evaluations rewrite into the universal language of sparse linear algebra. By chaining linear algebra calls together, we show that the evaluation of the expression tree can be deported to any sparse linear algebra backend. Notably, we show that both the forward and reverse passes can be streamlined efficiently, using either MKLSparse on Intel CPU or cusparse on CUDA GPU. We discuss the prototype's performance on the optimal power flow problem, using JuMP's AD backend as comparison. We show that on the largest instances, we can fasten the evaluation of the sparse Hessian by a factor of 50. Although our code remains a prototype, we have hope that the emergence of new AD library like Enzyme will permit to extend further the idea. We finish the talk by discussing ideas on how to vectorize the evaluation of the derivatives inside JuMP's AD backend.",recording_license:"",do_not_record:!1,persons:[{id:4450,code:"WC3WU3",public_name:"Fran\xE7ois Pacaud",biography:"Postdoc at Argonne National Labt",answers:[]},{id:1117,code:"DUUAYM",public_name:"Michel Schanen",biography:null,answers:[]}],links:[],attachments:[],answers:[]},{id:17985,guid:"a40503fc-7596-5185-be41-3e35a4bba831",logo:"",date:"2022-07-29T19:30:00+00:00",start:"19:30",duration:"00:30",room:"JuMP",slug:"juliacon-2022-17985-fast-optimization-via-randomized-numerical-linear-algebra",url:"https://pretalx.com/juliacon-2022/talk/EBBQDB/",title:"Fast optimization via randomized numerical linear algebra",subtitle:"",track:"JuMP",type:"Talk",language:"en",abstract:"We introduce RandomizedPreconditioners.jl, a package for preconditioning linear systems using randomized numerical linear algebra. Crucially, our preconditioners do not require a priori knowledge of structure present in the linear system, making them especially useful for general-purpose algorithms. We demonstrate significant speedups of positive semidefinite linear system solves, which we use to build fast constrained optimization solvers.",description:`In this talk, we discuss how techniques in randomized numerical linear algebra can dramatically speed up linear system solves, which are a fundamental primitive for most constrained optimization algorithms.\r
\r
We start with randomized approximations of matrices and introduce the Nystrom Sketch. Following the approach developed by Frangella et al. [1], we use this sketch to construct preconditioners for positive definite linear systems.\r
\r
We then introduce RandomizedPreconditioners.jl, a lightweight package which includes these randomized preconditioners and sketches. We show how this package allows preconditioners to be added with only a few extra lines of code, and we use the package to dramatically speedup a convex optimization solver that uses the alternating direction method of multipliers (ADMM) algorithm. We demonstrate how we can amortize the cost of this preconditioner over all solver iterations, allowing us to capture this speedup for minimal additional cost\r
\r
Finally, we conclude with future work to address other types of linear systems and other ways to speed up optimization solvers with randomized numerical linear algebra primitives that are implemented in RandomizedPreconditioners.jl.\r
\r
[1] Zachary Frangella, Joel A Tropp, and Madeleine Udell. \u201CRandomized Nystr\xF6m Preconditioning.\u201D In:arXiv preprint arXiv:2110.02820(2021). https://arxiv.org/abs/2110.02820`,recording_license:"",do_not_record:!1,persons:[{id:10507,code:"H8VVYE",public_name:"Theo Diamandis",biography:"Optimization PhD student at MIT",answers:[]}],links:[],attachments:[],answers:[]}],"Sponsored forums":[{id:21247,guid:"d2613e9b-548d-5014-8b45-1556c3b1dafd",logo:"",date:"2022-07-29T16:30:00+00:00",start:"16:30",duration:"00:45",room:"Sponsored forums",slug:"juliacon-2022-21247-relational-ai-sponsored-forum",url:"https://pretalx.com/juliacon-2022/talk/HAURQJ/",title:"Relational AI Sponsored Forum",subtitle:"",track:null,type:"Sponsor forum",language:"en",abstract:"At RelationalAI, we are building the world\u2019s fastest, most scalable, most expressive, most open knowledge graph management system, built on top of the world\u2019s only complete relational reasoning engine that uses the knowledge and data captured in enterprise databases to learn and reason.",description:"",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]}]}},{index:12,date:"2022-07-30",day_start:"2022-07-30T04:00:00+00:00",day_end:"2022-07-31T03:59:00+00:00",rooms:{Green:[{id:21383,guid:"fc82abf1-f5cd-54fd-9030-1215fc677de5",logo:"",date:"2022-07-30T12:30:00+00:00",start:"12:30",duration:"06:00",room:"Green",slug:"juliacon-2022-21383-juliacon-hackathon",url:"https://pretalx.com/juliacon-2022/talk/8MRLPJ/",title:"JuliaCon Hackathon",subtitle:"",track:null,type:"Social hour",language:"en",abstract:"Join us on [Gather.town](https://gather.town) for this year's Julia hackaton.",description:"Like in previous years we will have another legendary JuliaCon hackaton! Join us to built something you are excited about in Julia. We will also have mentors available to help if you run into issues.",recording_license:"",do_not_record:!1,persons:[],links:[],attachments:[],answers:[]}]}}]}};const xg=(e,t)=>{const a=e.__vccOpts||e;for(const[n,i]of t)a[n]=i;return a};const Fu=H({name:"VApp",props:{...Eu({fullHeight:!0}),...ve()},setup(e,t){let{slots:a}=t;const n=ke(e),{layoutClasses:i,layoutStyles:o,getLayoutItem:r,items:s,layoutRef:l}=Bu(e),{rtlClasses:c}=ma();return O(()=>{var u;return d("div",{ref:l,class:["v-application",n.themeClasses.value,i.value,c.value],style:o.value},[d("div",{class:"v-application__wrap"},[(u=a.default)==null?void 0:u.call(a)])])}),{getLayoutItem:r,items:s,theme:n}}});const Ru=H({name:"VCardActions",setup(e,t){let{slots:a}=t;return Ue({VBtn:{variant:"text"}}),O(()=>{var n;return d("div",{class:"v-card-actions"},[(n=a.default)==null?void 0:n.call(a)])}),{}}});const Ll=["x-small","small","default","large","x-large"],Yt=me({size:{type:[String,Number],default:"default"}},"size");function ln(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:qt();const a=g(()=>Ll.includes(e.size)?`${t}--size-${e.size}`:void 0),n=g(()=>!Ll.includes(e.size)&&e.size?{width:Q(e.size),height:Q(e.size)}:void 0);return{sizeClasses:a,sizeStyles:n}}const le=me({tag:{type:String,default:"div"}},"tag");function es(e){const t=g(()=>yl(e.value.background)),a=g(()=>yl(e.value.text)),n=g(()=>{const o=[];return e.value.background&&!t.value&&o.push(`bg-${e.value.background}`),e.value.text&&!a.value&&o.push(`text-${e.value.text}`),o}),i=g(()=>{const o={};return e.value.background&&t.value&&(o.backgroundColor=e.value.background),e.value.text&&a.value&&(o.color=e.value.text,o.caretColor=e.value.text),o});return{colorClasses:n,colorStyles:i}}function at(e,t){const a=g(()=>({text:Ae(e)?e.value:t?e[t]:null})),{colorClasses:n,colorStyles:i}=es(a);return{textColorClasses:n,textColorStyles:i}}function Be(e,t){const a=g(()=>({background:Ae(e)?e.value:t?e[t]:null})),{colorClasses:n,colorStyles:i}=es(a);return{backgroundColorClasses:n,backgroundColorStyles:i}}const Vu=me({color:String,start:Boolean,end:Boolean,icon:se,...Yt(),...le({tag:"i"}),...ve()},"v-icon"),Te=H({name:"VIcon",props:Vu(),setup(e,t){let{attrs:a,slots:n}=t,i;n.default&&(i=g(()=>{var u,h;const m=(u=n.default)==null?void 0:u.call(n);if(!!m)return(h=fu(m).filter(f=>f.children&&typeof f.children=="string")[0])==null?void 0:h.children}));const{themeClasses:o}=ke(e),{iconData:r}=Xp(i||e),{sizeClasses:s}=ln(e),{textColorClasses:l,textColorStyles:c}=at(z(e,"color"));return O(()=>d(r.value.component,{tag:e.tag,icon:r.value.icon,class:["v-icon","notranslate",o.value,s.value,l.value,{"v-icon--clickable":!!a.onClick,"v-icon--start":e.start,"v-icon--end":e.end}],style:[s.value?void 0:{fontSize:Q(e.size),height:Q(e.size),width:Q(e.size)},c.value],"aria-hidden":"true"},null)),{}}});const wt=me({height:[Number,String],maxHeight:[Number,String],maxWidth:[Number,String],minHeight:[Number,String],minWidth:[Number,String],width:[Number,String]},"dimension");function kt(e){return{dimensionStyles:g(()=>({height:Q(e.height),maxHeight:Q(e.maxHeight),maxWidth:Q(e.maxWidth),minHeight:Q(e.minHeight),minWidth:Q(e.minWidth),width:Q(e.width)}))}}function Cg(e){return{aspectStyles:g(()=>{const t=Number(e.aspectRatio);return t?{paddingBottom:String(1/t*100)+"%"}:void 0})}}const zu=H({name:"VResponsive",props:{aspectRatio:[String,Number],contentClass:String,...wt()},setup(e,t){let{slots:a}=t;const{aspectStyles:n}=Cg(e),{dimensionStyles:i}=kt(e);return O(()=>{var o;return d("div",{class:"v-responsive",style:i.value},[d("div",{class:"v-responsive__sizer",style:n.value},null),(o=a.additional)==null?void 0:o.call(a),a.default&&d("div",{class:["v-responsive__content",e.contentClass]},[a.default()])])}),{}}});function Sg(e,t){if(!Xr)return;const a=t.modifiers||{},n=t.value,{handler:i,options:o}=typeof n=="object"?n:{handler:n,options:{}},r=new IntersectionObserver(function(){var s;let l=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[],c=arguments.length>1?arguments[1]:void 0;const u=(s=e._observe)==null?void 0:s[t.instance.$.uid];if(!u)return;const h=l.some(m=>m.isIntersecting);i&&(!a.quiet||u.init)&&(!a.once||h||u.init)&&i(h,l,c),h&&a.once?Hu(e,t):u.init=!0},o);e._observe=Object(e._observe),e._observe[t.instance.$.uid]={init:!1,observer:r},r.observe(e)}function Hu(e,t){var a;const n=(a=e._observe)==null?void 0:a[t.instance.$.uid];!n||(n.observer.unobserve(e),delete e._observe[t.instance.$.uid])}const Ou={mounted:Sg,unmounted:Hu},co=Ou,dt=me({transition:{type:[Boolean,String,Object],default:"fade-transition",validator:e=>e!==!0}},"transition"),Tt=(e,t)=>{var a;let{slots:n}=t;const{transition:i,...o}=e;if(!i||typeof i=="boolean")return(a=n.default)==null?void 0:a.call(n);const{component:r=Dt,...s}=typeof i=="object"?i:{};return Wt(r,oe(typeof i=="string"?{name:i}:s,o),n)},cn=H({name:"VImg",directives:{intersect:co},props:{aspectRatio:[String,Number],alt:String,cover:Boolean,eager:Boolean,gradient:String,lazySrc:String,options:{type:Object,default:()=>({root:void 0,rootMargin:void 0,threshold:void 0})},sizes:String,src:{type:[String,Object],default:""},srcset:String,width:[String,Number],...dt()},emits:["loadstart","load","error"],setup(e,t){let{emit:a,slots:n}=t;const i=D(""),o=D(),r=D(e.eager?"loading":"idle"),s=D(),l=D(),c=g(()=>e.src&&typeof e.src=="object"?{src:e.src.src,srcset:e.srcset||e.src.srcset,lazySrc:e.lazySrc||e.src.lazySrc,aspect:Number(e.aspectRatio||e.src.aspect)}:{src:e.src,srcset:e.srcset,lazySrc:e.lazySrc,aspect:Number(e.aspectRatio||0)}),u=g(()=>c.value.aspect||s.value/l.value||0);re(()=>e.src,()=>{h(r.value!=="idle")}),ao(()=>h());function h(y){if(!(e.eager&&y)&&!(Xr&&!y&&!e.eager)){if(r.value="loading",c.value.lazySrc){const _=new Image;_.src=c.value.lazySrc,b(_,null)}!c.value.src||Ee(()=>{var _,M;if(a("loadstart",((_=o.value)==null?void 0:_.currentSrc)||c.value.src),(M=o.value)!=null&&M.complete){if(o.value.naturalWidth||f(),r.value==="error")return;u.value||b(o.value,null),m()}else u.value||b(o.value),p()})}}function m(){var y;p(),r.value="loaded",a("load",((y=o.value)==null?void 0:y.currentSrc)||c.value.src)}function f(){var y;r.value="error",a("error",((y=o.value)==null?void 0:y.currentSrc)||c.value.src)}function p(){const y=o.value;y&&(i.value=y.currentSrc||y.src)}function b(y){let _=arguments.length>1&&arguments[1]!==void 0?arguments[1]:100;const M=()=>{const{naturalHeight:I,naturalWidth:J}=y;I||J?(s.value=J,l.value=I):!y.complete&&r.value==="loading"&&_!=null?setTimeout(M,_):(y.currentSrc.endsWith(".svg")||y.currentSrc.startsWith("data:image/svg+xml"))&&(s.value=1,l.value=1)};M()}const w=g(()=>({"v-img__img--cover":e.cover,"v-img__img--contain":!e.cover})),v=g(()=>{var y;if(!c.value.src||r.value==="idle")return;const _=Wt("img",{class:["v-img__img",w.value],src:c.value.src,srcset:c.value.srcset,sizes:e.sizes,ref:o,onLoad:m,onError:f}),M=(y=n.sources)==null?void 0:y.call(n);return d(Tt,{transition:e.transition,appear:!0},{default:()=>[Me(M?d("picture",{class:"v-img__picture"},[M,_]):_,[[Et,r.value==="loaded"]])]})}),S=g(()=>d(Tt,{transition:e.transition},{default:()=>[c.value.lazySrc&&r.value!=="loaded"&&d("img",{class:["v-img__img","v-img__img--preload",w.value],src:c.value.lazySrc,alt:""},null)]})),k=g(()=>{if(!!n.placeholder)return d(Tt,{transition:e.transition,appear:!0},{default:()=>[(r.value==="loading"||r.value==="error"&&!n.error)&&d("div",{class:"v-img__placeholder"},[n.placeholder()])]})}),P=g(()=>{if(!!n.error)return d(Tt,{transition:e.transition,appear:!0},{default:()=>[r.value==="error"&&d("div",{class:"v-img__error"},[n.error()])]})}),j=g(()=>{if(!!e.gradient)return d("div",{class:"v-img__gradient",style:{backgroundImage:`linear-gradient(${e.gradient})`}},null)}),x=D(!1);{const y=re(u,_=>{_&&(requestAnimationFrame(()=>{requestAnimationFrame(()=>{x.value=!0})}),y())})}return O(()=>Me(d(zu,{class:["v-img",{"v-img--booting":!x.value}],style:{width:Q(e.width==="auto"?s.value:e.width)},aspectRatio:u.value,"aria-label":e.alt,role:e.alt?"img":void 0},{additional:()=>[v.value,S.value,j.value,k.value,P.value],default:n.default}),[[ct("intersect"),{handler:h,options:e.options},null,{once:!0}]])),{currentSrc:i,image:o,state:r,naturalWidth:s,naturalHeight:l}}}),_g=[null,"default","comfortable","compact"],Ge=me({density:{type:String,default:"default",validator:e=>_g.includes(e)}},"density");function Xe(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:qt();return{densityClasses:g(()=>`${t}--density-${e.density}`)}}const Ie=me({rounded:{type:[Boolean,Number,String],default:void 0}},"rounded");function Re(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:qt();return{roundedClasses:g(()=>{const n=Ae(e)?e.value:e.rounded,i=[];if(n===!0||n==="")i.push(`${t}--rounded`);else if(typeof n=="string"||n===0)for(const o of String(n).split(" "))i.push(`rounded-${o}`);return i})}}const Gu=me({color:String,start:Boolean,end:Boolean,icon:se,image:String,...Ge(),...Ie(),...Yt(),...le()}),Ja=H({name:"VAvatar",props:Gu(),setup(e,t){let{slots:a}=t;const{backgroundColorClasses:n,backgroundColorStyles:i}=Be(z(e,"color")),{densityClasses:o}=Xe(e),{roundedClasses:r}=Re(e),{sizeClasses:s,sizeStyles:l}=ln(e);return O(()=>{var c;return d(e.tag,{class:["v-avatar",{"v-avatar--start":e.start,"v-avatar--end":e.end},n.value,o.value,r.value,s.value],style:[i.value,l.value]},{default:()=>[e.image?d(cn,{src:e.image,alt:""},null):e.icon?d(Te,{icon:e.icon},null):(c=a.default)==null?void 0:c.call(a)]})}),{}}}),Nu=ut("v-card-subtitle"),$u=ut("v-card-title"),Le=Hr({name:"VDefaultsProvider",props:{defaults:Object,reset:[Number,String],root:Boolean,scoped:Boolean},setup(e,t){let{slots:a}=t;const{defaults:n,reset:i,root:o,scoped:r}=Fr(e);return Ue(n,{reset:i,root:o,scoped:r}),()=>{var s;return(s=a.default)==null?void 0:s.call(a)}}}),Uu=Hr({name:"VCardItem",props:{appendAvatar:String,appendIcon:se,prependAvatar:String,prependIcon:se,subtitle:String,title:String,...Ge()},setup(e,t){let{slots:a}=t;return O(()=>{var n,i,o,r,s,l,c,u,h;const m=!!(e.prependAvatar||e.prependIcon||a.prepend),f=!!(e.appendAvatar||e.appendIcon||a.append),p=!!(e.title||a.title),b=!!(e.subtitle||a.subtitle);return d("div",{class:"v-card-item"},[m&&d(Le,{key:"prepend",defaults:{VAvatar:{density:e.density,icon:e.prependIcon,image:e.prependAvatar},VIcon:{density:e.density,icon:e.prependIcon}}},{default:()=>[d("div",{class:"v-card-item__prepend"},[(n=(i=a.prepend)==null?void 0:i.call(a))!=null?n:d(Ja,null,null)])]}),d("div",{class:"v-card-item__content"},[p&&d($u,{key:"title"},{default:()=>[(o=(r=a.title)==null?void 0:r.call(a))!=null?o:e.title]}),b&&d(Nu,{key:"subtitle"},{default:()=>[(s=(l=a.subtitle)==null?void 0:l.call(a))!=null?s:e.subtitle]}),(c=a.default)==null?void 0:c.call(a)]),f&&d(Le,{key:"append",defaults:{VAvatar:{density:e.density,icon:e.appendIcon,image:e.appendAvatar},VIcon:{density:e.density,icon:e.appendIcon}}},{default:()=>[d("div",{class:"v-card-item__append"},[(u=(h=a.append)==null?void 0:h.call(a))!=null?u:d(Ja,null,null)])]})])}),{}}}),Wu=ut("v-card-text");const lr=Symbol("rippleStop"),Tg=80;function Dl(e,t){e.style.transform=t,e.style.webkitTransform=t}function Lo(e,t){e.style.opacity=`calc(${t} * var(--v-theme-overlay-multiplier))`}function cr(e){return e.constructor.name==="TouchEvent"}function qu(e){return e.constructor.name==="KeyboardEvent"}const jg=function(e,t){var a;let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},i=0,o=0;if(!qu(e)){const m=t.getBoundingClientRect(),f=cr(e)?e.touches[e.touches.length-1]:e;i=f.clientX-m.left,o=f.clientY-m.top}let r=0,s=.3;(a=t._ripple)!=null&&a.circle?(s=.15,r=t.clientWidth/2,r=n.center?r:r+Math.sqrt((i-r)**2+(o-r)**2)/4):r=Math.sqrt(t.clientWidth**2+t.clientHeight**2)/2;const l=`${(t.clientWidth-r*2)/2}px`,c=`${(t.clientHeight-r*2)/2}px`,u=n.center?l:`${i-r}px`,h=n.center?c:`${o-r}px`;return{radius:r,scale:s,x:u,y:h,centerX:l,centerY:c}},zi={show(e,t){var a;let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(!(t!=null&&(a=t._ripple)!=null&&a.enabled))return;const i=document.createElement("span"),o=document.createElement("span");i.appendChild(o),i.className="v-ripple__container",n.class&&(i.className+=` ${n.class}`);const{radius:r,scale:s,x:l,y:c,centerX:u,centerY:h}=jg(e,t,n),m=`${r*2}px`;o.className="v-ripple__animation",o.style.width=m,o.style.height=m,t.appendChild(i);const f=window.getComputedStyle(t);f&&f.position==="static"&&(t.style.position="relative",t.dataset.previousPosition="static"),o.classList.add("v-ripple__animation--enter"),o.classList.add("v-ripple__animation--visible"),Dl(o,`translate(${l}, ${c}) scale3d(${s},${s},${s})`),Lo(o,0),o.dataset.activated=String(performance.now()),setTimeout(()=>{o.classList.remove("v-ripple__animation--enter"),o.classList.add("v-ripple__animation--in"),Dl(o,`translate(${u}, ${h}) scale3d(1,1,1)`),Lo(o,.08)},0)},hide(e){var t;if(!(e!=null&&(t=e._ripple)!=null&&t.enabled))return;const a=e.getElementsByClassName("v-ripple__animation");if(a.length===0)return;const n=a[a.length-1];if(n.dataset.isHiding)return;n.dataset.isHiding="true";const i=performance.now()-Number(n.dataset.activated),o=Math.max(250-i,0);setTimeout(()=>{n.classList.remove("v-ripple__animation--in"),n.classList.add("v-ripple__animation--out"),Lo(n,0),setTimeout(()=>{e.getElementsByClassName("v-ripple__animation").length===1&&e.dataset.previousPosition&&(e.style.position=e.dataset.previousPosition,delete e.dataset.previousPosition),n.parentNode&&e.removeChild(n.parentNode)},300)},o)}};function Ku(e){return typeof e>"u"||!!e}function Wn(e){const t={},a=e.currentTarget;if(!(!(a!=null&&a._ripple)||a._ripple.touched||e[lr])){if(e[lr]=!0,cr(e))a._ripple.touched=!0,a._ripple.isTouch=!0;else if(a._ripple.isTouch)return;if(t.center=a._ripple.centered||qu(e),a._ripple.class&&(t.class=a._ripple.class),cr(e)){if(a._ripple.showTimerCommit)return;a._ripple.showTimerCommit=()=>{zi.show(e,a,t)},a._ripple.showTimer=window.setTimeout(()=>{var n;a!=null&&(n=a._ripple)!=null&&n.showTimerCommit&&(a._ripple.showTimerCommit(),a._ripple.showTimerCommit=null)},Tg)}else zi.show(e,a,t)}}function El(e){e[lr]=!0}function ot(e){const t=e.currentTarget;if(!(!t||!t._ripple)){if(window.clearTimeout(t._ripple.showTimer),e.type==="touchend"&&t._ripple.showTimerCommit){t._ripple.showTimerCommit(),t._ripple.showTimerCommit=null,t._ripple.showTimer=window.setTimeout(()=>{ot(e)});return}window.setTimeout(()=>{t._ripple&&(t._ripple.touched=!1)}),zi.hide(t)}}function Yu(e){const t=e.currentTarget;!t||!t._ripple||(t._ripple.showTimerCommit&&(t._ripple.showTimerCommit=null),window.clearTimeout(t._ripple.showTimer))}let qn=!1;function Xu(e){!qn&&(e.keyCode===ml.enter||e.keyCode===ml.space)&&(qn=!0,Wn(e))}function Qu(e){qn=!1,ot(e)}function Zu(e){qn&&(qn=!1,ot(e))}function ed(e,t,a){var n;const{value:i,modifiers:o}=t,r=Ku(i);if(r||zi.hide(e),e._ripple=(n=e._ripple)!=null?n:{},e._ripple.enabled=r,e._ripple.centered=o.center,e._ripple.circle=o.circle,Zo(i)&&i.class&&(e._ripple.class=i.class),r&&!a){if(o.stop){e.addEventListener("touchstart",El,{passive:!0}),e.addEventListener("mousedown",El);return}e.addEventListener("touchstart",Wn,{passive:!0}),e.addEventListener("touchend",ot,{passive:!0}),e.addEventListener("touchmove",Yu,{passive:!0}),e.addEventListener("touchcancel",ot),e.addEventListener("mousedown",Wn),e.addEventListener("mouseup",ot),e.addEventListener("mouseleave",ot),e.addEventListener("keydown",Xu),e.addEventListener("keyup",Qu),e.addEventListener("blur",Zu),e.addEventListener("dragstart",ot,{passive:!0})}else!r&&a&&td(e)}function td(e){e.removeEventListener("mousedown",Wn),e.removeEventListener("touchstart",Wn),e.removeEventListener("touchend",ot),e.removeEventListener("touchmove",Yu),e.removeEventListener("touchcancel",ot),e.removeEventListener("mouseup",ot),e.removeEventListener("mouseleave",ot),e.removeEventListener("keydown",Xu),e.removeEventListener("keyup",Qu),e.removeEventListener("dragstart",ot),e.removeEventListener("blur",Zu)}function Pg(e,t){ed(e,t,!1)}function Ig(e){delete e._ripple,td(e)}function Ag(e,t){if(t.value===t.oldValue)return;const a=Ku(t.oldValue);ed(e,t,a)}const fa={mounted:Pg,unmounted:Ig,updated:Ag},Mg=fa,Jg=["elevated","flat","tonal","outlined","text","plain"];function un(e,t){return d(pe,null,[e&&d("div",{key:"overlay",class:`${t}__overlay`},null),d("div",{key:"underlay",class:`${t}__underlay`},null)])}const Pt=me({color:String,variant:{type:String,default:"elevated",validator:e=>Jg.includes(e)}},"variant");function dn(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:qt();const a=g(()=>{const{variant:o}=sa(e);return`${t}--variant-${o}`}),{colorClasses:n,colorStyles:i}=es(g(()=>{const{variant:o,color:r}=sa(e);return{[["elevated","flat"].includes(o)?"background":"text"]:r}}));return{colorClasses:n,colorStyles:i,variantClasses:a}}function ts(e){const t=D(),a=D(!1);if(Xr){const n=new IntersectionObserver(i=>{e==null||e(i,n),a.value=!!i.find(o=>o.isIntersecting)});lt(()=>{n.disconnect()}),re(t,(i,o)=>{o&&(n.unobserve(o),a.value=!1),i&&n.observe(i)},{flush:"post"})}return{intersectionRef:t,isIntersecting:a}}function he(e,t,a){let n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:l=>l,i=arguments.length>4&&arguments[4]!==void 0?arguments[4]:l=>l;const o=Ke("useProxiedModel"),r=g(()=>{var l,c;return!!(typeof e[t]<"u"&&(o!=null&&(l=o.vnode.props)!=null&&l.hasOwnProperty(t)||o!=null&&(c=o.vnode.props)!=null&&c.hasOwnProperty(Ur(t))))}),s=D(n(e[t]));return g({get(){return r.value?n(e[t]):s.value},set(l){(r.value?n(e[t]):s.value)!==l&&(s.value=l,o==null||o.emit(`update:${t}`,i(l)))}})}const as=H({name:"VProgressLinear",props:{active:{type:Boolean,default:!0},bgColor:String,bgOpacity:[Number,String],bufferValue:{type:[Number,String],default:0},clickable:Boolean,color:String,height:{type:[Number,String],default:4},indeterminate:Boolean,max:{type:[Number,String],default:100},modelValue:{type:[Number,String],default:0},reverse:Boolean,stream:Boolean,striped:Boolean,roundedBar:Boolean,...Ie(),...le(),...ve()},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const n=he(e,"modelValue"),{isRtl:i}=ma(),{themeClasses:o}=ke(e),{textColorClasses:r,textColorStyles:s}=at(e,"color"),{backgroundColorClasses:l,backgroundColorStyles:c}=Be(g(()=>e.bgColor||e.color)),{backgroundColorClasses:u,backgroundColorStyles:h}=Be(e,"color"),{roundedClasses:m}=Re(e),{intersectionRef:f,isIntersecting:p}=ts(),b=g(()=>parseInt(e.max,10)),w=g(()=>parseInt(e.height,10)),v=g(()=>parseFloat(e.bufferValue)/b.value*100),S=g(()=>parseFloat(n.value)/b.value*100),k=g(()=>i.value!==e.reverse),P=g(()=>e.indeterminate?"fade-transition":"slide-x-transition"),j=g(()=>e.bgOpacity==null?e.bgOpacity:parseFloat(e.bgOpacity));function x(y){if(!f.value)return;const{left:_,right:M,width:I}=f.value.getBoundingClientRect(),J=k.value?I-y.clientX+(M-I):y.clientX-_;n.value=Math.round(J/I*b.value)}return O(()=>d(e.tag,{ref:f,class:["v-progress-linear",{"v-progress-linear--active":e.active&&p.value,"v-progress-linear--reverse":k.value,"v-progress-linear--rounded":e.rounded,"v-progress-linear--rounded-bar":e.roundedBar,"v-progress-linear--striped":e.striped},m.value,o.value],style:{height:e.active?Q(w.value):0,"--v-progress-linear-height":Q(w.value)},role:"progressbar","aria-valuemin":"0","aria-valuemax":e.max,"aria-valuenow":e.indeterminate?void 0:S.value,onClick:e.clickable&&x},{default:()=>[e.stream&&d("div",{key:"stream",class:["v-progress-linear__stream",r.value],style:{...s.value,[k.value?"left":"right"]:Q(-w.value),borderTop:`${Q(w.value/2)} dotted`,opacity:j.value,top:`calc(50% - ${Q(w.value/4)})`,width:Q(100-v.value,"%"),"--v-progress-linear-stream-to":Q(w.value*(k.value?1:-1))}},null),d("div",{class:["v-progress-linear__background",l.value],style:[c.value,{opacity:j.value,width:Q(e.stream?v.value:100,"%")}]},null),d(Dt,{name:P.value},{default:()=>[e.indeterminate?d("div",{class:"v-progress-linear__indeterminate"},[["long","short"].map(y=>d("div",{key:y,class:["v-progress-linear__indeterminate",y,u.value],style:h.value},null))]):d("div",{class:["v-progress-linear__determinate",u.value],style:[h.value,{width:Q(S.value,"%")}]},null)]}),a.default&&d("div",{class:"v-progress-linear__content"},[a.default({value:S.value,buffer:v.value})])]})),{}}}),ns=me({loading:Boolean},"loader");function uo(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:qt();return{loaderClasses:g(()=>({[`${t}--loading`]:e.loading}))}}function is(e,t){var a;let{slots:n}=t;return d("div",{class:`${e.name}__loader`},[((a=n.default)==null?void 0:a.call(n,{color:e.color,isActive:e.active}))||d(as,{active:e.active,color:e.color,height:"2",indeterminate:!0},null)])}const ht=me({border:[Boolean,Number,String]},"border");function xt(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:qt();return{borderClasses:g(()=>{const n=Ae(e)?e.value:e.border,i=[];if(n===!0||n==="")i.push(`${t}--border`);else if(typeof n=="string"||n===0)for(const o of String(n).split(" "))i.push(`border-${o}`);return i})}}const He=me({elevation:{type:[Number,String],validator(e){const t=parseInt(e);return!isNaN(t)&&t>=0&&t<=24}}},"elevation");function qe(e){return{elevationClasses:g(()=>{const a=Ae(e)?e.value:e.elevation,n=[];return a==null||n.push(`elevation-${a}`),n})}}const Bl={center:"center",top:"bottom",bottom:"top",left:"right",right:"left"},Fa=me({location:String},"location");function Ra(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1,a=arguments.length>2?arguments[2]:void 0;const{isRtl:n}=ma();return{locationStyles:g(()=>{if(!e.location)return{};const{side:o,align:r}=ar(e.location.split(" ").length>1?e.location:`${e.location} center`,n.value);function s(c){return a?a(c):0}const l={};return o!=="center"&&(t?l[Bl[o]]=`calc(100% - ${s(o)}px)`:l[o]=0),r!=="center"?t?l[Bl[r]]=`calc(100% - ${s(r)}px)`:l[r]=0:(o==="center"?l.top=l.left="50%":l[{top:"left",bottom:"left",left:"top",right:"top"}[o]]="50%",l.transform={top:"translateX(-50%)",bottom:"translateX(-50%)",left:"translateY(-50%)",right:"translateY(-50%)",center:"translate(-50%, -50%)"}[o]),l})}}const Lg=["static","relative","fixed","absolute","sticky"],hn=me({position:{type:String,validator:e=>Lg.includes(e)}},"position");function mn(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:qt();return{positionClasses:g(()=>e.position?`${t}--${e.position}`:void 0)}}function ad(){var e,t;return(e=Ke("useRouter"))==null||(t=e.proxy)==null?void 0:t.$router}function ai(e,t){const a=Um("RouterLink"),n=g(()=>!!(e.href||e.to)),i=g(()=>(n==null?void 0:n.value)||!!(t.onClick||t.onClickOnce));if(typeof a=="string")return{isLink:n,isClickable:i,href:z(e,"href")};const o=e.to?a.useLink(e):void 0;return{...o,isLink:n,isClickable:i,href:g(()=>e.to?o==null?void 0:o.route.value.href:e.href)}}const fn=me({href:String,replace:Boolean,to:[String,Object]},"router");let Do=!1;function Dg(e,t){let a=!1,n,i;Pe&&(Ee(()=>{window.addEventListener("popstate",o),n=e==null?void 0:e.beforeEach((r,s,l)=>{Do?a?t(l):l():setTimeout(()=>a?t(l):l()),Do=!0}),i=e==null?void 0:e.afterEach(()=>{Do=!1})}),La(()=>{var r,s;window.removeEventListener("popstate",o),(r=n)==null||r(),(s=i)==null||s()}));function o(r){var s;(s=r.state)!=null&&s.replaced||(a=!0,setTimeout(()=>a=!1))}}const nd=H({name:"VCard",directives:{Ripple:fa},props:{appendAvatar:String,appendIcon:se,disabled:Boolean,flat:Boolean,hover:Boolean,image:String,link:Boolean,prependAvatar:String,prependIcon:se,ripple:Boolean,subtitle:String,text:String,title:String,...ve(),...ht(),...Ge(),...wt(),...He(),...ns(),...Fa(),...hn(),...Ie(),...fn(),...le(),...Pt({variant:"elevated"})},setup(e,t){let{attrs:a,slots:n}=t;const{themeClasses:i}=ke(e),{borderClasses:o}=xt(e),{colorClasses:r,colorStyles:s,variantClasses:l}=dn(e),{densityClasses:c}=Xe(e),{dimensionStyles:u}=kt(e),{elevationClasses:h}=qe(e),{loaderClasses:m}=uo(e),{locationStyles:f}=Ra(e),{positionClasses:p}=mn(e),{roundedClasses:b}=Re(e),w=ai(e,a);return O(()=>{var v,S,k,P,j;const x=w.isLink.value?"a":e.tag,y=!!(n.title||e.title),_=!!(n.subtitle||e.subtitle),M=y||_,I=!!(n.append||e.appendAvatar||e.appendIcon),J=!!(n.prepend||e.prependAvatar||e.prependIcon),T=!!(n.image||e.image),L=M||J||I,B=!!(n.text||e.text),F=!e.disabled&&(w.isClickable.value||e.link);return Me(d(x,{class:["v-card",{"v-card--disabled":e.disabled,"v-card--flat":e.flat,"v-card--hover":e.hover&&!(e.disabled||e.flat),"v-card--link":F},i.value,o.value,r.value,c.value,h.value,m.value,p.value,b.value,l.value],style:[s.value,u.value,f.value],href:w.href.value,onClick:F&&w.navigate},{default:()=>[T&&d(Le,{key:"image",defaults:{VImg:{cover:!0,src:e.image}}},{default:()=>[d("div",{class:"v-card__image"},[(v=(S=n.image)==null?void 0:S.call(n))!=null?v:d(cn,null,null)])]}),d(is,{name:"v-card",active:!!e.loading,color:typeof e.loading=="boolean"?void 0:e.loading},{default:n.loader}),L&&d(Uu,{key:"item",prependAvatar:e.prependAvatar,prependIcon:e.prependIcon,title:e.title,subtitle:e.subtitle,appendAvatar:e.appendAvatar,appendIcon:e.appendIcon},{default:n.item,prepend:n.prepend,title:n.title,subtitle:n.subtitle,append:n.append}),B&&d(Wu,{key:"text"},{default:()=>[(k=(P=n.text)==null?void 0:P.call(n))!=null?k:e.text]}),(j=n.default)==null?void 0:j.call(n),n.actions&&d(Ru,null,{default:n.actions}),un(F,"v-card")]}),[[ct("ripple"),F]])}),{}}});const ur=H({name:"VContainer",props:{fluid:{type:Boolean,default:!1},...le()},setup(e,t){let{slots:a}=t;return O(()=>d(e.tag,{class:["v-container",{"v-container--fluid":e.fluid}]},a)),{}}}),os=["sm","md","lg","xl","xxl"],id=(()=>os.reduce((e,t)=>(e[t]={type:[Boolean,String,Number],default:!1},e),{}))(),od=(()=>os.reduce((e,t)=>(e["offset"+ha(t)]={type:[String,Number],default:null},e),{}))(),rd=(()=>os.reduce((e,t)=>(e["order"+ha(t)]={type:[String,Number],default:null},e),{}))(),Fl={col:Object.keys(id),offset:Object.keys(od),order:Object.keys(rd)};function Eg(e,t,a){let n=e;if(!(a==null||a===!1))return t&&(n+=`-${t.replace(e,"")}`),e==="col"&&(n="v-"+n),e==="col"&&(a===""||a===!0)||(n+=`-${a}`),n.toLowerCase()}const dr=H({name:"VCol",props:{cols:{type:[Boolean,String,Number],default:!1},...id,offset:{type:[String,Number],default:null},...od,order:{type:[String,Number],default:null},...rd,alignSelf:{type:String,default:null,validator:e=>["auto","start","end","center","baseline","stretch"].includes(e)},...le()},setup(e,t){let{slots:a}=t;const n=g(()=>{const i=[];let o;for(o in Fl)Fl[o].forEach(s=>{const l=e[s],c=Eg(o,s,l);c&&i.push(c)});const r=i.some(s=>s.startsWith("v-col-"));return i.push({"v-col":!r||!e.cols,[`v-col-${e.cols}`]:e.cols,[`offset-${e.offset}`]:e.offset,[`order-${e.order}`]:e.order,[`align-self-${e.alignSelf}`]:e.alignSelf}),i});return()=>{var i;return Wt(e.tag,{class:n.value},(i=a.default)==null?void 0:i.call(a))}}}),Bg=["sm","md","lg","xl","xxl"],rs=["start","end","center"];function ss(e,t){return Bg.reduce((a,n)=>(a[e+ha(n)]=t(),a),{})}const sd=e=>[...rs,"baseline","stretch"].includes(e),ld=ss("align",()=>({type:String,default:null,validator:sd})),cd=e=>[...rs,"space-between","space-around"].includes(e),ud=ss("justify",()=>({type:String,default:null,validator:cd})),dd=e=>[...rs,"space-between","space-around","stretch"].includes(e),hd=ss("alignContent",()=>({type:String,default:null,validator:dd})),Rl={align:Object.keys(ld),justify:Object.keys(ud),alignContent:Object.keys(hd)},Fg={align:"align",justify:"justify",alignContent:"align-content"};function Rg(e,t,a){let n=Fg[e];if(a!=null)return t&&(n+=`-${t.replace(e,"")}`),n+=`-${a}`,n.toLowerCase()}const hr=H({name:"VRow",props:{dense:Boolean,noGutters:Boolean,align:{type:String,default:null,validator:sd},...ld,justify:{type:String,default:null,validator:cd},...ud,alignContent:{type:String,default:null,validator:dd},...hd,...le()},setup(e,t){let{slots:a}=t;const n=g(()=>{const i=[];let o;for(o in Rl)Rl[o].forEach(r=>{const s=e[r],l=Rg(o,r,s);l&&i.push(l)});return i.push({"v-row--no-gutters":e.noGutters,"v-row--dense":e.dense,[`align-${e.align}`]:e.align,[`justify-${e.justify}`]:e.justify,[`align-content-${e.alignContent}`]:e.alignContent}),i});return()=>{var i;return Wt(e.tag,{class:["v-row",n.value]},(i=a.default)==null?void 0:i.call(a))}}}),Vg=ut("flex-grow-1","div","VSpacer");function We(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"top center 0",a=arguments.length>2?arguments[2]:void 0;return H({name:e,props:{group:Boolean,hideOnLeave:Boolean,leaveAbsolute:Boolean,mode:{type:String,default:a},origin:{type:String,default:t}},setup(n,i){let{slots:o}=i;return()=>{const r=n.group?Yf:Dt;return Wt(r,{name:e,mode:n.mode,onBeforeEnter(s){s.style.transformOrigin=n.origin},onLeave(s){if(n.leaveAbsolute){const{offsetTop:l,offsetLeft:c,offsetWidth:u,offsetHeight:h}=s;s._transitionInitialStyles={position:s.style.position,top:s.style.top,left:s.style.left,width:s.style.width,height:s.style.height},s.style.position="absolute",s.style.top=`${l}px`,s.style.left=`${c}px`,s.style.width=`${u}px`,s.style.height=`${h}px`}n.hideOnLeave&&s.style.setProperty("display","none","important")},onAfterLeave(s){if(n.leaveAbsolute&&s!=null&&s._transitionInitialStyles){const{position:l,top:c,left:u,width:h,height:m}=s._transitionInitialStyles;delete s._transitionInitialStyles,s.style.position=l||"",s.style.top=c||"",s.style.left=u||"",s.style.width=h||"",s.style.height=m||""}}},o.default)}}})}function md(e,t){let a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:"in-out";return H({name:e,props:{mode:{type:String,default:a}},setup(n,i){let{slots:o}=i;return()=>Wt(Dt,{name:e,...t},o.default)}})}function fd(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"";const a=(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)?"width":"height",n=bt(`offset-${a}`);return{onBeforeEnter(r){r._parent=r.parentNode,r._initialStyle={transition:r.style.transition,overflow:r.style.overflow,[a]:r.style[a]}},onEnter(r){const s=r._initialStyle;r.style.setProperty("transition","none","important"),r.style.overflow="hidden";const l=`${r[n]}px`;r.style[a]="0",r.offsetHeight,r.style.transition=s.transition,e&&r._parent&&r._parent.classList.add(e),requestAnimationFrame(()=>{r.style[a]=l})},onAfterEnter:o,onEnterCancelled:o,onLeave(r){r._initialStyle={transition:"",overflow:r.style.overflow,[a]:r.style[a]},r.style.overflow="hidden",r.style[a]=`${r[n]}px`,r.offsetHeight,requestAnimationFrame(()=>r.style[a]="0")},onAfterLeave:i,onLeaveCancelled:i};function i(r){e&&r._parent&&r._parent.classList.remove(e),o(r)}function o(r){const s=r._initialStyle[a];r.style.overflow=r._initialStyle.overflow,s!=null&&(r.style[a]=s),delete r._initialStyle}}const ho=H({name:"VDialogTransition",props:{target:Object},setup(e,t){let{slots:a}=t;const n={onBeforeEnter(i){i.style.pointerEvents="none",i.style.visibility="hidden"},async onEnter(i,o){var r;await new Promise(f=>requestAnimationFrame(f)),await new Promise(f=>requestAnimationFrame(f)),i.style.visibility="";const{x:s,y:l,sx:c,sy:u,speed:h}=zl(e.target,i),m=i.animate([{transform:`translate(${s}px, ${l}px) scale(${c}, ${u})`,opacity:0},{transform:""}],{duration:225*h,easing:Vp});(r=Vl(i))==null||r.forEach(f=>{f.animate([{opacity:0},{opacity:0,offset:.33},{opacity:1}],{duration:225*2*h,easing:Nn})}),m.finished.then(()=>o())},onAfterEnter(i){i.style.removeProperty("pointer-events")},onBeforeLeave(i){i.style.pointerEvents="none"},async onLeave(i,o){var r;await new Promise(f=>requestAnimationFrame(f));const{x:s,y:l,sx:c,sy:u,speed:h}=zl(e.target,i);i.animate([{transform:""},{transform:`translate(${s}px, ${l}px) scale(${c}, ${u})`,opacity:0}],{duration:125*h,easing:zp}).finished.then(()=>o()),(r=Vl(i))==null||r.forEach(f=>{f.animate([{},{opacity:0,offset:.2},{opacity:0}],{duration:125*2*h,easing:Nn})})},onAfterLeave(i){i.style.removeProperty("pointer-events")}};return()=>e.target?d(Dt,oe({name:"dialog-transition"},n,{css:!1}),a):d(Dt,{name:"dialog-transition"},a)}});function Vl(e){var t;const a=(t=e.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list"))==null?void 0:t.children;return a&&[...a]}function zl(e,t){const a=e.getBoundingClientRect(),n=Wr(t),[i,o]=getComputedStyle(t).transformOrigin.split(" ").map(v=>parseFloat(v)),[r,s]=getComputedStyle(t).getPropertyValue("--v-overlay-anchor-origin").split(" ");let l=a.left+a.width/2;r==="left"||s==="left"?l-=a.width/2:(r==="right"||s==="right")&&(l+=a.width/2);let c=a.top+a.height/2;r==="top"||s==="top"?c-=a.height/2:(r==="bottom"||s==="bottom")&&(c+=a.height/2);const u=a.width/n.width,h=a.height/n.height,m=Math.max(1,u,h),f=u/m,p=h/m,b=n.width*n.height/(window.innerWidth*window.innerHeight),w=b>.12?Math.min(1.5,(b-.12)*10+1):1;return{x:l-(i+n.left),y:c-(o+n.top),sx:f,sy:p,speed:w}}const zg=We("carousel-transition"),Hg=We("carousel-reverse-transition"),Og=We("tab-transition"),Gg=We("tab-reverse-transition"),Ng=We("menu-transition"),$g=We("fab-transition","center center","out-in"),Ug=We("dialog-bottom-transition"),Wg=We("dialog-top-transition"),mr=We("fade-transition"),pd=We("scale-transition"),qg=We("scroll-x-transition"),Kg=We("scroll-x-reverse-transition"),Yg=We("scroll-y-transition"),Xg=We("scroll-y-reverse-transition"),Qg=We("slide-x-transition"),Zg=We("slide-x-reverse-transition"),ls=We("slide-y-transition"),ev=We("slide-y-reverse-transition"),mo=md("expand-transition",fd()),cs=md("expand-x-transition",fd("",!0)),us=Symbol.for("vuetify:v-slider");function fr(e,t,a){const n=a==="vertical",i=t.getBoundingClientRect(),o="touches"in e?e.touches[0]:e;return n?o.clientY-(i.top+i.height/2):o.clientX-(i.left+i.width/2)}function tv(e,t){return"touches"in e&&e.touches.length?e.touches[0][t]:"changedTouches"in e&&e.changedTouches.length?e.changedTouches[0][t]:e[t]}const gd=me({disabled:Boolean,error:Boolean,readonly:Boolean,max:{type:[Number,String],default:100},min:{type:[Number,String],default:0},step:{type:[Number,String],default:0},thumbColor:String,thumbLabel:{type:[Boolean,String],default:void 0,validator:e=>typeof e=="boolean"||e==="always"},thumbSize:{type:[Number,String],default:20},showTicks:{type:[Boolean,String],default:!1,validator:e=>typeof e=="boolean"||e==="always"},ticks:{type:[Array,Object]},tickSize:{type:[Number,String],default:2},color:String,trackColor:String,trackFillColor:String,trackSize:{type:[Number,String],default:4},direction:{type:String,default:"horizontal",validator:e=>["vertical","horizontal"].includes(e)},reverse:Boolean,...Ie(),...He({elevation:2})},"slider"),vd=e=>{let{props:t,handleSliderMouseUp:a,handleMouseMove:n,getActiveThumb:i}=e;const{isRtl:o}=ma(),r=g(()=>o.value!==t.reverse),s=g(()=>{let Y=o.value?"rtl":"ltr";return t.reverse&&(Y=Y==="rtl"?"ltr":"rtl"),Y}),l=g(()=>parseFloat(t.min)),c=g(()=>parseFloat(t.max)),u=g(()=>t.step>0?parseFloat(t.step):0),h=g(()=>{const Y=u.value.toString().trim();return Y.includes(".")?Y.length-Y.indexOf(".")-1:0}),m=g(()=>parseInt(t.thumbSize,10)),f=g(()=>parseInt(t.tickSize,10)),p=g(()=>parseInt(t.trackSize,10)),b=g(()=>(c.value-l.value)/u.value),w=z(t,"disabled"),v=g(()=>t.direction==="vertical"),S=g(()=>{var Y;return t.error||t.disabled?void 0:(Y=t.thumbColor)!=null?Y:t.color}),k=g(()=>{var Y;return t.error||t.disabled?void 0:(Y=t.trackColor)!=null?Y:t.color}),P=g(()=>{var Y;return t.error||t.disabled?void 0:(Y=t.trackFillColor)!=null?Y:t.color}),j=D(!1),x=D(0),y=D(),_=D();function M(Y){if(u.value<=0)return Y;const xe=Lt(Y,l.value,c.value),ze=l.value%u.value,Qe=Math.round((xe-ze)/u.value)*u.value+ze;return parseFloat(Math.min(Qe,c.value).toFixed(h.value))}function I(Y){var xe;const ze=t.direction==="vertical",Qe=ze?"top":"left",Ha=ze?"height":"width",li=ze?"clientY":"clientX",{[Qe]:Zt,[Ha]:bn}=(xe=y.value)==null?void 0:xe.$el.getBoundingClientRect(),yn=tv(Y,li);let C=Math.min(Math.max((yn-Zt-x.value)/bn,0),1)||0;return(ze||r.value)&&(C=1-C),M(l.value+C*(c.value-l.value))}let J=!1;const T=Y=>{J||(x.value=0,a(I(Y))),j.value=!1,J=!1,x.value=0},L=Y=>{_.value=i(Y),_.value&&(_.value.focus(),j.value=!0,_.value.contains(Y.target)?(J=!0,x.value=fr(Y,_.value,t.direction)):(x.value=0,n(I(Y))))},B={passive:!0,capture:!0};function F(Y){J=!0,n(I(Y))}function $(Y){Y.stopPropagation(),Y.preventDefault(),T(Y),window.removeEventListener("mousemove",F,B),window.removeEventListener("mouseup",$)}function N(Y){Y.stopPropagation(),Y.preventDefault(),T(Y),window.removeEventListener("touchmove",F,B),window.removeEventListener("touchend",N)}function K(Y){L(Y),window.addEventListener("touchmove",F,B),window.addEventListener("touchend",N,{passive:!1})}function de(Y){Y.preventDefault(),L(Y),window.addEventListener("mousemove",F,B),window.addEventListener("mouseup",$,{passive:!1})}const Z=Y=>{const xe=(Y-l.value)/(c.value-l.value)*100;return Lt(isNaN(xe)?0:xe,0,100)},te=g(()=>t.ticks?Array.isArray(t.ticks)?t.ticks.map(Y=>({value:Y,position:Z(Y),label:Y.toString()})):Object.keys(t.ticks).map(Y=>({value:parseInt(Y,10),position:Z(parseInt(Y,10)),label:t.ticks[Y]})):b.value!==1/0?_a(b.value+1).map(Y=>{const xe=l.value+Y*u.value;return{value:xe,position:Z(xe)}}):[]),fe=g(()=>te.value.some(Y=>{let{label:xe}=Y;return!!xe})),Je={activeThumbRef:_,color:z(t,"color"),decimals:h,disabled:w,direction:z(t,"direction"),elevation:z(t,"elevation"),hasLabels:fe,horizontalDirection:s,isReversed:r,min:l,max:c,mousePressed:j,numTicks:b,onSliderMousedown:de,onSliderTouchstart:K,parsedTicks:te,parseMouseMove:I,position:Z,readonly:z(t,"readonly"),rounded:z(t,"rounded"),roundValue:M,showTicks:z(t,"showTicks"),startOffset:x,step:u,thumbSize:m,thumbColor:S,thumbLabel:z(t,"thumbLabel"),ticks:z(t,"ticks"),tickSize:f,trackColor:k,trackContainerRef:y,trackFillColor:P,trackSize:p,vertical:v};return Oe(us,Je),Je},pr=H({name:"VSliderThumb",directives:{Ripple:Mg},props:{focused:Boolean,max:{type:Number,required:!0},min:{type:Number,required:!0},modelValue:{type:Number,required:!0},position:{type:Number,required:!0}},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a,emit:n}=t;const i=we(us);if(!i)throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");const{thumbColor:o,step:r,vertical:s,disabled:l,thumbSize:c,thumbLabel:u,direction:h,readonly:m,elevation:f,isReversed:p,horizontalDirection:b,mousePressed:w,decimals:v}=i,{textColorClasses:S,textColorStyles:k}=at(o),{pageup:P,pagedown:j,end:x,home:y,left:_,right:M,down:I,up:J}=er,T=[P,j,x,y,_,M,I,J],L=g(()=>r.value?[1,2,3]:[1,5,10]);function B($,N){if(!T.includes($.key))return;$.preventDefault();const K=r.value||.1,de=(e.max-e.min)/K;if([_,M,I,J].includes($.key)){const te=(p.value?[_,J]:[M,J]).includes($.key)?1:-1,fe=$.shiftKey?2:$.ctrlKey?1:0;N=N+te*K*L.value[fe]}else if($.key===y)N=e.min;else if($.key===x)N=e.max;else{const Z=$.key===j?1:-1;N=N-Z*K*(de>100?de/10:10)}return Math.max(e.min,Math.min(e.max,N))}function F($){const N=B($,e.modelValue);N!=null&&n("update:modelValue",N)}return O(()=>{var $,N;const K=Q(s.value?100-e.position:e.position,"%"),de=s.value?"block":"inline",{elevationClasses:Z}=qe(g(()=>l.value?void 0:f.value));return d("div",{class:["v-slider-thumb",{"v-slider-thumb--focused":e.focused,"v-slider-thumb--pressed":e.focused&&w.value}],style:{[`inset-${de}-start`]:`calc(${K} - var(--v-slider-thumb-size) / 2)`,"--v-slider-thumb-size":Q(c.value),direction:s.value?void 0:b.value},role:"slider",tabindex:l.value?-1:0,"aria-valuemin":e.min,"aria-valuemax":e.max,"aria-valuenow":e.modelValue,"aria-readonly":m.value,"aria-orientation":h.value,onKeydown:m.value?void 0:F},[d("div",{class:["v-slider-thumb__surface",S.value,Z.value],style:{...k.value}},null),Me(d("div",{class:["v-slider-thumb__ripple",S.value],style:k.value},null),[[ct("ripple"),!0,null,{circle:!0,center:!0}]]),d(pd,{origin:"bottom center"},{default:()=>[Me(d("div",{class:"v-slider-thumb__label-container"},[d("div",{class:["v-slider-thumb__label"]},[d("div",null,[($=(N=a["thumb-label"])==null?void 0:N.call(a,{modelValue:e.modelValue}))!=null?$:e.modelValue.toFixed(r.value?v.value:1)])])]),[[Et,u.value&&e.focused||u.value==="always"]])]})])}),{}}});const bd=H({name:"VSliderTrack",props:{start:{type:Number,required:!0},stop:{type:Number,required:!0}},emits:{},setup(e,t){let{slots:a}=t;const n=we(us);if(!n)throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");const{color:i,horizontalDirection:o,parsedTicks:r,rounded:s,showTicks:l,tickSize:c,trackColor:u,trackFillColor:h,trackSize:m,vertical:f}=n,{roundedClasses:p}=Re(s),{backgroundColorClasses:b,backgroundColorStyles:w}=Be(h),{backgroundColorClasses:v,backgroundColorStyles:S}=Be(u),k=g(()=>`inset-${f.value?"block-end":"inline-start"}`),P=g(()=>f.value?"height":"width"),j=g(()=>({[k.value]:"0%",[P.value]:"100%"})),x=g(()=>e.stop-e.start),y=g(()=>({[k.value]:Q(e.start,"%"),[P.value]:Q(x.value,"%")})),_=g(()=>(f.value?r.value.slice().reverse():r.value).map((I,J)=>{var T,L;const B=f.value?"bottom":"margin-inline-start",F=I.position>0&&I.position<100?Q(I.position,"%"):void 0;return d("div",{key:I.value,class:["v-slider-track__tick",{"v-slider-track__tick--filled":I.position>=e.start&&I.position<=e.stop}],style:{[B]:F}},[(I.label||a["tick-label"])&&d("div",{class:"v-slider-track__tick-label"},[(T=(L=a["tick-label"])==null?void 0:L.call(a,{tick:I,index:J}))!=null?T:I.label])])}));return O(()=>d("div",{class:["v-slider-track",p.value],style:{"--v-slider-track-size":Q(m.value),"--v-slider-tick-size":Q(c.value),direction:f.value?void 0:o.value}},[d("div",{class:["v-slider-track__background",v.value,{"v-slider-track__background--opacity":!!i.value||!h.value}],style:{...j.value,...S.value}},null),d("div",{class:["v-slider-track__fill",b.value],style:{...y.value,...w.value}},null),l.value&&d("div",{class:["v-slider-track__ticks",{"v-slider-track__ticks--always-show":l.value==="always"}]},[_.value])])),{}}});const yd=H({name:"VMessages",props:{active:Boolean,color:String,messages:{type:[Array,String],default:()=>[]},...dt({transition:{component:ls,leaveAbsolute:!0,group:!0}})},setup(e,t){let{slots:a}=t;const n=g(()=>vt(e.messages)),{textColorClasses:i,textColorStyles:o}=at(g(()=>e.color));return O(()=>d(Tt,{transition:e.transition,tag:"div",class:["v-messages",i.value],style:o.value},{default:()=>[e.active&&n.value.map((r,s)=>d("div",{class:"v-messages__message",key:`${s}-${n.value}`},[a.message?a.message({message:r}):r]))]})),{}}}),wd=Symbol.for("vuetify:form"),av=me({disabled:Boolean,fastFail:Boolean,lazyValidation:Boolean,readonly:Boolean,modelValue:{type:Boolean,default:null}});function nv(e){const t=he(e,"modelValue"),a=g(()=>e.disabled),n=g(()=>e.readonly),i=D(!1),o=D([]),r=D([]);async function s(){const u=[];let h=!0;r.value=[],i.value=!0;for(const m of o.value){const f=await m.validate();if(f.length>0&&(h=!1,u.push({id:m.id,errorMessages:f})),!h&&e.fastFail)break}return r.value=u,i.value=!1,{valid:h,errors:r.value}}function l(){o.value.forEach(u=>u.reset()),t.value=null}function c(){o.value.forEach(u=>u.resetValidation()),r.value=[],t.value=null}return re(o,()=>{let u=null;o.value.some(h=>h.isValid===!1)?u=!1:o.value.every(h=>h.isValid===!0)&&(u=!0),t.value=u},{deep:!0}),Oe(wd,{register:(u,h,m,f,p)=>{o.value.some(b=>b.id===u)&&Aa(`Duplicate input name "${u}"`),o.value.push({id:u,validate:h,reset:m,resetValidation:f,isValid:p})},unregister:u=>{o.value=o.value.filter(h=>h.id!==u)},isDisabled:a,isReadonly:n,isValidating:i,items:o}),{errors:r,isDisabled:a,isReadonly:n,isValidating:i,items:o,validate:s,reset:l,resetValidation:c}}function iv(){return we(wd,null)}const kd=me({disabled:Boolean,error:Boolean,errorMessages:{type:[Array,String],default:()=>[]},maxErrors:{type:[Number,String],default:1},name:String,readonly:Boolean,rules:{type:Array,default:()=>[]},modelValue:null,validationValue:null});function xd(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:qt(),a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:Ye();const n=he(e,"modelValue"),i=g(()=>{var k;return(k=e.validationValue)!=null?k:n.value}),o=iv(),r=D([]),s=D(!0),l=g(()=>!!(vt(n.value===""?null:n.value).length||vt(i.value===""?null:i.value).length)),c=g(()=>!!(e.disabled||o!=null&&o.isDisabled.value)),u=g(()=>!!(e.readonly||o!=null&&o.isReadonly.value)),h=g(()=>e.errorMessages.length?vt(e.errorMessages):r.value),m=g(()=>e.error||h.value.length?!1:e.rules.length&&s.value?null:!0),f=D(!1),p=g(()=>({[`${t}--error`]:m.value===!1,[`${t}--dirty`]:l.value,[`${t}--disabled`]:c.value,[`${t}--readonly`]:u.value})),b=g(()=>{var k;return(k=e.name)!=null?k:sa(a)});ao(()=>{o==null||o.register(b.value,S,w,v,m)}),lt(()=>{o==null||o.unregister(b.value)}),re(i,()=>{i.value!=null&&S()});function w(){v(),n.value=null}function v(){s.value=!0,r.value=[]}async function S(){const k=[];f.value=!0;for(const P of e.rules){if(k.length>=(e.maxErrors||1))break;const x=await(typeof P=="function"?P:()=>P)(i.value);if(x!==!0){if(typeof x!="string"){console.warn(`${x} is not a valid value. Rule functions must return boolean true or a string.`);continue}k.push(x)}}return r.value=k,f.value=!1,s.value=!1,r.value}return{errorMessages:h,isDirty:l,isDisabled:c,isReadonly:u,isPristine:s,isValid:m,isValidating:f,reset:w,resetValidation:v,validate:S,validationClasses:p}}const Xt=me({id:String,appendIcon:se,prependIcon:se,hideDetails:[Boolean,String],messages:{type:[Array,String],default:()=>[]},direction:{type:String,default:"horizontal",validator:e=>["horizontal","vertical"].includes(e)},...Ge(),...kd()}),Ft=Fe()({name:"VInput",props:{...Xt()},emits:{"update:modelValue":e=>!0},setup(e,t){let{attrs:a,slots:n,emit:i}=t;const{densityClasses:o}=Xe(e),r=Ye(),s=g(()=>e.id||`input-${r}`),{errorMessages:l,isDirty:c,isDisabled:u,isReadonly:h,isPristine:m,isValid:f,isValidating:p,reset:b,resetValidation:w,validate:v,validationClasses:S}=xd(e,"v-input",s),k=g(()=>({id:s,isDirty:c,isDisabled:u,isReadonly:h,isPristine:m,isValid:f,isValidating:p,reset:b,resetValidation:w,validate:v}));return O(()=>{var P,j,x,y,_;const M=!!(n.prepend||e.prependIcon),I=!!(n.append||e.appendIcon),J=!!((P=e.messages)!=null&&P.length||l.value.length),T=!e.hideDetails||e.hideDetails==="auto"&&J;return d("div",{class:["v-input",`v-input--${e.direction}`,o.value,S.value]},[M&&d("div",{key:"prepend",class:"v-input__prepend"},[e.prependIcon&&d(Te,{key:"prepend-icon",onClick:a["onClick:prepend"],icon:e.prependIcon},null),(j=n.prepend)==null?void 0:j.call(n,k.value)]),n.default&&d("div",{class:"v-input__control"},[(x=n.default)==null?void 0:x.call(n,k.value)]),I&&d("div",{key:"append",class:"v-input__append"},[(y=n.append)==null?void 0:y.call(n,k.value),e.appendIcon&&d(Te,{key:"append-icon",onClick:a["onClick:append"],icon:e.appendIcon},null)]),T&&d("div",{class:"v-input__details"},[d(yd,{active:J,messages:l.value.length>0?l.value:e.messages},{message:n.message}),(_=n.details)==null?void 0:_.call(n,k.value)])])}),{reset:b,resetValidation:w,validate:v}}});function pa(e){return Bt(e,Object.keys(Ft.props))}const ds=me({focused:Boolean},"focus");function hs(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:qt();const a=he(e,"focused"),n=g(()=>({[`${t}--focused`]:a.value}));function i(){a.value=!0}function o(){a.value=!1}return{focusClasses:n,isFocused:a,focus:i,blur:o}}const Hi=H({name:"VSlider",props:{...ds(),...gd(),...Xt(),modelValue:{type:[Number,String],default:0}},emits:{"update:focused":e=>!0,"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const n=D(),{min:i,max:o,mousePressed:r,roundValue:s,onSliderMousedown:l,onSliderTouchstart:c,trackContainerRef:u,position:h,hasLabels:m,readonly:f}=vd({props:e,handleSliderMouseUp:k=>p.value=s(k),handleMouseMove:k=>p.value=s(k),getActiveThumb:()=>{var k;return(k=n.value)==null?void 0:k.$el}}),p=he(e,"modelValue",void 0,k=>{const P=typeof k=="string"?parseFloat(k):k==null?i.value:k;return s(P)}),{isFocused:b,focus:w,blur:v}=hs(e),S=g(()=>h(p.value));return O(()=>{const[k,P]=pa(e);return d(Ft,oe({class:["v-slider",{"v-slider--has-labels":!!a["tick-label"]||m.value,"v-slider--focused":b.value,"v-slider--pressed":r.value,"v-slider--disabled":e.disabled}]},k,{focused:b.value}),{...a,default:j=>{let{id:x}=j;return d("div",{class:"v-slider__container",onMousedown:f.value?void 0:l,onTouchstartPassive:f.value?void 0:c},[d("input",{id:x.value,name:e.name||x.value,disabled:e.disabled,readonly:e.readonly,tabindex:"-1",value:p.value},null),d(bd,{ref:u,start:0,stop:S.value},{"tick-label":a["tick-label"]}),d(pr,{ref:n,focused:b.value,min:i.value,max:o.value,modelValue:p.value,"onUpdate:modelValue":y=>p.value=y,position:S.value,elevation:e.elevation,onFocus:w,onBlur:v},{"thumb-label":a["thumb-label"]})])}})}),{}}});const fo=H({name:"VLabel",props:{text:String,...ve()},setup(e,t){let{slots:a}=t;return O(()=>{var n;return d("label",{class:"v-label"},[e.text,(n=a.default)==null?void 0:n.call(a)])}),{}}}),Tn=H({name:"VFieldLabel",props:{floating:Boolean},setup(e,t){let{slots:a}=t;return O(()=>d(fo,{class:["v-field-label",{"v-field-label--floating":e.floating}],"aria-hidden":e.floating||void 0},a)),{}}}),ov=["underlined","outlined","filled","solo","plain"],po=me({appendInnerIcon:se,bgColor:String,clearable:Boolean,clearIcon:{type:se,default:"$clear"},active:Boolean,color:String,dirty:Boolean,disabled:Boolean,error:Boolean,label:String,persistentClear:Boolean,prependInnerIcon:se,reverse:Boolean,singleLine:Boolean,variant:{type:String,default:"filled",validator:e=>ov.includes(e)},...ve(),...ns()},"v-field"),ni=Fe()({name:"VField",inheritAttrs:!1,props:{id:String,...ds(),...po()},emits:{"click:clear":e=>!0,"click:control":e=>!0,"update:focused":e=>!0,"update:modelValue":e=>!0},setup(e,t){let{attrs:a,emit:n,slots:i}=t;const{themeClasses:o}=ke(e),{loaderClasses:r}=uo(e),{focusClasses:s,isFocused:l,focus:c,blur:u}=hs(e),h=g(()=>e.dirty||e.active),m=g(()=>!e.singleLine&&!!(e.label||i.label)),f=Ye(),p=g(()=>e.id||`input-${f}`),b=D(),w=D(),v=D(),{backgroundColorClasses:S,backgroundColorStyles:k}=Be(z(e,"bgColor")),{textColorClasses:P,textColorStyles:j}=at(g(()=>h.value&&l.value&&!e.error&&!e.disabled?e.color:void 0));re(h,_=>{if(m.value){const M=b.value.$el,I=w.value.$el,J=Wr(M),T=I.getBoundingClientRect(),L=T.x-J.x,B=T.y-J.y-(J.height/2-T.height/2),F=T.width/.75,$=Math.abs(F-J.width)>1?{maxWidth:Q(F)}:void 0,N=parseFloat(getComputedStyle(M).transitionDuration)*1e3,K=parseFloat(getComputedStyle(I).getPropertyValue("--v-field-label-scale"));M.style.visibility="visible",I.style.visibility="hidden",M.animate([{transform:"translate(0)"},{transform:`translate(${L}px, ${B}px) scale(${K})`,...$}],{duration:N,easing:Nn,direction:_?"normal":"reverse"}).finished.then(()=>{M.style.removeProperty("visibility"),I.style.removeProperty("visibility")})}},{flush:"post"});const x=g(()=>({isActive:h,isFocused:l,controlRef:v,blur:u,focus:c}));function y(_){_.target!==document.activeElement&&_.preventDefault(),n("click:control",_)}return O(()=>{var _,M,I;const J=e.variant==="outlined",T=i["prepend-inner"]||e.prependInnerIcon,L=!!(e.clearable||i.clear),B=!!(i["append-inner"]||e.appendInnerIcon||L),F=i.label?i.label({label:e.label,props:{for:p.value}}):e.label;return d("div",oe({class:["v-field",{"v-field--active":h.value,"v-field--appended":B,"v-field--disabled":e.disabled,"v-field--dirty":e.dirty,"v-field--error":e.error,"v-field--has-background":!!e.bgColor,"v-field--persistent-clear":e.persistentClear,"v-field--prepended":T,"v-field--reverse":e.reverse,"v-field--single-line":e.singleLine,"v-field--has-label":!!F,[`v-field--variant-${e.variant}`]:!0},o.value,S.value,s.value,r.value],style:[k.value,j.value],onClick:y},a),[d("div",{class:"v-field__overlay"},null),d(is,{name:"v-field",active:e.loading,color:e.error?"error":e.color},{default:i.loader}),T&&d("div",{key:"prepend",class:"v-field__prepend-inner"},[e.prependInnerIcon&&d(Te,{key:"prepend-icon",onClick:a["onClick:prependInner"],icon:e.prependInnerIcon},null),(_=i["prepend-inner"])==null?void 0:_.call(i,x.value)]),d("div",{class:"v-field__field","data-no-activator":""},[["solo","filled"].includes(e.variant)&&m.value&&d(Tn,{key:"floating-label",ref:w,class:[P.value],floating:!0},{default:()=>[F]}),d(Tn,{ref:b,for:p.value},{default:()=>[F]}),(M=i.default)==null?void 0:M.call(i,{...x.value,props:{id:p.value,class:"v-field__input"},focus:c,blur:u})]),L&&d(cs,{key:"clear"},{default:()=>[Me(d("div",{class:"v-field__clearable"},[i.clear?i.clear():d(Te,{onClick:$=>n("click:clear",$),icon:e.clearIcon},null)]),[[Et,e.dirty]])]}),B&&d("div",{key:"append",class:"v-field__append-inner"},[(I=i["append-inner"])==null?void 0:I.call(i,x.value),e.appendInnerIcon&&d(Te,{key:"append-icon",onClick:a["onClick:appendInner"],icon:e.appendInnerIcon},null)]),d("div",{class:["v-field__outline",P.value]},[J&&d(pe,null,[d("div",{class:"v-field__outline__start"},null),m.value&&d("div",{class:"v-field__outline__notch"},[d(Tn,{ref:w,floating:!0},{default:()=>[F]})]),d("div",{class:"v-field__outline__end"},null)]),["plain","underlined"].includes(e.variant)&&m.value&&d(Tn,{ref:w,floating:!0},{default:()=>[F]})])])}),{controlRef:v}}});function ms(e){return Bt(e,Object.keys(ni.props))}const go=H({name:"VCounter",functional:!0,props:{active:Boolean,max:[Number,String],value:{type:[Number,String],default:0},...dt({transition:{component:ls}})},setup(e,t){let{slots:a}=t;const n=g(()=>e.max?`${e.value} / ${e.max}`:String(e.value));return O(()=>d(Tt,{transition:e.transition},{default:()=>[Me(d("div",{class:"v-counter"},[a.default?a.default({counter:n.value,max:e.max,value:e.value}):n.value]),[[Et,e.active]])]})),{}}});function Qt(e){for(var t=arguments.length,a=new Array(t>1?t-1:0),n=1;n<t;n++)a[n-1]=arguments[n];return new Proxy(e,{get(i,o){if(Reflect.has(i,o))return Reflect.get(i,o);for(const r of a)if(r.value&&Reflect.has(r.value,o)){const s=Reflect.get(r.value,o);return typeof s=="function"?s.bind(r.value):s}},getOwnPropertyDescriptor(i,o){const r=Reflect.getOwnPropertyDescriptor(i,o);if(r)return r;for(const s of a){if(!s.value)continue;const l=Reflect.getOwnPropertyDescriptor(s.value,o);if(l)return l}for(const s of a){let l=s.value&&Object.getPrototypeOf(s.value);for(;l;){const c=Reflect.getOwnPropertyDescriptor(l,o);if(c)return c;l=Object.getPrototypeOf(l)}}}})}const rv=["color","file","time","date","datetime-local","week","month"],ii=Fe()({name:"VTextField",directives:{Intersect:co},inheritAttrs:!1,props:{autofocus:Boolean,counter:[Boolean,Number,String],counterValue:Function,hint:String,persistentHint:Boolean,prefix:String,placeholder:String,persistentPlaceholder:Boolean,persistentCounter:Boolean,suffix:String,type:{type:String,default:"text"},...Xt(),...po()},emits:{"click:clear":e=>!0,"click:control":e=>!0,"click:input":e=>!0,"update:modelValue":e=>!0},setup(e,t){let{attrs:a,emit:n,slots:i}=t;const o=he(e,"modelValue"),r=g(()=>{var S;return typeof e.counterValue=="function"?e.counterValue(o.value):((S=o.value)!=null?S:"").toString().length}),s=g(()=>{if(a.maxlength)return a.maxlength;if(!(!e.counter||typeof e.counter!="number"&&typeof e.counter!="string"))return e.counter});function l(S,k){var P,j;!e.autofocus||!S||(P=k[0].target)==null||(j=P.focus)==null||j.call(P)}const c=D(),u=D(),h=D(!1),m=D(),f=g(()=>rv.includes(e.type)||e.persistentPlaceholder||h.value),p=g(()=>e.messages.length?e.messages:h.value||e.persistentHint?e.hint:"");function b(){if(m.value!==document.activeElement){var S;(S=m.value)==null||S.focus()}h.value||(h.value=!0)}function w(S){b(),n("click:control",S)}function v(S){S.stopPropagation(),b(),Ee(()=>{o.value="",n("click:clear",S)})}return O(()=>{const S=!!(i.counter||e.counter||e.counterValue),[k,P]=Ba(a),[{modelValue:j,...x}]=pa(e),[y]=ms(e);return d(Ft,oe({ref:c,modelValue:o.value,"onUpdate:modelValue":_=>o.value=_,class:["v-text-field",{"v-text-field--prefixed":e.prefix,"v-text-field--suffixed":e.suffix,"v-text-field--flush-details":["plain","underlined"].includes(e.variant)}],"onClick:prepend":a["onClick:prepend"],"onClick:append":a["onClick:append"]},k,x,{messages:p.value}),{...i,default:_=>{let{id:M,isDisabled:I,isDirty:J,isReadonly:T,isValid:L}=_;return d(ni,oe({ref:u,onMousedown:B=>{B.target!==m.value&&B.preventDefault()},"onClick:control":w,"onClick:clear":v,"onClick:prependInner":a["onClick:prependInner"],"onClick:appendInner":a["onClick:appendInner"],role:"textbox"},y,{id:M.value,active:f.value||J.value,dirty:J.value||e.dirty,focused:h.value,error:L.value===!1}),{...i,default:B=>{var F;let{props:{class:$,...N}}=B;return d(pe,null,[e.prefix&&d("span",{class:"v-text-field__prefix"},[e.prefix]),d("div",{class:$,onClick:K=>n("click:input",K),"data-no-activator":""},[(F=i.default)==null?void 0:F.call(i),Me(d("input",oe({ref:m,"onUpdate:modelValue":K=>o.value=K,autofocus:e.autofocus,readonly:T.value,disabled:I.value,name:e.name,placeholder:e.placeholder,size:1,type:e.type,onFocus:b,onBlur:()=>h.value=!1},N,P),null),[[uu,o.value],[ct("intersect"),{handler:l},null,{once:!0}]])]),e.suffix&&d("span",{class:"v-text-field__suffix"},[e.suffix])])}})},details:S?()=>d(pe,null,[d("span",null,null),d(go,{active:e.persistentCounter||h.value,value:r.value,max:s.value},i.counter)]):void 0})}),Qt({},c,u,m)}}),sv=e=>(Am("data-v-49bc9be5"),e=e(),Mm(),e),lv=sv(()=>io("span",null," What is your time zone: ",-1)),cv={__name:"App",setup(e){const t=s=>{const l=s.slice(0,2),c=s.slice(3,5);return parseInt(l)*60+parseInt(c)},a=s=>{const l=Math.floor(s/60),c=l<10?`0${l}`:`${l}`;s=s%60;let u=`${c}:${s}`;return s==0&&(u=u+"0"),u},n=kg.conference.days.slice(8,11),i=D(0),o=Object.keys(n[0].rooms),r={};for(const s of o){if(s=="Sponsored forums")continue;const l=n[0].rooms[s];let c="12:30";r[s]={color:s=="Red"?"red":"white",title:[],start:[],duration:[],height:[]};for(let u=0;u<l.length;u++){const h=l[u];if(c<h.start){r[s].title.push("EMPTY"),r[s].start.push(c);const m=h.start,f=t(m)-t(c);r[s].duration.push(f),r[s].height.push(f),c=a(t(c)+f)}r[s].title.push(h.title),r[s].start.push(h.start),r[s].duration.push(t(h.duration)),r[s].height.push(t(h.duration)),c=a(t(c)+t(h.duration))}}return(s,l)=>(pi(),qs(Fu,null,{default:na(()=>[d(ur,null,{default:na(()=>[d(hr,null,{default:na(()=>[d(dr,{cols:"12",sm:"4"},{default:na(()=>[lv,d(Hi,{modelValue:i.value,"onUpdate:modelValue":l[0]||(l[0]=c=>i.value=c),min:"-12",max:"12",step:"1"},null,8,["modelValue"]),d(ii,{modelValue:i.value,"onUpdate:modelValue":l[1]||(l[1]=c=>i.value=c),"hide-details":"",density:"compact",type:"number"},null,8,["modelValue"])]),_:1})]),_:1})]),_:1}),d(ur,{fluid:""},{default:na(()=>[d(hr,{"no-gutters":""},{default:na(()=>[(pi(),Ws(pe,null,Fs(r,(c,u)=>d(dr,{key:u,cols:"12",sm:"2"},{default:na(()=>[io("h2",null,Lh(u),1),(pi(!0),Ws(pe,null,Fs(c.title,(h,m)=>(pi(),qs(nd,{id:u+"-"+c.start[m],key:m,class:Ui(h=="EMPTY"?"":u),style:$i({height:c.height[m]*10+"px"}),title:a(t(c.start[m])+60*i.value),text:h},null,8,["id","class","style","title","text"]))),128))]),_:2},1024)),64))]),_:1})]),_:1})]),_:1}))}},uv=xg(cv,[["__scopeId","data-v-49bc9be5"]]),dv="modulepreload",hv=function(e){return"/jc2022/"+e},Hl={},mv=function(t,a,n){return!a||a.length===0?t():Promise.all(a.map(i=>{if(i=hv(i),i in Hl)return;Hl[i]=!0;const o=i.endsWith(".css"),r=o?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${i}"]${r}`))return;const s=document.createElement("link");if(s.rel=o?"stylesheet":dv,o||(s.as="script",s.crossOrigin=""),s.href=i,document.head.appendChild(s),o)return new Promise((l,c)=>{s.addEventListener("load",l),s.addEventListener("error",()=>c(new Error(`Unable to preload CSS for ${i}`)))})})).then(()=>t())};async function fv(){(await mv(()=>import("./webfontloader.b777d690.js").then(t=>t.w),[])).load({google:{families:["Roboto:100,300,400,500,700,900&display=swap"]}})}const Oi=Fe()({name:"VToolbarTitle",props:{text:String,...le()},setup(e,t){let{slots:a}=t;return O(()=>{var n;const i=!!(a.default||a.text||e.text);return d(e.tag,{class:"v-toolbar-title"},{default:()=>[i&&d("div",{class:"v-toolbar-title__placeholder"},[a.text?a.text():e.text,(n=a.default)==null?void 0:n.call(a)])]})}),{}}}),pv=[null,"prominent","default","comfortable","compact"],Cd=me({absolute:Boolean,collapse:Boolean,color:String,density:{type:String,default:"default",validator:e=>pv.includes(e)},extended:Boolean,extensionHeight:{type:[Number,String],default:48},flat:Boolean,floating:Boolean,height:{type:[Number,String],default:64},image:String,title:String,...ht(),...He(),...Ie(),...le({tag:"header"}),...ve()},"v-toolbar"),Gi=Fe()({name:"VToolbar",props:Cd(),setup(e,t){var a;let{slots:n}=t;const{backgroundColorClasses:i,backgroundColorStyles:o}=Be(z(e,"color")),{borderClasses:r}=xt(e),{elevationClasses:s}=qe(e),{roundedClasses:l}=Re(e),{themeClasses:c}=ke(e),u=D(!!(e.extended||(a=n.extension)!=null&&a.call(n))),h=g(()=>parseInt(Number(e.height)+(e.density==="prominent"?Number(e.height):0)-(e.density==="comfortable"?8:0)-(e.density==="compact"?16:0),10)),m=g(()=>u.value?parseInt(Number(e.extensionHeight)+(e.density==="prominent"?Number(e.extensionHeight):0)-(e.density==="comfortable"?4:0)-(e.density==="compact"?8:0),10):0);return Ue({VBtn:{variant:"text"}}),O(()=>{var f,p,b,w,v;const S=!!(e.title||n.title),k=!!(n.image||e.image),P=(f=n.extension)==null?void 0:f.call(n);return u.value=!!(e.extended||P),d(e.tag,{class:["v-toolbar",{"v-toolbar--absolute":e.absolute,"v-toolbar--collapse":e.collapse,"v-toolbar--flat":e.flat,"v-toolbar--floating":e.floating,[`v-toolbar--density-${e.density}`]:!0},i.value,r.value,s.value,l.value,c.value],style:[o.value]},{default:()=>[k&&d("div",{key:"image",class:"v-toolbar__image"},[d(Le,{defaults:{VImg:{cover:!0,src:e.image}}},{default:()=>[n.image?(p=n.image)==null?void 0:p.call(n):d(cn,null,null)]})]),d("div",{class:"v-toolbar__content",style:{height:Q(h.value)}},[n.prepend&&d("div",{class:"v-toolbar__prepend"},[(b=n.prepend)==null?void 0:b.call(n)]),S&&d(Oi,{key:"title",text:e.title},{text:n.title}),(w=n.default)==null?void 0:w.call(n),n.append&&d("div",{class:"v-toolbar__append"},[(v=n.append)==null?void 0:v.call(n)])]),d(mo,null,{default:()=>[u.value&&d("div",{class:"v-toolbar__extension",style:{height:Q(m.value)}},[P])]})]})}),Qt({contentHeight:h,extensionHeight:m})}});function gv(e){var t;return Bt(e,Object.keys((t=Gi==null?void 0:Gi.props)!=null?t:{}))}const vv=H({name:"VAppBar",props:{modelValue:{type:Boolean,default:!0},location:{type:String,default:"top",validator:e=>["top","bottom"].includes(e)},...Cd(),...rn(),height:{type:[Number,String],default:64}},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const n=D(),i=he(e,"modelValue"),o=g(()=>{var s,l,c,u;const h=(s=(l=n.value)==null?void 0:l.contentHeight)!=null?s:0,m=(c=(u=n.value)==null?void 0:u.extensionHeight)!=null?c:0;return h+m}),{layoutItemStyles:r}=sn({id:e.name,order:g(()=>parseInt(e.order,10)),position:z(e,"location"),layoutSize:o,elementSize:o,active:i,absolute:z(e,"absolute")});return O(()=>{const[s]=gv(e);return d(Gi,oe({ref:n,class:["v-app-bar",{"v-app-bar--bottom":e.location==="bottom"}],style:{...r.value,height:void 0}},s),a)}),{}}});const Sd=H({name:"VBtnGroup",props:{divided:Boolean,...ht(),...Ge(),...He(),...Ie(),...le(),...ve(),...Pt()},setup(e,t){let{slots:a}=t;const{themeClasses:n}=ke(e),{densityClasses:i}=Xe(e),{borderClasses:o}=xt(e),{elevationClasses:r}=qe(e),{roundedClasses:s}=Re(e);Ue({VBtn:{height:"auto",color:z(e,"color"),density:z(e,"density"),flat:!0,variant:z(e,"variant")}}),O(()=>d(e.tag,{class:["v-btn-group",{"v-btn-group--divided":e.divided},n.value,o.value,i.value,r.value,s.value]},a))}}),pn=me({modelValue:{type:null,default:void 0},multiple:Boolean,mandatory:[Boolean,String],max:Number,selectedClass:String,disabled:Boolean},"group"),Va=me({value:null,disabled:Boolean,selectedClass:String},"group-item");function gn(e,t){let a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!0;const n=Ke("useGroupItem");if(!n)throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");const i=Ye();Oe(Symbol.for(`${t.description}:id`),i);const o=we(t,null);if(!o){if(!a)return o;throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${t.description}`)}const r=z(e,"value"),s=g(()=>o.disabled.value||e.disabled);o.register({id:i,value:r,disabled:s},n),lt(()=>{o.unregister(i)});const l=g(()=>o.isSelected(i)),c=g(()=>l.value&&[o.selectedClass.value,e.selectedClass]);return re(l,u=>{n.emit("group:selected",{value:u})}),{id:i,isSelected:l,toggle:()=>o.select(i,!l.value),select:u=>o.select(i,u),selectedClass:c,value:r,disabled:s,group:o}}function za(e,t){let a=!1;const n=tt([]),i=he(e,"modelValue",[],m=>m==null?[]:_d(n,vt(m)),m=>{const f=yv(n,m);return e.multiple?f:f[0]}),o=Ke("useGroup");function r(m,f){const p=m,b=Symbol.for(`${t.description}:id`),v=Jn(b,o==null?void 0:o.vnode).indexOf(f);v>-1?n.splice(v,0,p):n.push(p)}function s(m){if(a)return;l();const f=n.findIndex(p=>p.id===m);n.splice(f,1)}function l(){const m=n.find(f=>!f.disabled);m&&e.mandatory==="force"&&!i.value.length&&(i.value=[m.id])}yt(()=>{l()}),lt(()=>{a=!0});function c(m,f){const p=n.find(v=>v.id===m);if(!(f&&p!=null&&p.disabled))if(e.multiple){var b;const v=i.value.slice(),S=v.findIndex(P=>P===m),k=~S;if(f=(b=f)!=null?b:!k,k&&e.mandatory&&v.length<=1||!k&&e.max!=null&&v.length+1>e.max)return;S<0&&f?v.push(m):S>=0&&!f&&v.splice(S,1),i.value=v}else{var w;const v=i.value.includes(m);if(e.mandatory&&v)return;i.value=((w=f)!=null?w:!v)?[m]:[]}}function u(m){if(e.multiple&&Aa('This method is not supported when using "multiple" prop'),i.value.length){const f=i.value[0],p=n.findIndex(v=>v.id===f);let b=(p+m)%n.length,w=n[b];for(;w.disabled&&b!==p;)b=(b+m)%n.length,w=n[b];if(w.disabled)return;i.value=[n[b].id]}else{const f=n.find(p=>!p.disabled);f&&(i.value=[f.id])}}const h={register:r,unregister:s,selected:i,select:c,disabled:z(e,"disabled"),prev:()=>u(n.length-1),next:()=>u(1),isSelected:m=>i.value.includes(m),selectedClass:g(()=>e.selectedClass),items:g(()=>n),getItemIndex:m=>bv(n,m)};return Oe(t,h),h}function bv(e,t){const a=_d(e,[t]);return a.length?e.findIndex(n=>n.id===a[0]):-1}function _d(e,t){const a=[];for(let n=0;n<e.length;n++){const i=e[n];i.value!=null?t.find(o=>ti(o,i.value))!=null&&a.push(i.id):t.includes(n)&&a.push(i.id)}return a}function yv(e,t){const a=[];for(let n=0;n<e.length;n++){const i=e[n];t.includes(i.id)&&a.push(i.value!=null?i.value:n)}return a}const fs=Symbol.for("vuetify:v-btn-toggle"),wv=Fe()({name:"VBtnToggle",props:pn({selectedClass:"v-btn--selected"}),emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const{isSelected:n,next:i,prev:o,select:r,selected:s}=za(e,fs);return O(()=>{var l;return d(Sd,{class:"v-btn-toggle"},{default:()=>[(l=a.default)==null?void 0:l.call(a,{isSelected:n,next:i,prev:o,select:r,selected:s})]})}),{next:i,prev:o,select:r}}});const ps=H({name:"VProgressCircular",props:{bgColor:String,color:String,indeterminate:[Boolean,String],modelValue:{type:[Number,String],default:0},rotate:{type:[Number,String],default:0},width:{type:[Number,String],default:4},...Yt(),...le({tag:"div"}),...ve()},setup(e,t){let{slots:a}=t;const n=20,i=2*Math.PI*n,o=D(),{themeClasses:r}=ke(e),{sizeClasses:s,sizeStyles:l}=ln(e),{textColorClasses:c,textColorStyles:u}=at(z(e,"color")),{textColorClasses:h,textColorStyles:m}=at(z(e,"bgColor")),{intersectionRef:f,isIntersecting:p}=ts(),{resizeRef:b,contentRect:w}=an(),v=g(()=>Math.max(0,Math.min(100,parseFloat(e.modelValue)))),S=g(()=>Number(e.width)),k=g(()=>l.value?Number(e.size):w.value?w.value.width:Math.max(S.value,32)),P=g(()=>n/(1-S.value/k.value)*2),j=g(()=>S.value/k.value*P.value),x=g(()=>Q((100-v.value)/100*i));return $t(()=>{f.value=o.value,b.value=o.value}),O(()=>d(e.tag,{ref:o,class:["v-progress-circular",{"v-progress-circular--indeterminate":!!e.indeterminate,"v-progress-circular--visible":p.value,"v-progress-circular--disable-shrink":e.indeterminate==="disable-shrink"},r.value,s.value,c.value],style:[l.value,u.value],role:"progressbar","aria-valuemin":"0","aria-valuemax":"100","aria-valuenow":e.indeterminate?void 0:v.value},{default:()=>[d("svg",{style:{transform:`rotate(calc(-90deg + ${Number(e.rotate)}deg))`},xmlns:"http://www.w3.org/2000/svg",viewBox:`0 0 ${P.value} ${P.value}`},[d("circle",{class:["v-progress-circular__underlay",h.value],style:m.value,fill:"transparent",cx:"50%",cy:"50%",r:n,"stroke-width":j.value,"stroke-dasharray":i,"stroke-dashoffset":0},null),d("circle",{class:"v-progress-circular__overlay",fill:"transparent",cx:"50%",cy:"50%",r:n,"stroke-width":j.value,"stroke-dasharray":i,"stroke-dashoffset":x.value},null)]),a.default&&d("div",{class:"v-progress-circular__content"},[a.default({value:v.value})])]})),{}}});function kv(e,t){re(()=>{var a;return(a=e.isExactActive)==null?void 0:a.value},a=>{e.isLink.value&&a&&t&&Ee(()=>{t(!0)})},{immediate:!0})}const rt=H({name:"VBtn",directives:{Ripple:fa},props:{active:Boolean,symbol:{type:null,default:fs},flat:Boolean,icon:[Boolean,String,Function,Object],prependIcon:se,appendIcon:se,block:Boolean,stacked:Boolean,ripple:{type:Boolean,default:!0},...ht(),...Ie(),...Ge(),...wt(),...He(),...Va(),...ns(),...Fa(),...hn(),...fn(),...Yt(),...le({tag:"button"}),...ve(),...Pt({variant:"elevated"})},setup(e,t){let{attrs:a,slots:n}=t;const{themeClasses:i}=ke(e),{borderClasses:o}=xt(e),{colorClasses:r,colorStyles:s,variantClasses:l}=dn(e),{densityClasses:c}=Xe(e),{dimensionStyles:u}=kt(e),{elevationClasses:h}=qe(e),{loaderClasses:m}=uo(e),{locationStyles:f}=Ra(e),{positionClasses:p}=mn(e),{roundedClasses:b}=Re(e),{sizeClasses:w}=ln(e),v=gn(e,e.symbol,!1),S=ai(e,a),k=g(()=>(v==null?void 0:v.disabled.value)||e.disabled),P=g(()=>e.variant==="elevated"&&!(e.disabled||e.flat||e.border));return kv(S,v==null?void 0:v.select),O(()=>{var j,x,y,_,M,I,J,T;const L=S.isLink.value?"a":e.tag,B=!v||v.isSelected.value,F=!!(e.prependIcon||n.prepend),$=!!(e.appendIcon||n.append);return Me(d(L,{type:L==="a"?void 0:"button",class:["v-btn",v==null?void 0:v.selectedClass.value,{"v-btn--active":e.active,"v-btn--block":e.block,"v-btn--disabled":k.value,"v-btn--elevated":P.value,"v-btn--flat":e.flat,"v-btn--icon":!!e.icon,"v-btn--loading":e.loading,"v-btn--stacked":e.stacked},i.value,o.value,B?r.value:void 0,c.value,h.value,m.value,p.value,b.value,w.value,l.value],style:[B?s.value:void 0,u.value,f.value],disabled:k.value||void 0,href:S.href.value,onClick:N=>{var K;k.value||((K=S.navigate)==null||K.call(S,N),v==null||v.toggle())}},{default:()=>[un(!0,"v-btn"),!e.icon&&F&&d(Le,{key:"prepend",defaults:{VIcon:{icon:e.prependIcon}}},{default:()=>[d("div",{class:"v-btn__prepend"},[(j=(x=n.prepend)==null?void 0:x.call(n))!=null?j:d(Te,null,null)])]}),d("div",{class:"v-btn__content","data-no-activator":""},[d(Le,{key:"content",defaults:{VIcon:{icon:typeof e.icon=="string"?e.icon:void 0}}},{default:()=>[(y=(_=n.default)==null?void 0:_.call(n))!=null?y:typeof e.icon=="string"&&d(Te,{key:"icon"},null)]})]),!e.icon&&$&&d(Le,{key:"append",defaults:{VIcon:{icon:e.appendIcon}}},{default:()=>[d("div",{class:"v-btn__append"},[(M=(I=n.append)==null?void 0:I.call(n))!=null?M:d(Te,null,null)])]}),!!e.loading&&d("span",{key:"loader",class:"v-btn__loader"},[(J=(T=n.loader)==null?void 0:T.call(n))!=null?J:d(ps,{color:typeof e.loading=="boolean"?void 0:e.loading,indeterminate:!0,size:"23",width:"2"},null)])]}),[[ct("ripple"),!k.value&&e.ripple,null]])}),{}}}),xv=H({name:"VAppBarNavIcon",props:{icon:{type:se,default:"$menu"}},setup(e,t){let{slots:a}=t;return O(()=>d(rt,{class:"v-app-bar-nav-icon",icon:e.icon},a)),{}}}),Cv=H({name:"VToolbarItems",props:Pt({variant:"text"}),setup(e,t){let{slots:a}=t;return Ue({VBtn:{color:z(e,"color"),height:"inherit",variant:z(e,"variant")}}),O(()=>{var n;return d("div",{class:"v-toolbar-items"},[(n=a.default)==null?void 0:n.call(a)])}),{}}}),Sv=H({name:"VAppBarTitle",props:{...Oi.props},setup(e,t){let{slots:a}=t;return O(()=>d(Oi,{class:"v-app-bar-title"},a)),{}}});const Td=ut("v-alert-title"),_v=["success","info","warning","error"],Tv=H({name:"VAlert",props:{border:{type:[Boolean,String],validator:e=>typeof e=="boolean"||["top","end","bottom","start"].includes(e)},borderColor:String,closable:Boolean,closeIcon:{type:se,default:"$close"},closeLabel:{type:String,default:"$vuetify.close"},icon:{type:[Boolean,String,Function,Object],default:null},modelValue:{type:Boolean,default:!0},prominent:Boolean,title:String,text:String,type:{type:String,validator:e=>_v.includes(e)},...Ge(),...wt(),...He(),...Fa(),...hn(),...Ie(),...le(),...ve(),...Pt({variant:"flat"})},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const n=he(e,"modelValue"),i=g(()=>{var k;if(e.icon!==!1)return e.type?(k=e.icon)!=null?k:`$${e.type}`:e.icon}),o=g(()=>{var k;return{color:(k=e.color)!=null?k:e.type,variant:e.variant}}),{themeClasses:r}=ke(e),{colorClasses:s,colorStyles:l,variantClasses:c}=dn(o),{densityClasses:u}=Xe(e),{dimensionStyles:h}=kt(e),{elevationClasses:m}=qe(e),{locationStyles:f}=Ra(e),{positionClasses:p}=mn(e),{roundedClasses:b}=Re(e),{textColorClasses:w,textColorStyles:v}=at(z(e,"borderColor"));function S(k){n.value=!1}return()=>{var k;const P=!!(a.prepend||i.value),j=!!(a.title||e.title),x=!!(e.text||a.text),y=!!(a.close||e.closable);return n.value&&d(e.tag,{class:["v-alert",e.border&&{"v-alert--border":!!e.border,[`v-alert--border-${e.border===!0?"start":e.border}`]:!0},{"v-alert--prominent":e.prominent},r.value,s.value,u.value,m.value,p.value,b.value,c.value],style:[l.value,h.value,f.value],role:"alert"},{default:()=>[un(!1,"v-alert"),e.border&&d("div",{key:"border",class:["v-alert__border",w.value],style:v.value},null),P&&d(Le,{key:"prepend",defaults:{VIcon:{density:e.density,icon:i.value,size:e.prominent?44:"default"}}},{default:()=>[d("div",{class:"v-alert__prepend"},[a.prepend?a.prepend():i.value&&d(Te,null,null)])]}),d("div",{class:"v-alert__content"},[j&&d(Td,{key:"title"},{default:()=>[a.title?a.title():e.title]}),x&&(a.text?a.text():e.text),(k=a.default)==null?void 0:k.call(a)]),a.append&&d("div",{key:"append",class:"v-alert__append"},[a.append()]),y&&d(Le,{key:"close",defaults:{VIcon:{icon:e.closeIcon,size:"small"}}},{default:()=>[d("div",{class:"v-alert__close",onClick:S},[a.close?a.close():d(Te,null,null)])]})]})}}});const jd=Symbol.for("vuetify:selection-control-group"),Pd=H({name:"VSelectionControlGroup",props:{disabled:Boolean,id:String,inline:Boolean,name:String,falseIcon:se,trueIcon:se,multiple:{type:Boolean,default:null},readonly:Boolean,type:String,modelValue:null},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const n=he(e,"modelValue"),i=Ye(),o=g(()=>e.id||`v-selection-control-group-${i}`),r=g(()=>e.name||o.value);return Oe(jd,{disabled:z(e,"disabled"),inline:z(e,"inline"),modelValue:n,multiple:g(()=>!!e.multiple||e.multiple==null&&Array.isArray(n.value)),name:r,falseIcon:z(e,"falseIcon"),trueIcon:z(e,"trueIcon"),readonly:z(e,"readonly"),type:z(e,"type")}),O(()=>{var s;return d("div",{class:"v-selection-control-group","aria-labelled-by":e.type==="radio"?o.value:void 0,role:e.type==="radio"?"radiogroup":void 0},[(s=a.default)==null?void 0:s.call(a)])}),{}}}),vo=me({color:String,disabled:Boolean,error:Boolean,id:String,inline:Boolean,label:String,falseIcon:se,trueIcon:se,ripple:{type:Boolean,default:!0},multiple:{type:Boolean,default:null},name:String,readonly:Boolean,trueValue:null,falseValue:null,modelValue:null,type:String,value:null,valueComparator:{type:Function,default:ti},...ve(),...Ge()});function jv(e){const t=we(jd,void 0),{densityClasses:a}=Xe(e),n=he(e,"modelValue"),i=g(()=>e.trueValue!==void 0?e.trueValue:e.value!==void 0?e.value:!0),o=g(()=>e.falseValue!==void 0?e.falseValue:!1),r=g(()=>(t==null?void 0:t.multiple.value)||!!e.multiple||e.multiple==null&&Array.isArray(n.value)),s=g({get(){const h=t?t.modelValue.value:n.value;return r.value?h.some(m=>e.valueComparator(m,i.value)):e.valueComparator(h,i.value)},set(h){if(e.readonly)return;const m=h?i.value:o.value;let f=m;r.value&&(f=h?[...vt(n.value),m]:vt(n.value).filter(p=>!e.valueComparator(p,i.value))),t?t.modelValue.value=f:n.value=f}}),{textColorClasses:l,textColorStyles:c}=at(g(()=>s.value&&!e.error&&!e.disabled?e.color:void 0)),u=g(()=>{var h,m;return s.value?(h=t==null?void 0:t.trueIcon.value)!=null?h:e.trueIcon:(m=t==null?void 0:t.falseIcon.value)!=null?m:e.falseIcon});return{group:t,densityClasses:a,trueValue:i,falseValue:o,model:s,textColorClasses:l,textColorStyles:c,icon:u}}const oi=Fe()({name:"VSelectionControl",directives:{Ripple:fa},inheritAttrs:!1,props:vo(),emits:{"update:modelValue":e=>!0},setup(e,t){let{attrs:a,slots:n}=t;const{densityClasses:i,group:o,icon:r,model:s,textColorClasses:l,textColorStyles:c,trueValue:u}=jv(e),h=Ye(),m=g(()=>e.id||`input-${h}`),f=D(!1),p=D(!1),b=D();function w(S){f.value=!0,(!or||or&&S.target.matches(":focus-visible"))&&(p.value=!0)}function v(){f.value=!1,p.value=!1}return O(()=>{var S,k,P,j;const x=n.label?n.label({label:e.label,props:{for:m.value}}):e.label,y=(S=o==null?void 0:o.type.value)!=null?S:e.type,[_,M]=Ba(a);return d("div",oe({class:["v-selection-control",{"v-selection-control--dirty":s.value,"v-selection-control--disabled":e.disabled,"v-selection-control--error":e.error,"v-selection-control--focused":f.value,"v-selection-control--focus-visible":p.value,"v-selection-control--inline":(o==null?void 0:o.inline.value)||e.inline},i.value]},_),[d("div",{class:["v-selection-control__wrapper",l.value],style:c.value},[(k=n.default)==null?void 0:k.call(n),Me(d("div",{class:["v-selection-control__input"]},[r.value&&d(Te,{key:"icon",icon:r.value},null),Me(d("input",oe({"onUpdate:modelValue":I=>s.value=I,ref:b,disabled:e.disabled,id:m.value,onBlur:v,onFocus:w,"aria-readonly":e.readonly,type:y,value:u.value,name:(P=o==null?void 0:o.name.value)!=null?P:e.name,"aria-checked":y==="checkbox"?s.value:void 0},M),null),[[uu,s.value]]),(j=n.input)==null?void 0:j.call(n,{model:s,textColorClasses:l,props:{onFocus:w,onBlur:v,id:m.value}})]),[[ct("ripple"),e.ripple&&[!e.disabled&&!e.readonly,null,["center","circle"]]]])]),x&&d(fo,{for:m.value},{default:()=>[x]})])}),{isFocused:f,input:b}}});function Id(e){return Bt(e,Object.keys(oi.props))}const Ad=me({indeterminate:Boolean,indeterminateIcon:{type:se,default:"$checkboxIndeterminate"},...vo({falseIcon:"$checkboxOff",trueIcon:"$checkboxOn"})}),vn=H({name:"VCheckboxBtn",props:Ad(),emits:{"update:modelValue":e=>!0,"update:indeterminate":e=>!0},setup(e,t){let{slots:a,emit:n}=t;const i=he(e,"indeterminate");function o(l){i.value&&(i.value=!1),n("update:modelValue",l)}const r=g(()=>e.indeterminate?e.indeterminateIcon:e.falseIcon),s=g(()=>e.indeterminate?e.indeterminateIcon:e.trueIcon);return O(()=>d(oi,oe(e,{class:"v-checkbox-btn",type:"checkbox",inline:!0,"onUpdate:modelValue":o,falseIcon:r.value,trueIcon:s.value,"aria-checked":e.indeterminate?"mixed":void 0}),a)),{}}});function Pv(e){return Bt(e,Object.keys(vn.props))}const Iv=H({name:"VCheckbox",inheritAttrs:!1,props:{...Xt(),...Ad()},setup(e,t){let{attrs:a,slots:n}=t;const i=Ye(),o=g(()=>e.id||`checkbox-${i}`);return O(()=>{const[r,s]=Ba(a),[l,c]=pa(e),[u,h]=Pv(e);return d(Ft,oe({class:"v-checkbox"},r,l,{id:o.value}),{...n,default:m=>{let{id:f,isDisabled:p,isReadonly:b}=m;return d(vn,oe(u,{id:f.value,disabled:p.value,readonly:b.value},s),n)}})}),{}}});const Md=Symbol.for("vuetify:v-chip-group"),Av=H({name:"VChipGroup",props:{column:Boolean,filter:Boolean,valueComparator:{type:Function,default:ti},...pn({selectedClass:"v-chip--selected"}),...le(),...ve(),...Pt({variant:"tonal"})},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const{themeClasses:n}=ke(e),{isSelected:i,select:o,next:r,prev:s,selected:l}=za(e,Md);return Ue({VChip:{color:z(e,"color"),filter:z(e,"filter"),variant:z(e,"variant")}}),O(()=>{var c;return d(e.tag,{class:["v-chip-group",{"v-chip-group--column":e.column},n.value]},{default:()=>[(c=a.default)==null?void 0:c.call(a,{isSelected:i,select:o,next:r,prev:s,selected:l.value})]})}),{}}}),ri=H({name:"VChip",directives:{Ripple:fa},props:{activeClass:String,appendAvatar:String,appendIcon:se,closable:Boolean,closeIcon:{type:se,default:"$delete"},closeLabel:{type:String,default:"$vuetify.close"},draggable:Boolean,filter:Boolean,filterIcon:{type:String,default:"$complete"},label:Boolean,link:Boolean,pill:Boolean,prependAvatar:String,prependIcon:se,ripple:{type:Boolean,default:!0},text:String,modelValue:{type:Boolean,default:!0},...ht(),...Ge(),...He(),...Va(),...Ie(),...fn(),...Yt(),...le({tag:"span"}),...ve(),...Pt({variant:"tonal"})},emits:{"click:close":e=>!0,"update:active":e=>!0,"update:modelValue":e=>!0},setup(e,t){let{attrs:a,emit:n,slots:i}=t;const{borderClasses:o}=xt(e),{colorClasses:r,colorStyles:s,variantClasses:l}=dn(e),{densityClasses:c}=Xe(e),{elevationClasses:u}=qe(e),{roundedClasses:h}=Re(e),{sizeClasses:m}=ln(e),{themeClasses:f}=ke(e),p=he(e,"modelValue"),b=gn(e,Md,!1),w=ai(e,a);function v(S){p.value=!1,n("click:close",S)}return()=>{var S,k;const P=w.isLink.value?"a":e.tag,j=!!(i.append||e.appendIcon||e.appendAvatar),x=!!(i.close||e.closable),y=!!(i.filter||e.filter)&&b,_=!!(i.prepend||e.prependIcon||e.prependAvatar),M=!b||b.isSelected.value,I=!e.disabled&&(!!b||w.isClickable.value||e.link),J=e.link?e.link:b==null?void 0:b.toggle;return p.value&&Me(d(P,{class:["v-chip",{"v-chip--disabled":e.disabled,"v-chip--label":e.label,"v-chip--link":I,"v-chip--filter":y,"v-chip--pill":e.pill},f.value,o.value,M?r.value:void 0,c.value,u.value,h.value,m.value,l.value,b==null?void 0:b.selectedClass.value],style:[M?s.value:void 0],disabled:e.disabled||void 0,draggable:e.draggable,href:w.href.value,onClick:I&&J},{default:()=>[un(I,"v-chip"),y&&d(Le,{key:"filter",defaults:{VIcon:{icon:e.filterIcon}}},{default:()=>[d(cs,null,{default:()=>[Me(d("div",{class:"v-chip__filter"},[i.filter?i.filter():d(Te,null,null)]),[[Et,b.isSelected.value]])]})]}),_&&d(Le,{key:"prepend",defaults:{VAvatar:{image:e.prependAvatar},VIcon:{icon:e.prependIcon}}},{default:()=>[i.prepend?d("div",{class:"v-chip__prepend"},[i.prepend()]):e.prependAvatar?d(Ja,{start:!0},null):e.prependIcon?d(Te,{start:!0},null):void 0]}),(S=(k=i.default)==null?void 0:k.call(i,{isSelected:b==null?void 0:b.isSelected.value,selectedClass:b==null?void 0:b.selectedClass.value,select:b==null?void 0:b.select,toggle:b==null?void 0:b.toggle,value:b==null?void 0:b.value.value,disabled:e.disabled}))!=null?S:e.text,j&&d(Le,{key:"append",defaults:{VAvatar:{image:e.appendAvatar},VIcon:{icon:e.appendIcon}}},{default:()=>[i.append?d("div",{class:"v-chip__append"},[i.append()]):e.appendAvatar?d(Ja,{end:!0},null):e.appendIcon?d(Te,{end:!0},null):void 0]}),x&&d(Le,{key:"close",defaults:{VIcon:{icon:e.closeIcon,size:"x-small"}}},{default:()=>[d("div",{class:"v-chip__close",onClick:v},[i.close?i.close():d(Te,null,null)])]})]}),[[ct("ripple"),I&&e.ripple,null]])}}});const Jd=H({name:"VDivider",props:{color:String,inset:Boolean,length:[Number,String],thickness:[Number,String],vertical:Boolean,...ve()},setup(e,t){let{attrs:a}=t;const{themeClasses:n}=ke(e),{backgroundColorClasses:i,backgroundColorStyles:o}=Be(z(e,"color")),r=g(()=>{const s={};return e.length&&(s[e.vertical?"maxHeight":"maxWidth"]=Q(e.length)),e.thickness&&(s[e.vertical?"borderRightWidth":"borderTopWidth"]=Q(e.thickness)),s});return O(()=>d("hr",{class:[{"v-divider":!0,"v-divider--inset":e.inset,"v-divider--vertical":e.vertical},n.value,i.value],style:[r.value,o.value],"aria-orientation":!a.role||a.role==="separator"?e.vertical?"vertical":"horizontal":void 0,role:`${a.role||"separator"}`},null)),{}}}),gr=Symbol.for("vuetify:list");function Ld(){const e=we(gr,{hasPrepend:D(!1),updateHasPrepend:()=>null}),t={hasPrepend:D(!1),updateHasPrepend:a=>{a&&(t.hasPrepend.value=a)}};return Oe(gr,t),e}function Dd(){return we(gr,null)}const Mv={open:e=>{let{id:t,value:a,opened:n,parents:i}=e;if(a){const o=new Set;o.add(t);let r=i.get(t);for(;r!=null;)o.add(r),r=i.get(r);return o}else return n.delete(t),n},select:()=>null},Ed={open:e=>{let{id:t,value:a,opened:n,parents:i}=e;if(a){let o=i.get(t);for(n.add(t);o!=null&&o!==t;)n.add(o),o=i.get(o);return n}else n.delete(t);return n},select:()=>null},Jv={open:Ed.open,select:e=>{let{id:t,value:a,opened:n,parents:i}=e;if(!a)return n;const o=[];let r=i.get(t);for(;r!=null;)o.push(r),r=i.get(r);return new Set(o)}},gs=e=>{const t={select:a=>{let{id:n,value:i,selected:o}=a;if(e&&!i){const r=Array.from(o.entries()).reduce((s,l)=>{let[c,u]=l;return u==="on"?[...s,c]:s},[]);if(r.length===1&&r[0]===n)return o}return o.set(n,i?"on":"off"),o},in:(a,n,i)=>{let o=new Map;for(const r of a||[])o=t.select({id:r,value:!0,selected:new Map(o),children:n,parents:i});return o},out:a=>{const n=[];for(const[i,o]of a.entries())o==="on"&&n.push(i);return n}};return t},Bd=e=>{const t=gs(e);return{select:n=>{let{selected:i,id:o,...r}=n;const s=i.has(o)?new Map([[o,i.get(o)]]):new Map;return t.select({...r,id:o,selected:s})},in:(n,i,o)=>{let r=new Map;return n!=null&&n.length&&(r=t.in(n.slice(0,1),i,o)),r},out:(n,i,o)=>t.out(n,i,o)}},Lv=e=>{const t=gs(e);return{select:n=>{let{id:i,selected:o,children:r,...s}=n;return r.has(i)?o:t.select({id:i,selected:o,children:r,...s})},in:t.in,out:t.out}},Dv=e=>{const t=Bd(e);return{select:n=>{let{id:i,selected:o,children:r,...s}=n;return r.has(i)?o:t.select({id:i,selected:o,children:r,...s})},in:t.in,out:t.out}},Ev=e=>{const t={select:a=>{let{id:n,value:i,selected:o,children:r,parents:s}=a;const l=new Map(o),c=[n];for(;c.length;){const h=c.shift();o.set(h,i?"on":"off"),r.has(h)&&c.push(...r.get(h))}let u=s.get(n);for(;u;){const h=r.get(u),m=h.every(p=>o.get(p)==="on"),f=h.every(p=>!o.has(p)||o.get(p)==="off");o.set(u,m?"on":f?"off":"indeterminate"),u=s.get(u)}return e&&!i&&Array.from(o.entries()).reduce((m,f)=>{let[p,b]=f;return b==="on"?[...m,p]:m},[]).length===0?l:o},in:(a,n,i)=>{let o=new Map;for(const r of a||[])o=t.select({id:r,value:!0,selected:new Map(o),children:n,parents:i});return o},out:(a,n)=>{const i=[];for(const[o,r]of a.entries())r==="on"&&!n.has(o)&&i.push(o);return i}};return t},Kn=Symbol.for("vuetify:nested"),Fd={id:D(),root:{register:()=>null,unregister:()=>null,parents:D(new Map),children:D(new Map),open:()=>null,select:()=>null,opened:D(new Set),selected:D(new Map),selectedValues:D([])}},Bv=me({selectStrategy:[String,Function],openStrategy:[String,Function],opened:Array,selected:Array,mandatory:Boolean},"nested"),Fv=e=>{let t=!1;const a=D(new Map),n=D(new Map),i=he(e,"opened",e.opened,h=>new Set(h),h=>[...h.values()]),o=g(()=>{if(typeof e.selectStrategy=="object")return e.selectStrategy;switch(e.selectStrategy){case"single-leaf":return Dv(e.mandatory);case"leaf":return Lv(e.mandatory);case"independent":return gs(e.mandatory);case"single-independent":return Bd(e.mandatory);case"classic":default:return Ev(e.mandatory)}}),r=g(()=>{if(typeof e.openStrategy=="function")return e.openStrategy;switch(e.openStrategy){case"list":return Jv;case"single":return Mv;case"multiple":default:return Ed}}),s=he(e,"selected",e.selected,h=>o.value.in(h,a.value,n.value),h=>o.value.out(h,a.value,n.value));lt(()=>{t=!0});function l(h){const m=[];let f=h;for(;f!=null;)m.unshift(f),f=n.value.get(f);return m}const c=Ke("nested"),u={id:D(),root:{opened:i,selected:s,selectedValues:g(()=>{const h=[];for(const[m,f]of s.value.entries())f==="on"&&h.push(m);return h}),register:(h,m,f)=>{m&&h!==m&&n.value.set(h,m),f&&a.value.set(h,[]),m!=null&&a.value.set(m,[...a.value.get(m)||[],h])},unregister:h=>{if(t)return;a.value.delete(h);const m=n.value.get(h);if(m){var f;const p=(f=a.value.get(m))!=null?f:[];a.value.set(m,p.filter(b=>b!==h))}n.value.delete(h),i.value.delete(h)},open:(h,m,f)=>{c.emit("click:open",{id:h,value:m,path:l(h),event:f});const p=r.value.open({id:h,value:m,opened:new Set(i.value),children:a.value,parents:n.value,event:f});p&&(i.value=p)},select:(h,m,f)=>{c.emit("click:select",{id:h,value:m,path:l(h),event:f});const p=o.value.select({id:h,value:m,selected:new Map(s.value),children:a.value,parents:n.value,event:f});p&&(s.value=p);const b=r.value.select({id:h,value:m,selected:new Map(s.value),opened:new Set(i.value),children:a.value,parents:n.value,event:f});b&&(i.value=b)},children:a,parents:n}};return Oe(Kn,u),u.root},Rd=(e,t)=>{const a=we(Kn,Fd),n=g(()=>{var o;return(o=e.value)!=null?o:Ye().toString()}),i={...a,id:n,open:(o,r)=>a.root.open(n.value,o,r),isOpen:g(()=>a.root.opened.value.has(n.value)),parent:g(()=>a.root.parents.value.get(n.value)),select:(o,r)=>a.root.select(n.value,o,r),isSelected:g(()=>a.root.selected.value.get(n.value)==="on"),isIndeterminate:g(()=>a.root.selected.value.get(n.value)==="indeterminate"),isLeaf:g(()=>!a.root.children.value.get(n.value)),isGroupActivator:a.isGroupActivator};return!a.isGroupActivator&&a.root.register(n.value,a.id.value,t),lt(()=>{!a.isGroupActivator&&a.root.unregister(n.value)}),t&&Oe(Kn,i),i},Rv=()=>{const e=we(Kn,Fd);Oe(Kn,{...e,isGroupActivator:!0})};function bo(){const e=D(!1);return yt(()=>{window.requestAnimationFrame(()=>{e.value=!0})}),{ssrBootStyles:g(()=>e.value?void 0:{transition:"none !important"}),isBooted:Zn(e)}}const Vv=H({name:"VListGroupActivator",setup(e,t){let{slots:a}=t;return Rv(),()=>{var n;return(n=a.default)==null?void 0:n.call(a)}}}),Vd=Fe()({name:"VListGroup",props:{activeColor:String,color:String,collapseIcon:{type:se,default:"$collapse"},expandIcon:{type:se,default:"$expand"},value:null,...le()},setup(e,t){let{slots:a}=t;const{isOpen:n,open:i}=Rd(z(e,"value"),!0),o=Dd(),{isBooted:r}=bo(),s=c=>{i(!n.value,c)},l=g(()=>{var c;return{onClick:s,active:n.value,appendIcon:n.value?e.collapseIcon:e.expandIcon,class:"v-list-group__header",color:n.value?(c=e.activeColor)!=null?c:e.color:void 0}});return O(()=>{var c;return d(e.tag,{class:["v-list-group",{"v-list-group--prepend":o==null?void 0:o.hasPrepend.value}]},{default:()=>[a.activator&&d(Le,{defaults:{VListItemIcon:{color:l.value.color}}},{default:()=>[d(Vv,null,{default:()=>[a.activator({props:l.value,isOpen:n})]})]}),d(Tt,{transition:r.value&&{component:mo}},{default:()=>[Me(d("div",{class:"v-list-group__items"},[(c=a.default)==null?void 0:c.call(a)]),[[Et,n.value]])]})]})}),{}}});const vr=H({name:"VListItemAvatar",props:Gu(),setup(e,t){let{slots:a}=t;return O(()=>d(Ja,oe({class:["v-list-item-avatar",{"v-list-item-avatar--start":e.start,"v-list-item-avatar--end":e.end}]},e),a)),{}}}),zd=ut("v-list-item-header"),br=H({name:"VListItemIcon",props:Vu(),setup(e,t){let{slots:a}=t;return O(()=>d(Te,oe({class:["v-list-item-icon",{"v-list-item-icon--start":e.start,"v-list-item-icon--end":e.end}]},e),a)),{}}}),Hd=ut("v-list-item-subtitle"),Od=ut("v-list-item-title"),Nt=Fe()({name:"VListItem",directives:{Ripple:fa},props:{active:Boolean,activeColor:String,activeClass:String,appendAvatar:String,appendIcon:se,disabled:Boolean,lines:String,nav:Boolean,prependAvatar:String,prependIcon:se,subtitle:[String,Number,Boolean],title:[String,Number,Boolean],value:null,link:Boolean,...ht(),...Ge(),...wt(),...He(),...Ie(),...fn(),...le(),...ve(),...Pt({variant:"text"})},setup(e,t){var a;let{attrs:n,slots:i}=t;const o=ai(e,n),r=g(()=>{var T;return(T=e.value)!=null?T:o.href.value}),{select:s,isSelected:l,isIndeterminate:c,isGroupActivator:u,root:h,parent:m}=Rd(r,!1),f=Dd(),p=g(()=>{var T;return e.active||((T=o.isExactActive)==null?void 0:T.value)||l.value}),b=g(()=>e.rounded||e.nav),w=g(()=>{var T;return{color:p.value&&(T=e.activeColor)!=null?T:e.color,variant:e.variant}});(a=o.isExactActive)!=null&&a.value&&m.value!=null&&h.open(m.value,!0),re(()=>{var T;return(T=o.isExactActive)==null?void 0:T.value},T=>{T&&m.value!=null&&h.open(m.value,!0)});const{themeClasses:v}=ke(e),{borderClasses:S}=xt(e),{colorClasses:k,colorStyles:P,variantClasses:j}=dn(w),{densityClasses:x}=Xe(e),{dimensionStyles:y}=kt(e),{elevationClasses:_}=qe(e),{roundedClasses:M}=Re(b),I=g(()=>e.lines?`v-list-item--${e.lines}-line`:void 0),J=g(()=>({isActive:p.value,select:s,isSelected:l.value,isIndeterminate:c.value}));return O(()=>{var T,L,B;const F=o.isLink.value?"a":e.tag,$=!f||l.value||p.value,N=i.title||e.title,K=i.subtitle||e.subtitle,de=!!(N||K),Z=!!(i.append||e.appendAvatar||e.appendIcon),te=!!(i.prepend||e.prependAvatar||e.prependIcon),fe=!e.disabled&&(e.link||o.isClickable.value||e.value!=null&&!!f);return f==null||f.updateHasPrepend(te),Me(d(F,{class:["v-list-item",{"v-list-item--active":p.value,"v-list-item--disabled":e.disabled,"v-list-item--link":fe,"v-list-item--nav":e.nav,"v-list-item--prepend":!te&&(f==null?void 0:f.hasPrepend.value),[`${e.activeClass}`]:p.value},v.value,S.value,$?k.value:void 0,x.value,_.value,I.value,M.value,j.value],style:[$?P.value:void 0,y.value],href:o.href.value,tabindex:fe?0:void 0,onClick:fe&&(Je=>{var Y;u||((Y=o.navigate)==null||Y.call(o,Je),e.value!=null&&s(!l.value,Je))})},{default:()=>[un(fe||p.value,"v-list-item"),te&&d(pe,null,[e.prependAvatar&&d(vr,{image:e.prependAvatar,start:!0},null),e.prependIcon&&d(br,{icon:e.prependIcon,start:!0},null),(T=i.prepend)==null?void 0:T.call(i,J.value)]),de&&d(zd,{key:"header"},{default:()=>[N&&d(Od,{key:"title"},{default:()=>[i.title?i.title({title:e.title}):e.title]}),K&&d(Hd,null,{default:()=>[i.subtitle?i.subtitle({subtitle:e.subtitle}):e.subtitle]})]}),(L=i.default)==null?void 0:L.call(i,J.value),Z&&d(pe,null,[(B=i.append)==null?void 0:B.call(i,J.value),e.appendAvatar&&d(vr,{image:e.appendAvatar,end:!0},null),e.appendIcon&&d(br,{icon:e.appendIcon,end:!0},null)])]}),[[ct("ripple"),fe]])}),{}}}),Gd=H({name:"VListSubheader",props:{color:String,inset:Boolean,sticky:Boolean,title:String,...le()},setup(e,t){let{slots:a}=t;const{textColorClasses:n,textColorStyles:i}=at(z(e,"color"));return O(()=>{var o,r;const s=!!(a.default||e.title);return d(e.tag,{class:["v-list-subheader",{"v-list-subheader--inset":e.inset,"v-list-subheader--sticky":e.sticky},n.value],style:{textColorStyles:i}},{default:()=>[s&&d("div",{class:"v-list-subheader__text"},[(o=(r=a.default)==null?void 0:r.call(a))!=null?o:e.title])]})}),{}}}),Nd=Fe()({name:"VListChildren",props:{items:Array},setup(e,t){let{slots:a}=t;return Ld(),()=>{var n,i,o;return(n=(i=a.default)==null?void 0:i.call(a))!=null?n:(o=e.items)==null?void 0:o.map(r=>{let{children:s,props:l,type:c,raw:u}=r;if(c==="divider")return d(Jd,l,null);if(c==="subheader")return d(Gd,l,a);const h={subtitle:a.subtitle?m=>{var f;return(f=a.subtitle)==null?void 0:f.call(a,{...m,item:u})}:void 0,prepend:a.prepend?m=>{var f;return(f=a.prepend)==null?void 0:f.call(a,{...m,item:u})}:void 0,append:a.append?m=>{var f;return(f=a.append)==null?void 0:f.call(a,{...m,item:u})}:void 0,default:a.default?m=>{var f;return(f=a.default)==null?void 0:f.call(a,{...m,item:u})}:void 0,title:a.title?m=>{var f;return(f=a.title)==null?void 0:f.call(a,{...m,item:u})}:void 0};return s?d(Vd,{value:l==null?void 0:l.value},{activator:m=>{let{props:f}=m;return a.header?a.header({...l,...f}):d(Nt,oe(l,f),h)},default:()=>d(Nd,{items:s},a)}):a.item?a.item(l):d(Nt,l,h)})}}}),$d=me({items:{type:Array,default:()=>[]},itemTitle:{type:[String,Array,Function],default:"title"},itemValue:{type:[String,Array,Function],default:"value"},itemChildren:{type:[Boolean,String,Array,Function],default:"children"},itemProps:{type:[Boolean,String,Array,Function],default:"props"},returnObject:Boolean},"item");function Ka(e,t){const a=Jt(t,e.itemTitle,t),n=Jt(t,e.itemValue,a),i=Jt(t,e.itemChildren),o=e.itemProps===!0?Bt(t,["children"])[1]:Jt(t,e.itemProps),r={title:a,value:n,...o};return{title:r.title,value:r.value,props:r,children:Array.isArray(i)?Ud(e,i):void 0,raw:t}}function Ud(e,t){const a=[];for(const n of t)a.push(Ka(e,n));return a}function vs(e){const t=g(()=>Ud(e,e.items));function a(i){return i.map(o=>Ka(e,o))}function n(i){return e.returnObject?i.map(o=>{let{raw:r}=o;return r}):i.map(o=>{let{props:r}=o;return r.value})}return{items:t,transformIn:a,transformOut:n}}function zv(e,t){const a=Jt(t,e.itemType,"item"),n=typeof t=="string"?t:Jt(t,e.itemTitle),i=Jt(t,e.itemValue,void 0),o=Jt(t,e.itemChildren),r=e.itemProps===!0?Bt(t,["children"])[1]:Jt(t,e.itemProps),s={title:n,value:i,...r};return{type:a,title:s.title,value:s.value,props:s,children:a==="item"&&o?Wd(e,o):void 0,raw:t}}function Wd(e,t){const a=[];for(const n of t)a.push(zv(e,n));return a}function Hv(e){return{items:g(()=>Wd(e,e.items))}}const yo=Fe()({name:"VList",props:{activeColor:String,activeClass:String,bgColor:String,disabled:Boolean,lines:{type:[Boolean,String],default:"one"},nav:Boolean,...Bv({selectStrategy:"single-leaf",openStrategy:"list"}),...ht(),...Ge(),...wt(),...He(),itemType:{type:String,default:"type"},...$d(),...Ie(),...le(),...ve(),...Pt({variant:"text"})},emits:{"update:selected":e=>!0,"update:opened":e=>!0,"click:open":e=>!0,"click:select":e=>!0},setup(e,t){let{slots:a}=t;const{items:n}=Hv(e),{themeClasses:i}=ke(e),{backgroundColorClasses:o,backgroundColorStyles:r}=Be(z(e,"bgColor")),{borderClasses:s}=xt(e),{densityClasses:l}=Xe(e),{dimensionStyles:c}=kt(e),{elevationClasses:u}=qe(e),{roundedClasses:h}=Re(e),{open:m,select:f}=Fv(e),p=g(()=>e.lines?`v-list--${e.lines}-line`:void 0),b=z(e,"activeColor"),w=z(e,"color");return Ld(),Ue({VListGroup:{activeColor:b,color:w},VListItem:{activeClass:z(e,"activeClass"),activeColor:b,color:w,density:z(e,"density"),disabled:z(e,"disabled"),lines:z(e,"lines"),nav:z(e,"nav"),variant:z(e,"variant")}}),O(()=>d(e.tag,{class:["v-list",{"v-list--disabled":e.disabled,"v-list--nav":e.nav},i.value,o.value,s.value,l.value,u.value,p.value,h.value],style:[r.value,c.value]},{default:()=>[d(Nd,{items:n.value},a)]})),{open:m,select:f}}}),Ov=ut("v-list-img"),Gv=H({name:"VListItemAction",props:{start:Boolean,end:Boolean,...le()},setup(e,t){let{slots:a}=t;return O(()=>d(e.tag,{class:["v-list-item-action",{"v-list-item-action--start":e.start,"v-list-item-action--end":e.end}]},a)),{}}}),Nv=H({name:"VListItemMedia",props:{start:Boolean,end:Boolean,...le()},setup(e,t){let{slots:a}=t;return O(()=>d(e.tag,{class:["v-list-item-media",{"v-list-item-media--start":e.start,"v-list-item-media--end":e.end}]},a)),{}}});const qd=me({closeDelay:[Number,String],openDelay:[Number,String]},"delay");function Kd(e,t){const a={},n=i=>()=>{if(!Pe)return Promise.resolve(!0);const o=i==="openDelay";return a.closeDelay&&window.clearTimeout(a.closeDelay),delete a.closeDelay,a.openDelay&&window.clearTimeout(a.openDelay),delete a.openDelay,new Promise(r=>{var s;const l=parseInt((s=e[i])!=null?s:0,10);a[i]=window.setTimeout(()=>{t==null||t(o),r(o)},l)})};return{runCloseDelay:n("closeDelay"),runOpenDelay:n("openDelay")}}const yr=Symbol.for("vuetify:v-menu"),$v=me({activator:[String,Object],activatorProps:{type:Object,default:()=>({})},openOnClick:{type:Boolean,default:void 0},openOnHover:Boolean,openOnFocus:{type:Boolean,default:void 0},closeOnContentClick:Boolean,...qd()});function Uv(e,t){let{isActive:a,isTop:n}=t;const i=D();let o=!1,r=!1;const s=g(()=>e.openOnFocus||e.openOnFocus==null&&e.openOnHover),l=g(()=>e.openOnClick||e.openOnClick==null&&!e.openOnHover&&!s.value),{runOpenDelay:c,runCloseDelay:u}=Kd(e,v=>{v===(e.openOnHover&&o||s.value&&r)&&!(e.openOnHover&&a.value&&!n.value)&&(a.value=v)}),h={click:v=>{v.stopPropagation(),i.value=v.currentTarget||v.target,a.value=!a.value},mouseenter:v=>{o=!0,i.value=v.currentTarget||v.target,c()},mouseleave:v=>{o=!1,u()},focus:v=>{or&&!v.target.matches(":focus-visible")||(r=!0,v.stopPropagation(),i.value=v.currentTarget||v.target,c())},blur:v=>{r=!1,v.stopPropagation(),u()}},m=g(()=>{const v={};return l.value&&(v.click=h.click),e.openOnHover&&(v.mouseenter=h.mouseenter,v.mouseleave=h.mouseleave),s.value&&(v.focus=h.focus,v.blur=h.blur),v}),f=g(()=>{const v={};if(e.openOnHover&&(v.mouseenter=()=>{o=!0,c()},v.mouseleave=()=>{o=!1,u()}),e.closeOnContentClick){const S=we(yr,null);v.click=()=>{a.value=!1,S==null||S.closeParents()}}return v});re(n,v=>{v&&e.openOnHover&&!o&&(a.value=!1)});const p=D();$t(()=>{!p.value||Ee(()=>{const v=p.value;i.value=fp(v)?v.$el:v})});const b=Ke("useActivator");let w;return re(()=>!!e.activator,v=>{v&&Pe?(w=Qn(),w.run(()=>{Wv(e,b,{activatorEl:i,activatorEvents:m})})):w&&w.stop()},{flush:"post",immediate:!0}),{activatorEl:i,activatorRef:p,activatorEvents:m,contentEvents:f}}function Wv(e,t,a){let{activatorEl:n,activatorEvents:i}=a;re(()=>e.activator,(l,c)=>{if(c&&l!==c){const u=s(c);u&&r(u)}l&&Ee(()=>o())},{immediate:!0}),re(()=>e.activatorProps,()=>{o()}),La(()=>{r()});function o(){let l=arguments.length>0&&arguments[0]!==void 0?arguments[0]:s(),c=arguments.length>1&&arguments[1]!==void 0?arguments[1]:e.activatorProps;!l||(Object.entries(i.value).forEach(u=>{let[h,m]=u;l.addEventListener(h,m)}),Object.keys(c).forEach(u=>{c[u]==null?l.removeAttribute(u):l.setAttribute(u,c[u])}))}function r(){let l=arguments.length>0&&arguments[0]!==void 0?arguments[0]:s(),c=arguments.length>1&&arguments[1]!==void 0?arguments[1]:e.activatorProps;!l||(Object.entries(i.value).forEach(u=>{let[h,m]=u;l.removeEventListener(h,m)}),Object.keys(c).forEach(u=>{l.removeAttribute(u)}))}function s(){var l;let c=arguments.length>0&&arguments[0]!==void 0?arguments[0]:e.activator,u;if(c)if(c==="parent"){var h,m;let f=t==null||(h=t.proxy)==null||(m=h.$el)==null?void 0:m.parentNode;for(;f.hasAttribute("data-no-activator");)f=f.parentNode;u=f}else typeof c=="string"?u=document.querySelector(c):"$el"in c?u=c.$el:u=c;return n.value=((l=u)==null?void 0:l.nodeType)===Node.ELEMENT_NODE?u:null,n.value}}const wo=me({eager:Boolean},"lazy");function bs(e,t){const a=D(!1),n=g(()=>a.value||e.eager||t.value);re(t,()=>a.value=!0);function i(){e.eager||(a.value=!1)}return{isBooted:a,hasContent:n,onAfterLeave:i}}function Eo(e,t){return{x:e.x+t.x,y:e.y+t.y}}function qv(e,t){return{x:e.x-t.x,y:e.y-t.y}}function Ol(e,t){if(e.side==="top"||e.side==="bottom"){const{side:a,align:n}=e,i=n==="left"?0:n==="center"?t.width/2:n==="right"?t.width:n,o=a==="top"?0:a==="bottom"?t.height:a;return Eo({x:i,y:o},t)}else if(e.side==="left"||e.side==="right"){const{side:a,align:n}=e,i=a==="left"?0:a==="right"?t.width:a,o=n==="top"?0:n==="center"?t.height/2:n==="bottom"?t.height:n;return Eo({x:i,y:o},t)}return Eo({x:t.width/2,y:t.height/2},t)}const Yd={static:Xv,connected:Zv},Kv=me({locationStrategy:{type:[String,Function],default:"static",validator:e=>typeof e=="function"||e in Yd},location:{type:String,default:"bottom"},origin:{type:String,default:"auto"},offset:[Number,String,Array]});function Yv(e,t){const a=D({}),n=D();let i;$t(async()=>{var r;(r=i)==null||r.stop(),n.value=void 0,Pe&&t.isActive.value&&e.locationStrategy&&(i=Qn(),await Ee(),i.run(()=>{if(typeof e.locationStrategy=="function"){var s;n.value=(s=e.locationStrategy(t,e,a))==null?void 0:s.updateLocation}else{var l;n.value=(l=Yd[e.locationStrategy](t,e,a))==null?void 0:l.updateLocation}}))}),Pe&&window.addEventListener("resize",o,{passive:!0}),La(()=>{var r;Pe&&window.removeEventListener("resize",o),n.value=void 0,(r=i)==null||r.stop()});function o(r){var s;(s=n.value)==null||s.call(n,r)}return{contentStyles:a,updateLocation:n}}function Xv(){}function Qv(e){const t=Wr(e);return t.x-=parseFloat(e.style.left||0),t.y-=parseFloat(e.style.top||0),t}function Zv(e,t,a){const n=Op(e.activatorEl.value);n&&Object.assign(a.value,{position:"fixed"});const{preferredAnchor:i,preferredOrigin:o}=bp(()=>{const f=ar(t.location,e.isRtl.value),p=t.origin==="overlap"?f:t.origin==="auto"?Io(f):ar(t.origin,e.isRtl.value);return f.side===p.side&&f.align===Ao(p).align?{preferredAnchor:gl(f),preferredOrigin:gl(p)}:{preferredAnchor:f,preferredOrigin:p}}),[r,s,l,c]=["minWidth","minHeight","maxWidth","maxHeight"].map(f=>g(()=>{const p=parseFloat(t[f]);return isNaN(p)?1/0:p})),u=g(()=>{if(Array.isArray(t.offset))return t.offset;if(typeof t.offset=="string"){const f=t.offset.split(" ").map(parseFloat);return f.length<2&&f.push(0),f}return typeof t.offset=="number"?[t.offset,0]:[0,0]});let h=!1;if(Pe){const f=new ResizeObserver(()=>{h&&m()});f.observe(e.activatorEl.value),f.observe(e.contentEl.value),La(()=>{f.disconnect()})}function m(){h=!1,requestAnimationFrame(()=>{requestAnimationFrame(()=>h=!0)});const f=e.activatorEl.value.getBoundingClientRect(),p=Qv(e.contentEl.value),b=Fi(e.contentEl.value),w=12;b.length||(b.push(document.documentElement),e.contentEl.value.style.top&&e.contentEl.value.style.left||(p.x+=parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x")||0),p.y+=parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y")||0)));const v=b.reduce((I,J)=>{const T=J.getBoundingClientRect(),L=new Za({x:J===document.documentElement?0:T.x,y:J===document.documentElement?0:T.y,width:J.clientWidth,height:J.clientHeight});return I?new Za({x:Math.max(I.left,L.left),y:Math.max(I.top,L.top),width:Math.min(I.right,L.right)-Math.max(I.left,L.left),height:Math.min(I.bottom,L.bottom)-Math.max(I.top,L.top)}):L},void 0);v.x+=w,v.y+=w,v.width-=w*2,v.height-=w*2;let S={anchor:i.value,origin:o.value};function k(I){const J=new Za(p),T=Ol(I.anchor,f),L=Ol(I.origin,J);let{x:B,y:F}=qv(T,L);switch(I.anchor.side){case"top":F-=u.value[0];break;case"bottom":F+=u.value[0];break;case"left":B-=u.value[0];break;case"right":B+=u.value[0];break}switch(I.anchor.align){case"top":F-=u.value[1];break;case"bottom":F+=u.value[1];break;case"left":B-=u.value[1];break;case"right":B+=u.value[1];break}return J.x+=B,J.y+=F,J.width=Math.min(J.width,l.value),J.height=Math.min(J.height,c.value),{overflows:bl(J,v),x:B,y:F}}let P=0,j=0;const x={x:0,y:0},y={x:!1,y:!1};let _=-1;for(;;){if(_++>10){nr("Infinite loop detected in connectedLocationStrategy");break}const{x:I,y:J,overflows:T}=k(S);P+=I,j+=J,p.x+=I,p.y+=J;{const L=vl(S.anchor),B=T.x.before||T.x.after,F=T.y.before||T.y.after;let $=!1;if(["x","y"].forEach(N=>{if(N==="x"&&B&&!y.x||N==="y"&&F&&!y.y){const K={anchor:{...S.anchor},origin:{...S.origin}},de=N==="x"?L==="y"?Ao:Io:L==="y"?Io:Ao;K.anchor=de(K.anchor),K.origin=de(K.origin);const{overflows:Z}=k(K);(Z[N].before<=T[N].before&&Z[N].after<=T[N].after||Z[N].before+Z[N].after<(T[N].before+T[N].after)/2)&&(S=K,$=y[N]=!0)}}),$)continue}T.x.before&&(P+=T.x.before,p.x+=T.x.before),T.x.after&&(P-=T.x.after,p.x-=T.x.after),T.y.before&&(j+=T.y.before,p.y+=T.y.before),T.y.after&&(j-=T.y.after,p.y-=T.y.after);{const L=bl(p,v);x.x=v.width-L.x.before-L.x.after,x.y=v.height-L.y.before-L.y.after,P+=L.x.before,p.x+=L.x.before,j+=L.y.before,p.y+=L.y.before}break}const M=vl(S.anchor);Object.assign(a.value,{"--v-overlay-anchor-origin":`${S.anchor.side} ${S.anchor.align}`,transformOrigin:`${S.origin.side} ${S.origin.align}`,top:Q(Gl(j)),left:Q(Gl(P)),minWidth:Q(M==="y"?Math.min(r.value,f.width):r.value),maxWidth:Q(Nl(Lt(x.x,r.value===1/0?0:r.value,l.value))),maxHeight:Q(Nl(Lt(x.y,s.value===1/0?0:s.value,c.value)))})}return re(()=>[i.value,o.value,t.offset,t.minWidth,t.minHeight,t.maxWidth,t.maxHeight],()=>m(),{immediate:!n}),n&&Ee(()=>m()),requestAnimationFrame(()=>{a.value.maxHeight&&m()}),{updateLocation:m}}function Gl(e){return Math.round(e*devicePixelRatio)/devicePixelRatio}function Nl(e){return Math.ceil(e*devicePixelRatio)/devicePixelRatio}let wr=!0;const Ni=[];function eb(e){!wr||Ni.length?(Ni.push(e),kr()):(wr=!1,e(),kr())}let $l=-1;function kr(){cancelAnimationFrame($l),$l=requestAnimationFrame(()=>{const e=Ni.shift();e&&e(),Ni.length?kr():wr=!0})}const xr={none:null,close:nb,block:ib,reposition:ob},tb=me({scrollStrategy:{type:[String,Function],default:"block",validator:e=>typeof e=="function"||e in xr}});function ab(e,t){if(!Pe)return;let a;$t(async()=>{var n;(n=a)==null||n.stop(),t.isActive.value&&e.scrollStrategy&&(a=Qn(),await Ee(),a.run(()=>{if(typeof e.scrollStrategy=="function")e.scrollStrategy(t);else{var i;(i=xr[e.scrollStrategy])==null||i.call(xr,t)}}))})}function nb(e){var t;function a(n){e.isActive.value=!1}Xd((t=e.activatorEl.value)!=null?t:e.contentEl.value,a)}function ib(e){var t;const a=[...new Set([...Fi(e.activatorEl.value),...Fi(e.contentEl.value)])].filter(o=>!o.classList.contains("v-overlay-scroll-blocked")),n=window.innerWidth-document.documentElement.offsetWidth,i=(o=>Yr(o)&&o)(((t=e.root.value)==null?void 0:t.offsetParent)||document.documentElement);i&&e.root.value.classList.add("v-overlay--scroll-blocked"),a.forEach((o,r)=>{o.style.setProperty("--v-body-scroll-x",Q(-o.scrollLeft)),o.style.setProperty("--v-body-scroll-y",Q(-o.scrollTop)),o.style.setProperty("--v-scrollbar-offset",Q(n)),o.classList.add("v-overlay-scroll-blocked")}),La(()=>{a.forEach((o,r)=>{const s=parseFloat(o.style.getPropertyValue("--v-body-scroll-x")),l=parseFloat(o.style.getPropertyValue("--v-body-scroll-y"));o.style.removeProperty("--v-body-scroll-x"),o.style.removeProperty("--v-body-scroll-y"),o.style.removeProperty("--v-scrollbar-offset"),o.classList.remove("v-overlay-scroll-blocked"),o.scrollLeft=-s,o.scrollTop=-l}),i&&e.root.value.classList.remove("v-overlay--scroll-blocked")})}function ob(e){var t;let a=!1,n=-1;function i(o){eb(()=>{var r,s;const l=performance.now();(r=(s=e.updateLocation).value)==null||r.call(s,o),a=(performance.now()-l)/(1e3/60)>2})}Xd((t=e.activatorEl.value)!=null?t:e.contentEl.value,o=>{a?(cancelAnimationFrame(n),n=requestAnimationFrame(()=>{n=requestAnimationFrame(()=>{i(o)})})):i(o)})}function Xd(e,t){const a=[document,...Fi(e)];a.forEach(n=>{n.addEventListener("scroll",t,{passive:!0})}),La(()=>{a.forEach(n=>{n.removeEventListener("scroll",t)})})}function Qd(e,t){let a;re(e,n=>{if(n&&!a)a=Qn(),a.run(t);else{var i;(i=a)==null||i.stop(),a=void 0}},{immediate:!0})}const wa=tt([]);function rb(e,t){const a=Ke("useStack"),n=D(+t.value);Qd(e,()=>{var o;const r=(o=wa[wa.length-1])==null?void 0:o[1];n.value=r?r+10:+t.value,wa.push([a,n.value]),La(()=>{const s=wa.findIndex(l=>l[0]===a);wa.splice(s,1)})});const i=D(!0);return $t(()=>{var o;const r=ge((o=wa[wa.length-1])==null?void 0:o[0])===a;setTimeout(()=>i.value=r)}),{isTop:Zn(i),stackStyles:g(()=>({zIndex:n.value}))}}function Ln(e){return{teleportTarget:g(()=>{const a=e.value;if(a===!0||!Pe)return;const n=a===!1?document.body:typeof a=="string"?document.querySelector(a):a;if(n==null){ym(`Unable to locate target ${a}`);return}if(!Ln.cache.has(n)){const i=document.createElement("div");i.className="v-overlay-container",n.appendChild(i),Ln.cache.set(n,i)}return Ln.cache.get(n)})}}Ln.cache=new WeakMap;function sb(){return!0}function Zd(e,t,a){if(!e||eh(e,a)===!1)return!1;const n=ju(t);if(typeof ShadowRoot<"u"&&n instanceof ShadowRoot&&n.host===e.target)return!1;const i=(typeof a.value=="object"&&a.value.include||(()=>[]))();return i.push(t),!i.some(o=>o==null?void 0:o.contains(e.target))}function eh(e,t){return(typeof t.value=="object"&&t.value.closeConditional||sb)(e)}function lb(e,t,a){const n=typeof a.value=="function"?a.value:a.value.handler;t._clickOutside.lastMousedownWasOutside&&Zd(e,t,a)&&setTimeout(()=>{eh(e,a)&&n&&n(e)},0)}function Ul(e,t){const a=ju(e);t(document),typeof ShadowRoot<"u"&&a instanceof ShadowRoot&&t(a)}const th={mounted(e,t){const a=i=>lb(i,e,t),n=i=>{e._clickOutside.lastMousedownWasOutside=Zd(i,e,t)};Ul(e,i=>{i.addEventListener("click",a,!0),i.addEventListener("mousedown",n,!0)}),e._clickOutside||(e._clickOutside={lastMousedownWasOutside:!0}),e._clickOutside[t.instance.$.uid]={onClick:a,onMousedown:n}},unmounted(e,t){!e._clickOutside||(Ul(e,a=>{var n;if(!a||!((n=e._clickOutside)!=null&&n[t.instance.$.uid]))return;const{onClick:i,onMousedown:o}=e._clickOutside[t.instance.$.uid];a.removeEventListener("click",i,!0),a.removeEventListener("mousedown",o,!0)}),delete e._clickOutside[t.instance.$.uid])}};function cb(e){const{modelValue:t,color:a,...n}=e;return d(Dt,{name:"fade-transition",appear:!0},{default:()=>[e.modelValue&&d("div",oe({class:["v-overlay__scrim",e.color.backgroundColorClasses.value],style:e.color.backgroundColorStyles.value},n),null)]})}const si=Fe()({name:"VOverlay",directives:{ClickOutside:th},inheritAttrs:!1,props:{absolute:Boolean,attach:[Boolean,String,Object],closeOnBack:{type:Boolean,default:!0},contained:Boolean,contentClass:null,contentProps:null,disabled:Boolean,noClickAnimation:Boolean,modelValue:Boolean,persistent:Boolean,scrim:{type:[String,Boolean],default:!0},zIndex:{type:[Number,String],default:2e3},...$v(),...wt(),...wo(),...Kv(),...tb(),...ve(),...dt()},emits:{"click:outside":e=>!0,"update:modelValue":e=>!0,afterLeave:()=>!0},setup(e,t){let{slots:a,attrs:n,emit:i}=t;const o=he(e,"modelValue"),r=g({get:()=>o.value,set:F=>{F&&e.disabled||(o.value=F)}}),{teleportTarget:s}=Ln(g(()=>e.attach||e.contained)),{themeClasses:l}=ke(e),{rtlClasses:c,isRtl:u}=ma(),{hasContent:h,onAfterLeave:m}=bs(e,r),f=Be(g(()=>typeof e.scrim=="string"?e.scrim:null)),{isTop:p,stackStyles:b}=rb(r,z(e,"zIndex")),{activatorEl:w,activatorRef:v,activatorEvents:S,contentEvents:k}=Uv(e,{isActive:r,isTop:p}),{dimensionStyles:P}=kt(e);re(()=>e.disabled,F=>{F&&(r.value=!1)});const j=D(),x=D(),{contentStyles:y,updateLocation:_}=Yv(e,{isRtl:u,contentEl:x,activatorEl:w,isActive:r});ab(e,{root:j,contentEl:x,activatorEl:w,isActive:r,updateLocation:_});function M(F){i("click:outside",F),e.persistent?B():r.value=!1}function I(){return r.value&&p.value}Pe&&re(r,F=>{F?window.addEventListener("keydown",J):window.removeEventListener("keydown",J)},{immediate:!0});function J(F){F.key==="Escape"&&p.value&&(e.persistent?B():r.value=!1)}const T=ad();Qd(()=>e.closeOnBack,()=>{Dg(T,F=>{p.value&&r.value?(F(!1),e.persistent?B():r.value=!1):F()})});const L=D();re(()=>r.value&&(e.absolute||e.contained)&&s.value==null,F=>{if(F){const $=Iu(j.value);$&&$!==document.scrollingElement&&(L.value=$.scrollTop)}});function B(){var F;e.noClickAnimation||(F=x.value)==null||F.animate([{transformOrigin:"center"},{transform:"scale(1.03)"},{transformOrigin:"center"}],{duration:150,easing:Nn})}return O(()=>{var F,$;return d(pe,null,[(F=a.activator)==null?void 0:F.call(a,{isActive:r.value,props:oe({ref:v},Rs(S.value),e.activatorProps)}),Pe&&d(mf,{disabled:!s.value,to:s.value},{default:()=>[h.value&&d("div",oe({class:["v-overlay",{"v-overlay--absolute":e.absolute||e.contained,"v-overlay--active":r.value,"v-overlay--contained":e.contained},l.value,c.value],style:[b.value,{top:Q(L.value)}],ref:j},n),[d(cb,{color:f,modelValue:r.value&&!!e.scrim},null),d(Tt,{appear:!0,persisted:!0,transition:e.transition,target:w.value,onAfterLeave:()=>{m(),i("afterLeave")}},{default:()=>[Me(d("div",oe({ref:x,class:["v-overlay__content",e.contentClass],style:[P.value,y.value]},Rs(k.value),e.contentProps),[($=a.default)==null?void 0:$.call(a,{isActive:r})]),[[Et,r.value],[ct("click-outside"),{handler:M,closeConditional:I,include:()=>[w.value]}]])]})])]})])}),{activatorEl:w,animateClick:B,contentEl:x,isTop:p,updateLocation:_}}});function ko(){const t=Ke("useScopeId").vnode.scopeId;return{scopeId:t?{[t]:""}:void 0}}const xo=Fe()({name:"VMenu",inheritAttrs:!1,props:{modelValue:Boolean,id:String,...dt({transition:{component:ho}})},emits:{"update:modelValue":e=>!0},setup(e,t){let{attrs:a,slots:n}=t;const i=he(e,"modelValue"),{scopeId:o}=ko(),r=Ye(),s=g(()=>e.id||`v-menu-${r}`),l=D(),c=we(yr,null);let u=0;Oe(yr,{register(){++u},unregister(){--u},closeParents(){setTimeout(()=>{u||(i.value=!1,c==null||c.closeParents())},40)}}),re(i,m=>{m?c==null||c.register():c==null||c.unregister()});function h(){c==null||c.closeParents()}return O(()=>d(si,oe({ref:l,modelValue:i.value,"onUpdate:modelValue":m=>i.value=m,class:["v-menu"],transition:e.transition,absolute:!0,closeOnContentClick:!0,locationStrategy:"connected",scrollStrategy:"reposition",scrim:!1,openDelay:"300",closeDelay:"250",activatorProps:{"aria-haspopup":"menu","aria-expanded":String(i.value),"aria-owns":s.value},"onClick:outside":h},o,a),{default:n.default,activator:n.activator})),Qt({id:s},l)}}),ys=me({chips:Boolean,closableChips:Boolean,eager:Boolean,hideNoData:Boolean,hideSelected:Boolean,menu:Boolean,menuIcon:{type:se,default:"$dropdown"},menuProps:{type:Object},modelValue:{type:null,default:()=>[]},multiple:Boolean,noDataText:{type:String,default:"$vuetify.noDataText"},openOnClear:Boolean,...$d({itemChildren:!1})},"select"),ub=Fe()({name:"VSelect",props:{...ys(),...dt({transition:{component:ho}})},emits:{"update:modelValue":e=>!0,"update:menu":e=>!0},setup(e,t){let{slots:a}=t;const{t:n}=Kt(),i=D(),o=he(e,"menu"),{items:r,transformIn:s,transformOut:l}=vs(e),c=he(e,"modelValue",[],w=>s(vt(w)),w=>{var v;const S=l(w);return e.multiple?S:(v=S[0])!=null?v:null}),u=g(()=>c.value.map(w=>r.value.find(v=>v.value===w.value)||w)),h=g(()=>u.value.map(w=>w.props.value));function m(w){c.value=[],e.openOnClear&&(o.value=!0)}function f(){e.hideNoData&&!r.value.length||(o.value=!0)}function p(w){["Enter","ArrowDown"," "].includes(w.key)&&(o.value=!0),["Escape","Tab"].includes(w.key)&&(o.value=!1)}function b(w){if(e.multiple){const v=h.value.findIndex(S=>S===w.value);if(v===-1)c.value=[...c.value,w];else{const S=[...c.value];S.splice(v,1),c.value=S}}else c.value=[w],o.value=!1}return O(()=>{const w=!!(e.chips||a.chip);return d(ii,{ref:i,modelValue:c.value.map(v=>v.props.value).join(", "),"onUpdate:modelValue":v=>{v==null&&(c.value=[])},validationValue:e.modelValue,class:["v-select",{"v-select--active-menu":o.value,"v-select--chips":!!e.chips,[`v-select--${e.multiple?"multiple":"single"}`]:!0}],appendInnerIcon:e.menuIcon,readonly:!0,"onClick:clear":m,"onClick:input":f,"onClick:control":f,onBlur:()=>o.value=!1,onKeydown:p},{...a,default:()=>{var v,S;return d(pe,null,[d(xo,oe({modelValue:o.value,"onUpdate:modelValue":k=>o.value=k,activator:"parent",contentClass:"v-select__content",eager:e.eager,openOnClick:!1,closeOnContentClick:!1,transition:e.transition},e.menuProps),{default:()=>[d(yo,{selected:h.value,selectStrategy:e.multiple?"independent":"single-independent",onMousedown:k=>k.preventDefault()},{default:()=>[!r.value.length&&!e.hideNoData&&((v=(S=a["no-data"])==null?void 0:S.call(a))!=null?v:d(Nt,{title:n(e.noDataText)},null)),r.value.map((k,P)=>{var j,x;return(j=(x=a.item)==null?void 0:x.call(a,{item:k,index:P,props:oe(k.props,{onClick:()=>b(k)})}))!=null?j:d(Nt,oe({key:P},k.props,{onClick:()=>b(k)}),{prepend:y=>{let{isSelected:_}=y;return e.multiple?d(vn,{modelValue:_,ripple:!1},null):void 0}})})]})]}),u.value.map((k,P)=>{function j(y){y.stopPropagation(),y.preventDefault(),b(k)}const x={"onClick:close":j,modelValue:!0};return d("div",{key:P,class:"v-select__selection"},[w?d(Le,{defaults:{VChip:{closable:e.closableChips,size:"small",text:k.title}}},{default:()=>[a.chip?a.chip({item:k,index:P,props:x}):d(ri,x,null)]}):a.selection?a.selection({item:k,index:P}):d("span",{class:"v-select__selection-text"},[k.title,e.multiple&&P<u.value.length-1&&d("span",{class:"v-select__selection-comma"},[ei(",")])])])})])}})}),Qt({menu:o,select:b},i)}}),db=(e,t,a)=>e==null||t==null?-1:e.toString().toLocaleLowerCase().indexOf(t.toString().toLocaleLowerCase()),ah=me({customFilter:Function,customKeyFilter:Object,filterKeys:[Array,String],filterMode:{type:String,default:"intersection"},noFilter:Boolean},"filter");function hb(e,t,a){var n,i;const o=[],r=(n=a==null?void 0:a.default)!=null?n:db,s=a!=null&&a.filterKeys?vt(a.filterKeys):!1,l=Object.keys((i=a==null?void 0:a.customKeyFilter)!=null?i:{}).length;if(!(e!=null&&e.length))return o;e:for(let u=0;u<e.length;u++){const h=e[u],m={},f={};let p=-1;if(t&&!(a!=null&&a.noFilter)){if(typeof h=="object"){const v=s||Object.keys(h);for(const S of v){var c;const k=Jt(h,S,h),P=a==null||(c=a.customKeyFilter)==null?void 0:c[S];if(p=P?P(k,t,h):r(k,t,h),p!==-1&&p!==!1)P?m[S]=p:f[S]=p;else if((a==null?void 0:a.filterMode)==="every")continue e}}else p=r(h,t,h),p!==-1&&p!==!1&&(f.title=p);const b=Object.keys(f).length,w=Object.keys(m).length;if(!b&&!w||(a==null?void 0:a.filterMode)==="union"&&w!==l&&!b||(a==null?void 0:a.filterMode)==="intersection"&&(w!==l||!b))continue}o.push({index:u,matches:{...f,...m}})}return o}function nh(e,t,a){const n=g(()=>typeof(a==null?void 0:a.value)!="string"&&typeof(a==null?void 0:a.value)!="number"?"":String(a.value));return{filteredItems:g(()=>{const o=sa(t);return hb(o,n.value,{customKeyFilter:e.customKeyFilter,default:e.customFilter,filterKeys:e.filterKeys,filterMode:e.filterMode,noFilter:e.noFilter}).map(s=>{let{index:l,matches:c}=s;return{item:o[l],matches:c}})})}}function mb(e,t,a){if(Array.isArray(t))throw new Error("Multiple matches is not implemented");return typeof t=="number"&&~t?d(pe,null,[d("span",{class:"v-autocomplete__unmask"},[e.substr(0,t)]),d("span",{class:"v-autocomplete__mask"},[e.substr(t,a)]),d("span",{class:"v-autocomplete__unmask"},[e.substr(t+a)])]):e}const fb=Fe()({name:"VAutocomplete",props:{search:String,...ah({filterKeys:["title"]}),...ys(),...dt({transition:!1})},emits:{"click:clear":e=>!0,"update:search":e=>!0,"update:modelValue":e=>!0,"update:menu":e=>!0},setup(e,t){let{slots:a}=t;const{t:n}=Kt(),i=D(),o=D(!1),r=D(!0),s=he(e,"menu"),{items:l,transformIn:c,transformOut:u}=vs(e),h=he(e,"search",""),m=he(e,"modelValue",[],y=>c(vt(y)),y=>{var _;const M=u(y);return e.multiple?M:(_=M[0])!=null?_:null}),{filteredItems:f}=nh(e,l,g(()=>r.value?void 0:h.value)),p=g(()=>m.value.map(y=>l.value.find(_=>_.value===y.value)||y)),b=g(()=>p.value.map(y=>y.props.value));function w(y){m.value=[],e.openOnClear&&(s.value=!0),h.value=""}function v(){e.hideNoData&&!f.value.length||(s.value=!0)}function S(y){["Enter","ArrowDown"].includes(y.key)&&(s.value=!0),["Escape"].includes(y.key)&&(s.value=!1),["Enter","Escape","Tab"].includes(y.key)&&(r.value=!0)}function k(y){h.value=y.target.value}function P(){o.value&&(r.value=!0)}const j=D(!1);function x(y){if(e.multiple){const _=b.value.findIndex(M=>M===y.value);if(_===-1)m.value=[...m.value,y],h.value="";else{const M=[...m.value];M.splice(_,1),m.value=M}}else m.value=[y],j.value=!0,h.value=y.title,s.value=!1,r.value=!0,Ee(()=>j.value=!1)}return re(o,y=>{if(y){var _,M;j.value=!0,h.value=e.multiple?"":String((_=(M=p.value.at(-1))==null?void 0:M.props.title)!=null?_:""),r.value=!0,Ee(()=>j.value=!1)}else s.value=!1,h.value=""}),re(h,y=>{!o.value||j.value||(y&&(s.value=!0),r.value=!y)}),O(()=>{const y=!!(e.chips||a.chip);return d(ii,{ref:i,modelValue:h.value,"onUpdate:modelValue":_=>{_==null&&(m.value=[])},validationValue:e.modelValue,onInput:k,class:["v-autocomplete",{"v-autocomplete--active-menu":s.value,"v-autocomplete--chips":!!e.chips,[`v-autocomplete--${e.multiple?"multiple":"single"}`]:!0}],appendInnerIcon:e.menuIcon,"onClick:clear":w,"onClick:control":v,"onClick:input":v,onFocus:()=>o.value=!0,onBlur:()=>o.value=!1,onKeydown:S},{...a,default:()=>{var _,M;return d(pe,null,[d(xo,oe({modelValue:s.value,"onUpdate:modelValue":I=>s.value=I,activator:"parent",contentClass:"v-autocomplete__content",eager:e.eager,openOnClick:!1,closeOnContentClick:!1,transition:e.transition,onAfterLeave:P},e.menuProps),{default:()=>[d(yo,{selected:b.value,selectStrategy:e.multiple?"independent":"single-independent",onMousedown:I=>I.preventDefault()},{default:()=>[!f.value.length&&!e.hideNoData&&((_=(M=a["no-data"])==null?void 0:M.call(a))!=null?_:d(Nt,{title:n(e.noDataText)},null)),f.value.map((I,J)=>{var T,L;let{item:B,matches:F}=I;return(T=(L=a.item)==null?void 0:L.call(a,{item:B,index:J,props:oe(B.props,{onClick:()=>x(B)})}))!=null?T:d(Nt,oe({key:J},B.props,{onClick:()=>x(B)}),{prepend:$=>{let{isSelected:N}=$;return e.multiple?d(vn,{modelValue:N,ripple:!1},null):void 0},title:()=>{var $,N;return r.value?B.title:mb(B.title,F.title,($=(N=h.value)==null?void 0:N.length)!=null?$:0)}})})]})]}),p.value.map((I,J)=>{function T(B){B.stopPropagation(),B.preventDefault(),x(I)}const L={"onClick:close":T,modelValue:!0};return d("div",{key:J,class:"v-autocomplete__selection"},[y?d(Le,{defaults:{VChip:{closable:e.closableChips,size:"small",text:I.title}}},{default:()=>[a.chip?a.chip({item:I,index:J,props:L}):d(ri,L,null)]}):a.selection?a.selection({item:I,index:J}):d("span",{class:"v-autocomplete__selection-text"},[I.title,e.multiple&&J<p.value.length-1&&d("span",{class:"v-autocomplete__selection-comma"},[ei(",")])])])})])}})}),Qt({isFocused:o,isPristine:r,menu:s,search:h,filteredItems:f,select:x},i)}});const pb=H({name:"VBadge",inheritAttrs:!1,props:{bordered:Boolean,color:String,content:[Number,String],dot:Boolean,floating:Boolean,icon:se,inline:Boolean,label:{type:String,default:"$vuetify.badge"},max:[Number,String],modelValue:{type:Boolean,default:!0},offsetX:[Number,String],offsetY:[Number,String],textColor:String,...Fa({location:"top end"}),...Ie(),...le(),...ve(),...dt({transition:"scale-rotate-transition"})},setup(e,t){const{backgroundColorClasses:a,backgroundColorStyles:n}=Be(z(e,"color")),{roundedClasses:i}=Re(e),{t:o}=Kt(),{textColorClasses:r,textColorStyles:s}=at(z(e,"textColor")),{themeClasses:l}=Lu(),{locationStyles:c}=Ra(e,!0,u=>{var h,m;return(e.floating?e.dot?2:4:e.dot?8:12)+(["top","bottom"].includes(u)?+((h=e.offsetY)!=null?h:0):["left","right"].includes(u)?+((m=e.offsetX)!=null?m:0):0)});return O(()=>{var u,h,m,f;const p=Number(e.content),b=!e.max||isNaN(p)?e.content:p<=e.max?p:`${e.max}+`,[w,v]=Bt(t.attrs,["aria-atomic","aria-label","aria-live","role","title"]);return d(e.tag,oe({class:["v-badge",{"v-badge--bordered":e.bordered,"v-badge--dot":e.dot,"v-badge--floating":e.floating,"v-badge--inline":e.inline}]},v),{default:()=>[d("div",{class:"v-badge__wrapper"},[(u=(h=t.slots).default)==null?void 0:u.call(h),d(Tt,{transition:e.transition},{default:()=>[Me(d("span",oe({class:["v-badge__badge",l.value,a.value,i.value,r.value],style:[n.value,s.value,e.inline?{}:c.value],"aria-atomic":"true","aria-label":o(e.label,p),"aria-live":"polite",role:"status"},w),[e.dot?void 0:t.slots.badge?(m=(f=t.slots).badge)==null?void 0:m.call(f):e.icon?d(Te,{icon:e.icon},null):b]),[[Et,e.modelValue]])]})])]})}),{}}});const ih=H({name:"VBannerActions",props:{color:String,density:String},setup(e,t){let{slots:a}=t;return Ue({VBtn:{color:e.color,density:e.density,variant:"text"}}),O(()=>{var n;return d("div",{class:"v-banner-actions"},[(n=a.default)==null?void 0:n.call(a)])}),{}}}),oh=ut("v-banner-text"),gb=H({name:"VBanner",props:{avatar:String,color:String,icon:se,lines:String,stacked:Boolean,sticky:Boolean,text:String,...ht(),...Ge(),...wt(),...He(),...Fa(),...hn(),...Ie(),...le(),...ve()},setup(e,t){let{slots:a}=t;const{borderClasses:n}=xt(e),{densityClasses:i}=Xe(e),{mobile:o}=Qr(),{dimensionStyles:r}=kt(e),{elevationClasses:s}=qe(e),{locationStyles:l}=Ra(e),{positionClasses:c}=mn(e),{roundedClasses:u}=Re(e),{themeClasses:h}=ke(e),m=z(e,"color"),f=z(e,"density");Ue({VBannerActions:{color:m,density:f}}),O(()=>{var p;const b=!!(e.text||a.text),w=!!(a.prepend||e.avatar||e.icon);return d(e.tag,{class:["v-banner",{"v-banner--stacked":e.stacked||o.value,"v-banner--sticky":e.sticky,[`v-banner--${e.lines}-line`]:!!e.lines},n.value,i.value,s.value,c.value,u.value,h.value],style:[r.value,l.value],role:"banner"},{default:()=>[w&&d(Le,{key:"prepend",defaults:{VAvatar:{color:m.value,density:f.value,icon:e.icon,image:e.avatar}}},{default:()=>[d("div",{class:"v-banner__prepend"},[a.prepend?a.prepend():(e.avatar||e.icon)&&d(Ja,null,null)])]}),d("div",{class:"v-banner__content"},[b&&d(oh,{key:"text"},{default:()=>[a.text?a.text():e.text]}),(p=a.default)==null?void 0:p.call(a)]),a.actions&&d(ih,null,{default:()=>[a.actions()]})]})})}});const vb=H({name:"VBottomNavigation",props:{bgColor:String,color:String,grow:Boolean,mode:{type:String,validator:e=>!e||["horizontal","shift"].includes(e)},height:{type:[Number,String],default:56},...ht(),...Ge(),...He(),...Ie(),...rn({name:"bottom-navigation"}),...le({tag:"header"}),...pn({modelValue:!0,selectedClass:"v-btn--selected"}),...ve()},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const{themeClasses:n}=Lu(),{borderClasses:i}=xt(e),{backgroundColorClasses:o,backgroundColorStyles:r}=Be(z(e,"bgColor")),{densityClasses:s}=Xe(e),{elevationClasses:l}=qe(e),{roundedClasses:c}=Re(e),u=g(()=>Number(e.height)-(e.density==="comfortable"?8:0)-(e.density==="compact"?16:0)),h=he(e,"modelValue",e.modelValue),{layoutItemStyles:m}=sn({id:e.name,order:g(()=>parseInt(e.order,10)),position:g(()=>"bottom"),layoutSize:g(()=>h.value?u.value:0),elementSize:u,active:h,absolute:z(e,"absolute")});return za(e,fs),Ue({VBtn:{color:z(e,"color"),density:z(e,"density"),stacked:g(()=>e.mode!=="horizontal"),variant:"text"}},{scoped:!0}),O(()=>d(e.tag,{class:["v-bottom-navigation",{"v-bottom-navigation--active":h.value,"v-bottom-navigation--grow":e.grow,"v-bottom-navigation--shift":e.mode==="shift"},n.value,o.value,i.value,s.value,l.value,c.value],style:[r.value,m.value,{height:Q(u.value),transform:`translateY(${Q(h.value?0:100,"%")})`}]},{default:()=>[a.default&&d("div",{class:"v-bottom-navigation__content"},[a.default()])]})),{}}});const rh=ut("v-breadcrumbs-divider","li"),sh=H({name:"VBreadcrumbsItem",props:{active:Boolean,activeClass:String,activeColor:String,color:String,disabled:Boolean,title:String,...fn(),...le({tag:"li"})},setup(e,t){let{slots:a,attrs:n}=t;const i=ai(e,n),o=g(()=>{var c;return e.active||((c=i.isExactActive)==null?void 0:c.value)}),r=g(()=>o.value?e.activeColor:e.color),{textColorClasses:s,textColorStyles:l}=at(r);return O(()=>{var c,u;const h=i.isLink.value?"a":e.tag;return d(h,{class:["v-breadcrumbs-item",{"v-breadcrumbs-item--active":o.value,"v-breadcrumbs-item--disabled":e.disabled,"v-breadcrumbs-item--link":i.isLink.value,[`${e.activeClass}`]:o.value&&e.activeClass},s.value],style:[l.value],href:i.href.value,"aria-current":o.value?"page":void 0,onClick:i.navigate},{default:()=>[(c=(u=a.default)==null?void 0:u.call(a))!=null?c:e.title]})}),{}}}),bb=Fe()({name:"VBreadcrumbs",props:{activeClass:String,activeColor:String,bgColor:String,color:String,disabled:Boolean,divider:{type:String,default:"/"},icon:se,items:{type:Array,default:()=>[]},...Ge(),...Ie(),...le({tag:"ul"})},setup(e,t){let{slots:a}=t;const{backgroundColorClasses:n,backgroundColorStyles:i}=Be(z(e,"bgColor")),{densityClasses:o}=Xe(e),{roundedClasses:r}=Re(e);return Ue({VBreadcrumbsItem:{activeClass:z(e,"activeClass"),activeColor:z(e,"activeColor"),color:z(e,"color"),disabled:z(e,"disabled")}}),O(()=>{var s;const l=!!(a.prepend||e.icon);return d(e.tag,{class:["v-breadcrumbs",n.value,o.value,r.value],style:i.value},{default:()=>[e.icon&&d(Te,{key:"icon",icon:e.icon,left:!0},null),l&&d(Le,{key:"prepend",defaults:{VIcon:{icon:e.icon,start:!0}}},{default:()=>[d("div",{class:"v-breadcrumbs__prepend"},[a.prepend?a.prepend():e.icon&&d(Te,null,null)])]}),e.items.map((c,u,h)=>{var m,f;return d(pe,null,[d(sh,oe({key:u,disabled:u>=h.length-1},typeof c=="string"?{title:c}:c),{default:a.title?()=>{var p;return(p=a.title)==null?void 0:p.call(a,{item:c,index:u})}:void 0}),u<h.length-1&&d(rh,null,{default:()=>[(m=(f=a.divider)==null?void 0:f.call(a,{item:c,index:u}))!=null?m:e.divider]})])}),(s=a.default)==null?void 0:s.call(a)]})}),{}}});const yb=e=>{const{touchstartX:t,touchendX:a,touchstartY:n,touchendY:i}=e,o=.5,r=16;e.offsetX=a-t,e.offsetY=i-n,Math.abs(e.offsetY)<o*Math.abs(e.offsetX)&&(e.left&&a<t-r&&e.left(e),e.right&&a>t+r&&e.right(e)),Math.abs(e.offsetX)<o*Math.abs(e.offsetY)&&(e.up&&i<n-r&&e.up(e),e.down&&i>n+r&&e.down(e))};function wb(e,t){var a;const n=e.changedTouches[0];t.touchstartX=n.clientX,t.touchstartY=n.clientY,(a=t.start)==null||a.call(t,{originalEvent:e,...t})}function kb(e,t){var a;const n=e.changedTouches[0];t.touchendX=n.clientX,t.touchendY=n.clientY,(a=t.end)==null||a.call(t,{originalEvent:e,...t}),yb(t)}function xb(e,t){var a;const n=e.changedTouches[0];t.touchmoveX=n.clientX,t.touchmoveY=n.clientY,(a=t.move)==null||a.call(t,{originalEvent:e,...t})}function Cb(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const t={touchstartX:0,touchstartY:0,touchendX:0,touchendY:0,touchmoveX:0,touchmoveY:0,offsetX:0,offsetY:0,left:e.left,right:e.right,up:e.up,down:e.down,start:e.start,move:e.move,end:e.end};return{touchstart:a=>wb(a,t),touchend:a=>kb(a,t),touchmove:a=>xb(a,t)}}function Sb(e,t){var a,n,i;const o=t.value,r=o!=null&&o.parent?e.parentElement:e,s=(a=o==null?void 0:o.options)!=null?a:{passive:!0},l=(n=t.instance)==null?void 0:n.$.uid;if(!r||!l)return;const c=Cb(t.value);r._touchHandlers=(i=r._touchHandlers)!=null?i:Object.create(null),r._touchHandlers[l]=c,mu(c).forEach(u=>{r.addEventListener(u,c[u],s)})}function _b(e,t){var a,n;const i=(a=t.value)!=null&&a.parent?e.parentElement:e,o=(n=t.instance)==null?void 0:n.$.uid;if(!(i!=null&&i._touchHandlers)||!o)return;const r=i._touchHandlers[o];mu(r).forEach(s=>{i.removeEventListener(s,r[s])}),delete i._touchHandlers[o]}const ws={mounted:Sb,unmounted:_b},lh=Symbol.for("vuetify:v-window"),ch=Symbol.for("vuetify:v-window-group"),uh=Fe()({name:"VWindow",directives:{Touch:ws},props:{continuous:Boolean,nextIcon:{type:[Boolean,String,Function,Object],default:"$next"},prevIcon:{type:[Boolean,String,Function,Object],default:"$prev"},reverse:Boolean,showArrows:{type:[Boolean,String],validator:e=>typeof e=="boolean"||e==="hover"},touch:{type:[Object,Boolean],default:void 0},direction:{type:String,default:"horizontal"},modelValue:null,disabled:Boolean,selectedClass:{type:String,default:"v-window-item--active"},mandatory:{default:"force"},...le(),...ve()},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const{themeClasses:n}=ke(e),{isRtl:i}=ma(),{t:o}=Kt(),r=za(e,ch),s=D(),l=g(()=>i.value?!e.reverse:e.reverse),c=D(!1),u=g(()=>{const P=e.direction==="vertical"?"y":"x",x=(l.value?!c.value:c.value)?"-reverse":"";return`v-window-${P}${x}-transition`}),h=D(0),m=D(void 0),f=g(()=>r.items.value.findIndex(P=>r.selected.value.includes(P.id)));re(f,(P,j)=>{const x=r.items.value.length,y=x-1;x<=2?c.value=P<j:P===y&&j===0?c.value=!0:P===0&&j===y?c.value=!1:c.value=P<j}),Oe(lh,{transition:u,isReversed:c,transitionCount:h,transitionHeight:m,rootRef:s});const p=g(()=>e.continuous||f.value!==0),b=g(()=>e.continuous||f.value!==r.items.value.length-1);function w(){p.value&&r.prev()}function v(){b.value&&r.next()}const S=g(()=>{const P=[],j={icon:i.value?e.nextIcon:e.prevIcon,class:`v-window__${l.value?"right":"left"}`,onClick:r.prev,ariaLabel:o("$vuetify.carousel.prev")};P.push(p.value?a.prev?a.prev({props:j}):d(rt,j,null):d("div",null,null));const x={icon:i.value?e.prevIcon:e.nextIcon,class:`v-window__${l.value?"left":"right"}`,onClick:r.next,ariaLabel:o("$vuetify.carousel.next")};return P.push(b.value?a.next?a.next({props:x}):d(rt,x,null):d("div",null,null)),P}),k=g(()=>e.touch===!1?e.touch:{...{left:()=>{l.value?w():v()},right:()=>{l.value?v():w()},end:j=>{let{originalEvent:x}=j;x.stopPropagation()},start:j=>{let{originalEvent:x}=j;x.stopPropagation()}},...e.touch===!0?{}:e.touch});return O(()=>{var P,j;return Me(d(e.tag,{ref:s,class:["v-window",{"v-window--show-arrows-on-hover":e.showArrows==="hover"},n.value]},{default:()=>[d("div",{class:"v-window__container",style:{height:m.value}},[(P=a.default)==null?void 0:P.call(a,{group:r}),e.showArrows!==!1&&d("div",{class:"v-window__controls"},[S.value])]),(j=a.additional)==null?void 0:j.call(a,{group:r})]}),[[ct("touch"),k.value]])}),{group:r}}}),dh=H({name:"VWindowItem",directives:{Touch:ws},props:{reverseTransition:{type:[Boolean,String],default:void 0},transition:{type:[Boolean,String],default:void 0},...Va(),...wo()},setup(e,t){let{slots:a}=t;const n=we(lh),i=gn(e,ch),{isBooted:o}=bo();if(!n||!i)throw new Error("[Vuetify] VWindowItem must be used inside VWindow");const r=D(!1),s=g(()=>n.isReversed.value?e.reverseTransition!==!1:e.transition!==!1);function l(){!r.value||!n||(r.value=!1,n.transitionCount.value>0&&(n.transitionCount.value-=1,n.transitionCount.value===0&&(n.transitionHeight.value=void 0)))}function c(){if(!(r.value||!n)){if(r.value=!0,n.transitionCount.value===0){var p;n.transitionHeight.value=Q((p=n.rootRef.value)==null?void 0:p.clientHeight)}n.transitionCount.value+=1}}function u(){l()}function h(p){!r.value||Ee(()=>{!s.value||!r.value||!n||(n.transitionHeight.value=Q(p.clientHeight))})}const m=g(()=>{const p=n.isReversed.value?e.reverseTransition:e.transition;return s.value?{name:typeof p!="string"?n.transition.value:p,onBeforeEnter:c,onAfterEnter:l,onEnterCancelled:u,onBeforeLeave:c,onAfterLeave:l,onLeaveCancelled:u,onEnter:h}:!1}),{hasContent:f}=bs(e,i.isSelected);return O(()=>{var p;return d(Tt,{transition:o.value&&m.value},{default:()=>[Me(d("div",{class:["v-window-item",i.selectedClass.value]},[f.value&&((p=a.default)==null?void 0:p.call(a))]),[[Et,i.isSelected.value]])]})}),{}}}),Tb=H({name:"VCarousel",props:{color:String,cycle:Boolean,delimiterIcon:{type:se,default:"$delimiter"},height:{type:[Number,String],default:500},hideDelimiters:Boolean,hideDelimiterBackground:Boolean,interval:{type:[Number,String],default:6e3,validator:e=>e>0},modelValue:null,progress:[Boolean,String],showArrows:{type:[Boolean,String],default:!0,validator:e=>typeof e=="boolean"||e==="hover"},verticalDelimiters:[Boolean,String]},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const n=he(e,"modelValue"),{t:i}=Kt(),o=D();let r=-1;re(n,l),re(()=>e.interval,l),re(()=>e.cycle,c=>{c?l():window.clearTimeout(r)}),yt(s);function s(){!e.cycle||!o.value||(r=window.setTimeout(o.value.group.next,+e.interval>0?+e.interval:6e3))}function l(){window.clearTimeout(r),window.requestAnimationFrame(s)}return O(()=>d(uh,{ref:o,modelValue:n.value,"onUpdate:modelValue":c=>n.value=c,class:["v-carousel",{"v-carousel--hide-delimiter-background":e.hideDelimiterBackground,"v-carousel--vertical-delimiters":e.verticalDelimiters}],style:{height:Q(e.height)},continuous:!0,mandatory:"force",showArrows:e.showArrows},{default:a.default,additional:c=>{let{group:u}=c;return d(pe,null,[!e.hideDelimiters&&d("div",{class:"v-carousel__controls",style:{left:e.verticalDelimiters==="left"&&e.verticalDelimiters?0:"auto",right:e.verticalDelimiters==="right"?0:"auto"}},[u.items.value.length>0&&d(Le,{defaults:{VBtn:{color:e.color,icon:e.delimiterIcon,size:"x-small",variant:"text"}},scoped:!0},{default:()=>[u.items.value.map(h=>{const m={"aria-label":i("$vuetify.carousel.ariaLabel.delimiter"),class:[u.isSelected(h.id)&&"v-btn--selected"],onClick:()=>u.select(h.id,!0)};return a.item?a.item({props:m,item:h}):d(rt,oe(h,m),null)})]})]),e.progress&&d(as,{class:"v-carousel__progress",color:typeof e.progress=="string"?e.progress:void 0,modelValue:(u.getItemIndex(n.value)+1)/u.items.value.length*100},null)])},prev:a.prev,next:a.next})),{}}}),jb=H({name:"VCarouselItem",inheritAttrs:!1,props:{value:null},setup(e,t){let{slots:a,attrs:n}=t;O(()=>d(dh,{class:"v-carousel-item",value:e.value},{default:()=>[d(cn,n,a)]}))}});const Pb=ut("v-code");const Ib=H({name:"VColorPickerCanvas",props:{color:{type:Object},disabled:Boolean,dotSize:{type:[Number,String],default:10},height:{type:[Number,String],default:150},width:{type:[Number,String],default:300}},emits:{"update:color":e=>!0,"update:position":e=>!0},setup(e,t){let{emit:a}=t;const n=D(!1),i=D(!1),o=D({x:0,y:0}),r=g(()=>{const{x:p,y:b}=o.value,w=parseInt(e.dotSize,10)/2;return{width:Q(e.dotSize),height:Q(e.dotSize),transform:`translate(${Q(p-w)}, ${Q(b-w)})`}}),s=D();function l(p,b,w){const{left:v,top:S,width:k,height:P}=w;o.value={x:Lt(p-v,0,k),y:Lt(b-S,0,P)}}function c(p){e.disabled||!s.value||l(p.clientX,p.clientY,s.value.getBoundingClientRect())}function u(p){p.preventDefault(),!e.disabled&&(n.value=!0,window.addEventListener("mousemove",h),window.addEventListener("mouseup",m),window.addEventListener("touchmove",h),window.addEventListener("touchend",m))}function h(p){if(e.disabled||!s.value)return;n.value=!0;const b=vp(p);l(b.clientX,b.clientY,s.value.getBoundingClientRect())}function m(){window.removeEventListener("mousemove",h),window.removeEventListener("mouseup",m),window.removeEventListener("touchmove",h),window.removeEventListener("touchend",m)}re(o,()=>{var p,b,w,v;if(i.value){i.value=!1;return}if(!s.value)return;const{width:S,height:k}=s.value.getBoundingClientRect(),{x:P,y:j}=o.value;a("update:color",{h:(p=(b=e.color)==null?void 0:b.h)!=null?p:0,s:Lt(P,0,S)/S,v:1-Lt(j,0,k)/k,a:(w=(v=e.color)==null?void 0:v.a)!=null?w:1})});function f(){var p,b;if(!s.value)return;const w=s.value,v=w.getContext("2d");if(!v)return;const S=v.createLinearGradient(0,0,w.width,0);S.addColorStop(0,"hsla(0, 0%, 100%, 1)"),S.addColorStop(1,`hsla(${(p=(b=e.color)==null?void 0:b.h)!=null?p:0}, 100%, 50%, 1)`),v.fillStyle=S,v.fillRect(0,0,w.width,w.height);const k=v.createLinearGradient(0,0,0,w.height);k.addColorStop(0,"hsla(0, 0%, 100%, 0)"),k.addColorStop(1,"hsla(0, 0%, 0%, 1)"),v.fillStyle=k,v.fillRect(0,0,w.width,w.height)}return re(()=>{var p;return(p=e.color)==null?void 0:p.h},f,{immediate:!0}),re(()=>e.color,()=>{if(n.value){n.value=!1;return}!e.color||(i.value=!0,o.value={x:e.color.s*parseInt(e.width,10),y:(1-e.color.v)*parseInt(e.height,10)})},{deep:!0,immediate:!0}),yt(()=>f()),O(()=>d("div",{class:"v-color-picker-canvas",style:{width:Q(e.width),height:Q(e.height)},onClick:c,onMousedown:u,onTouchstart:u},[d("canvas",{ref:s,width:e.width,height:e.height},null),d("div",{class:["v-color-picker-canvas__dot",{"v-color-picker-canvas__dot--disabled":e.disabled}],style:r.value},null)])),{}}});var Wl;function Ta(e,t){return t.every(a=>e.hasOwnProperty(a))}function hh(e){var t;if(!e)return null;let a=null;if(typeof e=="string"){const n=Dp(e);a=Su(n)}return typeof e=="object"&&(Ta(e,["r","g","b"])?a=Kr(e):Ta(e,["h","s","l"])?a=xu(e):Ta(e,["h","s","v"])&&(a=e)),a!=null?{...a,a:(t=a.a)!=null?t:1}:null}function Ab(e,t){if(t){const{a,...n}=e;return n}return e}function Mb(e,t){if(t==null||typeof t=="string"){const a=_u(e);return e.a===1?a.slice(0,7):a}if(typeof t=="object"){let a;return Ta(t,["r","g","b"])?a=so(e):Ta(t,["h","s","l"])?a=ku(e):Ta(t,["h","s","v"])&&(a=e),Ab(a,!Ta(t,["a"]))}return e}const ji={h:0,s:0,v:1,a:1},Cr={inputProps:{type:"number",min:0},inputs:[{label:"R",max:255,step:1,getValue:e=>Math.round(e.r),getColor:(e,t)=>({...e,r:Number(t)})},{label:"G",max:255,step:1,getValue:e=>Math.round(e.g),getColor:(e,t)=>({...e,g:Number(t)})},{label:"B",max:255,step:1,getValue:e=>Math.round(e.b),getColor:(e,t)=>({...e,b:Number(t)})},{label:"A",max:1,step:.01,getValue:e=>Math.round(e.a*100)/100,getColor:(e,t)=>({...e,a:Number(t)})}],to:so,from:Kr},Jb={...Cr,inputs:(Wl=Cr.inputs)==null?void 0:Wl.slice(0,3)},Sr={inputProps:{type:"number",min:0},inputs:[{label:"H",max:360,step:1,getValue:e=>Math.round(e.h),getColor:(e,t)=>({...e,h:Number(t)})},{label:"S",max:1,step:.01,getValue:e=>Math.round(e.s*100)/100,getColor:(e,t)=>({...e,s:Number(t)})},{label:"L",max:1,step:.01,getValue:e=>Math.round(e.l*100)/100,getColor:(e,t)=>({...e,l:Number(t)})},{label:"A",max:1,step:.01,getValue:e=>Math.round(e.a*100)/100,getColor:(e,t)=>({...e,a:Number(t)})}],to:ku,from:xu},Lb={...Sr,inputs:Sr.inputs.slice(0,3)},mh={inputProps:{type:"text"},inputs:[{label:"HEXA",getValue:e=>e,getColor:(e,t)=>t}],to:_u,from:Su},Db={...mh,inputs:[{label:"HEX",getValue:e=>e.slice(0,7),getColor:(e,t)=>t}]},ja={rgb:Jb,rgba:Cr,hsl:Lb,hsla:Sr,hex:Db,hexa:mh},Eb=e=>{let{label:t,...a}=e;return d("div",{class:"v-color-picker-edit__input"},[d("input",a,null),d("span",null,[t])])},Bb=H({name:"VColorPickerEdit",props:{color:Object,disabled:Boolean,mode:{type:String,default:"rgba",validator:e=>Object.keys(ja).includes(e)},modes:{type:Array,default:()=>Object.keys(ja),validator:e=>Array.isArray(e)&&e.every(t=>Object.keys(ja).includes(t))}},emits:{"update:color":e=>!0,"update:mode":e=>!0},setup(e,t){let{emit:a}=t;const n=g(()=>e.modes.map(o=>({...ja[o],name:o}))),i=g(()=>{var o;const r=n.value.find(l=>l.name===e.mode);if(!r)return[];const s=e.color?r.to(e.color):{};return(o=r.inputs)==null?void 0:o.map(l=>{let{getValue:c,getColor:u,...h}=l;return{...r.inputProps,...h,disabled:e.disabled,value:c(s),onChange:m=>{const f=m.target;!f||a("update:color",r.from(u(s,f.value)))}}})});return O(()=>{var o;return d("div",{class:"v-color-picker-edit"},[(o=i.value)==null?void 0:o.map(r=>d(Eb,r,null)),n.value.length>1&&d(rt,{icon:"$unfold",size:"x-small",variant:"plain",onClick:()=>{const r=n.value.findIndex(s=>s.name===e.mode);a("update:mode",n.value[(r+1)%n.value.length].name)}},null)])}),{}}});const Fb=H({name:"VColorPickerPreview",props:{color:{type:Object},disabled:Boolean,hideAlpha:Boolean},emits:{"update:color":e=>!0},setup(e,t){let{emit:a}=t;return O(()=>{var n,i,o;return d("div",{class:["v-color-picker-preview",{"v-color-picker-preview--hide-alpha":e.hideAlpha}]},[d("div",{class:"v-color-picker-preview__dot"},[d("div",{style:{background:Cu((n=e.color)!=null?n:ji)}},null)]),d("div",{class:"v-color-picker-preview__sliders"},[d(Hi,{class:"v-color-picker-preview__track v-color-picker-preview__hue",modelValue:(i=e.color)==null?void 0:i.h,"onUpdate:modelValue":r=>{var s;return a("update:color",{...(s=e.color)!=null?s:ji,h:r})},step:0,min:0,max:360,disabled:e.disabled,thumbSize:14,trackSize:8,trackFillColor:"white",hideDetails:!0},null),!e.hideAlpha&&d(Hi,{class:"v-color-picker-preview__track v-color-picker-preview__alpha",modelValue:(o=e.color)==null?void 0:o.a,"onUpdate:modelValue":r=>{var s;return a("update:color",{...(s=e.color)!=null?s:ji,a:r})},step:0,min:0,max:1,disabled:e.disabled,thumbSize:14,trackSize:8,trackFillColor:"white",hideDetails:!0},null)])])}),{}}});const Rb=Object.freeze({base:"#f44336",lighten5:"#ffebee",lighten4:"#ffcdd2",lighten3:"#ef9a9a",lighten2:"#e57373",lighten1:"#ef5350",darken1:"#e53935",darken2:"#d32f2f",darken3:"#c62828",darken4:"#b71c1c",accent1:"#ff8a80",accent2:"#ff5252",accent3:"#ff1744",accent4:"#d50000"}),Vb=Object.freeze({base:"#e91e63",lighten5:"#fce4ec",lighten4:"#f8bbd0",lighten3:"#f48fb1",lighten2:"#f06292",lighten1:"#ec407a",darken1:"#d81b60",darken2:"#c2185b",darken3:"#ad1457",darken4:"#880e4f",accent1:"#ff80ab",accent2:"#ff4081",accent3:"#f50057",accent4:"#c51162"}),zb=Object.freeze({base:"#9c27b0",lighten5:"#f3e5f5",lighten4:"#e1bee7",lighten3:"#ce93d8",lighten2:"#ba68c8",lighten1:"#ab47bc",darken1:"#8e24aa",darken2:"#7b1fa2",darken3:"#6a1b9a",darken4:"#4a148c",accent1:"#ea80fc",accent2:"#e040fb",accent3:"#d500f9",accent4:"#aa00ff"}),Hb=Object.freeze({base:"#673ab7",lighten5:"#ede7f6",lighten4:"#d1c4e9",lighten3:"#b39ddb",lighten2:"#9575cd",lighten1:"#7e57c2",darken1:"#5e35b1",darken2:"#512da8",darken3:"#4527a0",darken4:"#311b92",accent1:"#b388ff",accent2:"#7c4dff",accent3:"#651fff",accent4:"#6200ea"}),Ob=Object.freeze({base:"#3f51b5",lighten5:"#e8eaf6",lighten4:"#c5cae9",lighten3:"#9fa8da",lighten2:"#7986cb",lighten1:"#5c6bc0",darken1:"#3949ab",darken2:"#303f9f",darken3:"#283593",darken4:"#1a237e",accent1:"#8c9eff",accent2:"#536dfe",accent3:"#3d5afe",accent4:"#304ffe"}),Gb=Object.freeze({base:"#2196f3",lighten5:"#e3f2fd",lighten4:"#bbdefb",lighten3:"#90caf9",lighten2:"#64b5f6",lighten1:"#42a5f5",darken1:"#1e88e5",darken2:"#1976d2",darken3:"#1565c0",darken4:"#0d47a1",accent1:"#82b1ff",accent2:"#448aff",accent3:"#2979ff",accent4:"#2962ff"}),Nb=Object.freeze({base:"#03a9f4",lighten5:"#e1f5fe",lighten4:"#b3e5fc",lighten3:"#81d4fa",lighten2:"#4fc3f7",lighten1:"#29b6f6",darken1:"#039be5",darken2:"#0288d1",darken3:"#0277bd",darken4:"#01579b",accent1:"#80d8ff",accent2:"#40c4ff",accent3:"#00b0ff",accent4:"#0091ea"}),$b=Object.freeze({base:"#00bcd4",lighten5:"#e0f7fa",lighten4:"#b2ebf2",lighten3:"#80deea",lighten2:"#4dd0e1",lighten1:"#26c6da",darken1:"#00acc1",darken2:"#0097a7",darken3:"#00838f",darken4:"#006064",accent1:"#84ffff",accent2:"#18ffff",accent3:"#00e5ff",accent4:"#00b8d4"}),Ub=Object.freeze({base:"#009688",lighten5:"#e0f2f1",lighten4:"#b2dfdb",lighten3:"#80cbc4",lighten2:"#4db6ac",lighten1:"#26a69a",darken1:"#00897b",darken2:"#00796b",darken3:"#00695c",darken4:"#004d40",accent1:"#a7ffeb",accent2:"#64ffda",accent3:"#1de9b6",accent4:"#00bfa5"}),Wb=Object.freeze({base:"#4caf50",lighten5:"#e8f5e9",lighten4:"#c8e6c9",lighten3:"#a5d6a7",lighten2:"#81c784",lighten1:"#66bb6a",darken1:"#43a047",darken2:"#388e3c",darken3:"#2e7d32",darken4:"#1b5e20",accent1:"#b9f6ca",accent2:"#69f0ae",accent3:"#00e676",accent4:"#00c853"}),qb=Object.freeze({base:"#8bc34a",lighten5:"#f1f8e9",lighten4:"#dcedc8",lighten3:"#c5e1a5",lighten2:"#aed581",lighten1:"#9ccc65",darken1:"#7cb342",darken2:"#689f38",darken3:"#558b2f",darken4:"#33691e",accent1:"#ccff90",accent2:"#b2ff59",accent3:"#76ff03",accent4:"#64dd17"}),Kb=Object.freeze({base:"#cddc39",lighten5:"#f9fbe7",lighten4:"#f0f4c3",lighten3:"#e6ee9c",lighten2:"#dce775",lighten1:"#d4e157",darken1:"#c0ca33",darken2:"#afb42b",darken3:"#9e9d24",darken4:"#827717",accent1:"#f4ff81",accent2:"#eeff41",accent3:"#c6ff00",accent4:"#aeea00"}),Yb=Object.freeze({base:"#ffeb3b",lighten5:"#fffde7",lighten4:"#fff9c4",lighten3:"#fff59d",lighten2:"#fff176",lighten1:"#ffee58",darken1:"#fdd835",darken2:"#fbc02d",darken3:"#f9a825",darken4:"#f57f17",accent1:"#ffff8d",accent2:"#ffff00",accent3:"#ffea00",accent4:"#ffd600"}),Xb=Object.freeze({base:"#ffc107",lighten5:"#fff8e1",lighten4:"#ffecb3",lighten3:"#ffe082",lighten2:"#ffd54f",lighten1:"#ffca28",darken1:"#ffb300",darken2:"#ffa000",darken3:"#ff8f00",darken4:"#ff6f00",accent1:"#ffe57f",accent2:"#ffd740",accent3:"#ffc400",accent4:"#ffab00"}),Qb=Object.freeze({base:"#ff9800",lighten5:"#fff3e0",lighten4:"#ffe0b2",lighten3:"#ffcc80",lighten2:"#ffb74d",lighten1:"#ffa726",darken1:"#fb8c00",darken2:"#f57c00",darken3:"#ef6c00",darken4:"#e65100",accent1:"#ffd180",accent2:"#ffab40",accent3:"#ff9100",accent4:"#ff6d00"}),Zb=Object.freeze({base:"#ff5722",lighten5:"#fbe9e7",lighten4:"#ffccbc",lighten3:"#ffab91",lighten2:"#ff8a65",lighten1:"#ff7043",darken1:"#f4511e",darken2:"#e64a19",darken3:"#d84315",darken4:"#bf360c",accent1:"#ff9e80",accent2:"#ff6e40",accent3:"#ff3d00",accent4:"#dd2c00"}),ey=Object.freeze({base:"#795548",lighten5:"#efebe9",lighten4:"#d7ccc8",lighten3:"#bcaaa4",lighten2:"#a1887f",lighten1:"#8d6e63",darken1:"#6d4c41",darken2:"#5d4037",darken3:"#4e342e",darken4:"#3e2723"}),ty=Object.freeze({base:"#607d8b",lighten5:"#eceff1",lighten4:"#cfd8dc",lighten3:"#b0bec5",lighten2:"#90a4ae",lighten1:"#78909c",darken1:"#546e7a",darken2:"#455a64",darken3:"#37474f",darken4:"#263238"}),ay=Object.freeze({base:"#9e9e9e",lighten5:"#fafafa",lighten4:"#f5f5f5",lighten3:"#eeeeee",lighten2:"#e0e0e0",lighten1:"#bdbdbd",darken1:"#757575",darken2:"#616161",darken3:"#424242",darken4:"#212121"}),ny=Object.freeze({black:"#000000",white:"#ffffff",transparent:"transparent"}),iy=Object.freeze({red:Rb,pink:Vb,purple:zb,deepPurple:Hb,indigo:Ob,blue:Gb,lightBlue:Nb,cyan:$b,teal:Ub,green:Wb,lightGreen:qb,lime:Kb,yellow:Yb,amber:Xb,orange:Qb,deepOrange:Zb,brown:ey,blueGrey:ty,grey:ay,shades:ny});function oy(e){return Object.keys(e).map(t=>{const a=e[t];return a.base?[a.base,a.darken4,a.darken3,a.darken2,a.darken1,a.lighten1,a.lighten2,a.lighten3,a.lighten4,a.lighten5]:[a.black,a.white,a.transparent]})}const ry=H({name:"VColorPickerSwatches",props:{swatches:{type:Array,default:()=>oy(iy)},disabled:Boolean,color:Object,maxHeight:[Number,String]},emits:{"update:color":e=>!0},setup(e,t){let{emit:a}=t;return O(()=>d("div",{class:"v-color-picker-swatches",style:{maxHeight:Q(e.maxHeight)}},[d("div",null,[e.swatches.map(n=>d("div",{class:"v-color-picker-swatches__swatch"},[n.map(i=>{const o=hh(i);return d("div",{class:"v-color-picker-swatches__color",onClick:()=>o&&a("update:color",o)},[d("div",{style:{background:i}},[e.color&&ti(e.color,o)?d(Te,{size:"x-small",icon:"$success",color:Fp(i,"#FFFFFF")>2?"white":"black"},null):void 0])])})]))])])),{}}});const fh=H({name:"VSheet",props:{color:String,...ht(),...wt(),...He(),...Fa(),...hn(),...Ie(),...le(),...ve()},setup(e,t){let{slots:a}=t;const{themeClasses:n}=ke(e),{backgroundColorClasses:i,backgroundColorStyles:o}=Be(z(e,"color")),{borderClasses:r}=xt(e),{dimensionStyles:s}=kt(e),{elevationClasses:l}=qe(e),{locationStyles:c}=Ra(e),{positionClasses:u}=mn(e),{roundedClasses:h}=Re(e);return()=>d(e.tag,{class:["v-sheet",n.value,i.value,r.value,l.value,u.value,h.value],style:[o.value,s.value,c.value]},a)}}),sy=H({name:"VColorPicker",inheritAttrs:!1,props:{canvasHeight:{type:[String,Number],default:150},disabled:Boolean,dotSize:{type:[Number,String],default:10},hideCanvas:Boolean,hideSliders:Boolean,hideInputs:Boolean,mode:{type:String,default:"rgba",validator:e=>Object.keys(ja).includes(e)},modes:{type:Array,default:()=>Object.keys(ja),validator:e=>Array.isArray(e)&&e.every(t=>Object.keys(ja).includes(t))},showSwatches:Boolean,swatches:Array,swatchesMaxHeight:{type:[Number,String],default:150},modelValue:{type:[Object,String]},width:{type:[Number,String],default:300},...He(),...Ie(),...ve()},emits:{"update:modelValue":e=>!0,"update:mode":e=>!0},setup(e){const t=he(e,"mode"),a=D(null),n=he(e,"modelValue",void 0,o=>{let r=hh(o);return r?(a.value&&(r={...r,h:a.value.h},a.value=null),r):null},o=>o?Mb(o,e.modelValue):null),i=o=>{n.value=o,a.value=o};return yt(()=>{e.modes.includes(t.value)||(t.value=e.modes[0])}),O(()=>{var o;return d(fh,{rounded:e.rounded,elevation:e.elevation,theme:e.theme,class:["v-color-picker"],style:{"--v-color-picker-color-hsv":Cu({...(o=n.value)!=null?o:ji,a:1})},maxWidth:e.width},{default:()=>[!e.hideCanvas&&d(Ib,{key:"canvas",color:n.value,"onUpdate:color":i,disabled:e.disabled,dotSize:e.dotSize,width:e.width,height:e.canvasHeight},null),(!e.hideSliders||!e.hideInputs)&&d("div",{key:"controls",class:"v-color-picker__controls"},[!e.hideSliders&&d(Fb,{key:"preview",color:n.value,"onUpdate:color":i,hideAlpha:!t.value.endsWith("a"),disabled:e.disabled},null),!e.hideInputs&&d(Bb,{key:"edit",modes:e.modes,mode:t.value,"onUpdate:mode":r=>t.value=r,color:n.value,"onUpdate:color":i,disabled:e.disabled},null)]),e.showSwatches&&d(ry,{key:"swatches",color:n.value,"onUpdate:color":i,maxHeight:e.swatchesMaxHeight,swatches:e.swatches,disabled:e.disabled},null)]})}),{}}});function ly(e,t,a){if(Array.isArray(t))throw new Error("Multiple matches is not implemented");return typeof t=="number"&&~t?d(pe,null,[d("span",{class:"v-combobox__unmask"},[e.substr(0,t)]),d("span",{class:"v-combobox__mask"},[e.substr(t,a)]),d("span",{class:"v-combobox__unmask"},[e.substr(t+a)])]):e}const cy=Fe()({name:"VCombobox",props:{delimiters:Array,...ah({filterKeys:["title"]}),...ys({hideNoData:!0,returnObject:!0}),...dt({transition:!1})},emits:{"update:modelValue":e=>!0,"update:searchInput":e=>!0,"update:menu":e=>!0},setup(e,t){let{emit:a,slots:n}=t;const{t:i}=Kt(),o=D(),r=D(!1),s=D(!0),l=he(e,"menu"),c=D(-1),u=g(()=>{var T;return(T=o.value)==null?void 0:T.color}),{items:h,transformIn:m,transformOut:f}=vs(e),{textColorClasses:p,textColorStyles:b}=at(u),w=he(e,"modelValue",[],T=>m(vt(T||[])),T=>{var L;const B=f(T);return e.multiple?B:(L=B[0])!=null?L:null}),v=D(""),S=g({get:()=>{if(e.multiple)return v.value;const T=h.value.find(L=>{var B;return L.value===((B=w.value[0])==null?void 0:B.value)});return T==null?void 0:T.value},set:T=>{var L;if(e.multiple?v.value=T:w.value=[Ka(e,T)],T&&e.multiple&&(L=e.delimiters)!=null&&L.length){const B=T.split(new RegExp(`(?:${e.delimiters.join("|")})+`));B.length>1&&(B.forEach(F=>{F=F.trim(),F&&J(Ka(e,F))}),v.value="")}T||(c.value=-1),r.value&&(l.value=!0),s.value=!T}});re(v,T=>{a("update:searchInput",T)});const{filteredItems:k}=nh(e,h,g(()=>s.value?void 0:S.value)),P=g(()=>w.value.map(T=>h.value.find(L=>L.value===T.value)||T)),j=g(()=>P.value.map(T=>T.props.value)),x=g(()=>P.value[c.value]);function y(T){w.value=[],e.openOnClear&&(l.value=!0)}function _(){e.hideNoData&&!k.value.length||(l.value=!0)}function M(T){const L=o.value.selectionStart,B=j.value.length;if(c.value>-1&&T.preventDefault(),["Enter","ArrowDown"].includes(T.key)&&(l.value=!0),["Escape"].includes(T.key)&&(l.value=!1),["Enter","Escape","Tab"].includes(T.key)&&(s.value=!0),!!e.multiple){if(["Backspace","Delete"].includes(T.key)){if(c.value<0){T.key==="Backspace"&&!S.value&&(c.value=B-1);return}J(x.value),Ee(()=>!x.value&&(c.value=B-2))}if(T.key==="ArrowLeft"){if(c.value<0&&L>0)return;const F=c.value>-1?c.value-1:B-1;P.value[F]?c.value=F:(c.value=-1,o.value.setSelectionRange(S.value.length,S.value.length))}if(T.key==="ArrowRight"){if(c.value<0)return;const F=c.value+1;P.value[F]?c.value=F:(c.value=-1,o.value.setSelectionRange(0,0))}T.key==="Enter"&&(J(Ka(e,S.value)),S.value="")}}function I(){r.value&&(s.value=!0)}function J(T){if(e.multiple){const L=j.value.findIndex(B=>B===T.value);if(L===-1)w.value=[...w.value,T];else{const B=[...w.value];B.splice(L,1),w.value=B}S.value=""}else S.value=T.title,Ee(()=>{l.value=!1,s.value=!0})}return re(k,T=>{!T.length&&e.hideNoData&&(l.value=!1)}),re(r,T=>{if(T)c.value=-1;else{if(l.value=!1,!e.multiple||!S.value)return;w.value=[...w.value,Ka(e,S.value)],S.value=""}}),O(()=>{const T=!!(e.chips||n.chip);return d(ii,{ref:o,modelValue:S.value,"onUpdate:modelValue":[L=>S.value=L,L=>{L==null&&(w.value=[])}],validationValue:e.modelValue,class:["v-combobox",{"v-combobox--active-menu":l.value,"v-combobox--chips":!!e.chips,"v-combobox--selecting-index":c.value>-1,[`v-combobox--${e.multiple?"multiple":"single"}`]:!0}],appendInnerIcon:e.items.length?e.menuIcon:void 0,"onClick:clear":y,"onClick:control":_,"onClick:input":_,onFocus:()=>r.value=!0,onBlur:()=>r.value=!1,onKeydown:M},{...n,default:()=>{var L,B;return d(pe,null,[d(xo,oe({modelValue:l.value,"onUpdate:modelValue":F=>l.value=F,activator:"parent",contentClass:"v-combobox__content",eager:e.eager,openOnClick:!1,closeOnContentClick:!1,transition:e.transition,onAfterLeave:I},e.menuProps),{default:()=>[d(yo,{selected:j.value,selectStrategy:e.multiple?"independent":"single-independent",onMousedown:F=>F.preventDefault()},{default:()=>[!k.value.length&&!e.hideNoData&&((L=(B=n["no-data"])==null?void 0:B.call(n))!=null?L:d(Nt,{title:i(e.noDataText)},null)),k.value.map((F,$)=>{var N,K;let{item:de,matches:Z}=F;return(N=(K=n.item)==null?void 0:K.call(n,{item:de,index:$,props:oe(de.props,{onClick:()=>J(de)})}))!=null?N:d(Nt,oe({key:$},de.props,{onClick:()=>J(de)}),{prepend:te=>{let{isSelected:fe}=te;return e.multiple?d(vn,{modelValue:fe,ripple:!1},null):void 0},title:()=>{var te,fe;return s.value?de.title:ly(de.title,Z.title,(te=(fe=S.value)==null?void 0:fe.length)!=null?te:0)}})})]})]}),P.value.map((F,$)=>{function N(de){de.stopPropagation(),de.preventDefault(),J(F)}const K={"onClick:close":N,modelValue:!0};return d("div",{key:$,class:["v-combobox__selection",$===c.value&&["v-combobox__selection--selected",p.value]],style:$===c.value?b.value:{}},[T?d(Le,{defaults:{VChip:{closable:e.closableChips,size:"small",text:F.title}}},{default:()=>[n.chip?n.chip({item:F,index:$,props:K}):d(ri,K,null)]}):n.selection?n.selection({item:F,index:$}):d("span",{class:"v-combobox__selection-text"},[F.title,e.multiple&&$<P.value.length-1&&d("span",{class:"v-combobox__selection-comma"},[ei(",")])])])})])}})}),Qt({isFocused:r,isPristine:s,menu:l,search:S,selectionIndex:c,filteredItems:k,select:J},o)}});const uy=Fe()({name:"VDialog",inheritAttrs:!1,props:{fullscreen:Boolean,origin:{type:String,default:"center center"},retainFocus:{type:Boolean,default:!0},scrollable:Boolean,modelValue:Boolean,...wt({width:"auto"}),...dt({transition:{component:ho}})},emits:{"update:modelValue":e=>!0},setup(e,t){let{attrs:a,slots:n}=t;const i=he(e,"modelValue"),{dimensionStyles:o}=kt(e),{scopeId:r}=ko(),s=D();function l(c){var u,h;const m=c.relatedTarget,f=c.target;if(m!==f&&(u=s.value)!=null&&u.contentEl&&(h=s.value)!=null&&h.isTop&&![document,s.value.contentEl].includes(f)&&!s.value.contentEl.contains(f)){const p=[...s.value.contentEl.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')].filter(v=>!v.hasAttribute("disabled"));if(!p.length)return;const b=p[0],w=p[p.length-1];m===b?w.focus():b.focus()}}return Pe&&re(()=>i.value&&e.retainFocus,c=>{c?document.addEventListener("focusin",l):document.removeEventListener("focusin",l)},{immediate:!0}),re(i,async c=>{if(await Ee(),c){var u;(u=s.value.contentEl)==null||u.focus({preventScroll:!0})}else{var h;(h=s.value.activatorEl)==null||h.focus({preventScroll:!0})}}),O(()=>d(si,oe({modelValue:i.value,"onUpdate:modelValue":c=>i.value=c,class:["v-dialog",{"v-dialog--fullscreen":e.fullscreen,"v-dialog--scrollable":e.scrollable}],style:o.value,transition:e.transition,ref:s,"aria-role":"dialog","aria-modal":"true",activatorProps:{"aria-haspopup":"dialog","aria-expanded":String(i.value)},"z-index":2400},r,a),{default:n.default,activator:n.activator})),{}}});const Yn=Symbol.for("vuetify:v-expansion-panel"),dy=["default","accordion","inset","popout"],hy=H({name:"VExpansionPanels",props:{color:String,variant:{type:String,default:"default",validator:e=>dy.includes(e)},readonly:Boolean,...pn(),...le(),...ve()},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;za(e,Yn);const{themeClasses:n}=ke(e),i=g(()=>e.variant&&`v-expansion-panels--variant-${e.variant}`);return Ue({VExpansionPanel:{color:z(e,"color")},VExpansionPanelTitle:{readonly:z(e,"readonly")}}),O(()=>d(e.tag,{class:["v-expansion-panels",n.value,i.value]},a)),{}}}),ph=me({color:String,expandIcon:{type:se,default:"$expand"},collapseIcon:{type:se,default:"$collapse"},hideActions:Boolean,ripple:{type:[Boolean,Object],default:!1},readonly:Boolean}),gh=H({name:"VExpansionPanelTitle",directives:{Ripple:fa},props:{...ph()},setup(e,t){let{slots:a}=t;const n=we(Yn);if(!n)throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");const{backgroundColorClasses:i,backgroundColorStyles:o}=Be(e,"color"),r=g(()=>({collapseIcon:e.collapseIcon,disabled:n.disabled.value,expanded:n.isSelected.value,expandIcon:e.expandIcon,readonly:e.readonly}));return O(()=>{var s;return Me(d("button",{class:["v-expansion-panel-title",{"v-expansion-panel-title--active":n.isSelected.value},i.value],style:o.value,type:"button",tabindex:n.disabled.value?-1:void 0,disabled:n.disabled.value,"aria-expanded":n.isSelected.value,onClick:e.readonly?void 0:n.toggle},[d("div",{class:"v-expansion-panel-title__overlay"},null),(s=a.default)==null?void 0:s.call(a,r.value),!e.hideActions&&d("div",{class:"v-expansion-panel-title__icon"},[a.actions?a.actions(r.value):d(Te,{icon:n.isSelected.value?e.collapseIcon:e.expandIcon},null)])]),[[ct("ripple"),e.ripple]])}),{}}}),vh=H({name:"VExpansionPanelText",props:{...wo()},setup(e,t){let{slots:a}=t;const n=we(Yn);if(!n)throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");const{hasContent:i,onAfterLeave:o}=bs(e,n.isSelected);return O(()=>{var r;return d(mo,{onAfterLeave:o},{default:()=>[Me(d("div",{class:"v-expansion-panel-text"},[a.default&&i.value&&d("div",{class:"v-expansion-panel-text__wrapper"},[(r=a.default)==null?void 0:r.call(a)])]),[[Et,n.isSelected.value]])]})}),{}}}),my=H({name:"VExpansionPanel",props:{title:String,text:String,bgColor:String,...He(),...Va(),...wo(),...Ie(),...le(),...ph()},setup(e,t){let{slots:a}=t;const n=gn(e,Yn),{backgroundColorClasses:i,backgroundColorStyles:o}=Be(e,"bgColor"),{elevationClasses:r}=qe(e),{roundedClasses:s}=Re(e),l=g(()=>(n==null?void 0:n.disabled.value)||e.disabled),c=g(()=>n.group.items.value.reduce((m,f,p)=>(n.group.selected.value.includes(f.id)&&m.push(p),m),[])),u=g(()=>{const m=n.group.items.value.findIndex(f=>f.id===n.id);return!n.isSelected.value&&c.value.some(f=>f-m===1)}),h=g(()=>{const m=n.group.items.value.findIndex(f=>f.id===n.id);return!n.isSelected.value&&c.value.some(f=>f-m===-1)});return Oe(Yn,n),O(()=>{var m;const f=!!(a.text||e.text),p=!!(a.title||e.title);return d(e.tag,{class:["v-expansion-panel",{"v-expansion-panel--active":n.isSelected.value,"v-expansion-panel--before-active":u.value,"v-expansion-panel--after-active":h.value,"v-expansion-panel--disabled":l.value},s.value,i.value],style:o.value,"aria-expanded":n.isSelected.value},{default:()=>[d("div",{class:["v-expansion-panel__shadow",...r.value]},null),p&&d(gh,{key:"title",collapseIcon:e.collapseIcon,color:e.color,expandIcon:e.expandIcon,hideActions:e.hideActions,ripple:e.ripple},{default:()=>[a.title?a.title():e.title]}),f&&d(vh,{key:"text",eager:e.eager},{default:()=>[a.text?a.text():e.text]}),(m=a.default)==null?void 0:m.call(a)]})}),{}}});const fy=H({name:"VFileInput",inheritAttrs:!1,props:{chips:Boolean,counter:Boolean,counterSizeString:{type:String,default:"$vuetify.fileInput.counterSize"},counterString:{type:String,default:"$vuetify.fileInput.counter"},multiple:Boolean,hint:String,persistentHint:Boolean,placeholder:String,showSize:{type:[Boolean,Number],default:!1,validator:e=>typeof e=="boolean"||[1e3,1024].includes(e)},...Xt(),prependIcon:{type:se,default:"$file"},modelValue:{type:Array,default:()=>[],validator:e=>vt(e).every(t=>t!=null&&typeof t=="object")},...po({clearable:!0})},emits:{"click:clear":e=>!0,"click:control":e=>!0,"update:modelValue":e=>!0},setup(e,t){let{attrs:a,emit:n,slots:i}=t;const{t:o}=Kt(),r=he(e,"modelValue"),s=g(()=>typeof e.showSize!="boolean"?e.showSize:void 0),l=g(()=>{var P;return((P=r.value)!=null?P:[]).reduce((j,x)=>{let{size:y=0}=x;return j+y},0)}),c=g(()=>fl(l.value,s.value)),u=g(()=>{var P;return((P=r.value)!=null?P:[]).map(j=>{const{name:x="",size:y=0}=j;return e.showSize?`${x} (${fl(y,s.value)})`:x})}),h=g(()=>{var P,j;const x=(P=(j=r.value)==null?void 0:j.length)!=null?P:0;return e.showSize?o(e.counterSizeString,x,c.value):o(e.counterString,x)}),m=D(),f=D(),p=D(!1),b=D(),w=g(()=>e.messages.length?e.messages:e.persistentHint?e.hint:"");function v(){if(b.value!==document.activeElement){var P;(P=b.value)==null||P.focus()}p.value||(p.value=!0)}function S(P){var j;(j=b.value)==null||j.click(),n("click:control",P)}function k(P){P.stopPropagation(),v(),Ee(()=>{r.value=[],b!=null&&b.value&&(b.value.value=""),n("click:clear",P)})}return O(()=>{const P=!!(i.counter||e.counter),[j,x]=Ba(a),[{modelValue:y,..._}]=pa(e),[M]=ms(e);return d(Ft,oe({ref:m,modelValue:r.value,"onUpdate:modelValue":I=>r.value=I,class:"v-file-input"},j,_,{"onClick:prepend":S,messages:w.value}),{...i,default:I=>{let{isDisabled:J,isDirty:T,isReadonly:L,isValid:B}=I;return d(ni,oe({ref:f,"prepend-icon":e.prependIcon,"onClick:control":S,"onClick:clear":k},M,{active:T.value||p.value,dirty:T.value,focused:p.value,error:B.value===!1}),{...i,default:F=>{let{props:{class:$,...N}}=F;return d(pe,null,[d("input",oe({ref:b,type:"file",readonly:L.value,disabled:J.value,multiple:e.multiple,name:e.name,onClick:K=>{K.stopPropagation(),v()},onChange:K=>{var de;if(!K.target)return;const Z=K.target;r.value=[...(de=Z.files)!=null?de:[]]},onFocus:v,onBlur:()=>p.value=!1},N,x),null),r.value.length>0&&d("div",{class:$},[i.selection?i.selection({fileNames:u.value,totalBytes:l.value,totalBytesReadable:c.value}):e.chips?u.value.map(K=>d(ri,{key:K,size:"small",color:e.color},{default:()=>[K]})):u.value.join(", ")])])}})},details:P?()=>d(pe,null,[d("span",null,null),d(go,{active:!!r.value.length,value:h.value},i.counter)]):void 0})}),Qt({},m,f,b)}});const py=H({name:"VFooter",props:{app:Boolean,color:String,height:{type:[Number,String],default:"auto"},...ht(),...He(),...rn(),...Ie(),...le({tag:"footer"}),...ve()},setup(e,t){let{slots:a}=t;const{themeClasses:n}=ke(e),{backgroundColorClasses:i,backgroundColorStyles:o}=Be(z(e,"color")),{borderClasses:r}=xt(e),{elevationClasses:s}=qe(e),{roundedClasses:l}=Re(e),c=D(32),{resizeRef:u}=an(f=>{!f.length||(c.value=f[0].target.clientHeight)}),h=g(()=>e.height==="auto"?c.value:parseInt(e.height,10)),{layoutItemStyles:m}=sn({id:e.name,order:g(()=>parseInt(e.order,10)),position:g(()=>"bottom"),layoutSize:h,elementSize:g(()=>e.height==="auto"?void 0:h.value),active:g(()=>e.app),absolute:z(e,"absolute")});return O(()=>d(e.tag,{ref:u,class:["v-footer",n.value,i.value,r.value,s.value,l.value],style:[o,e.app?m.value:void 0]},a)),{}}}),gy=H({name:"VForm",props:{...av()},emits:{"update:modelValue":e=>!0,submit:e=>!0},setup(e,t){let{slots:a,emit:n}=t;const i=nv(e),o=D();function r(l){l.preventDefault(),i.reset()}function s(l){const c=l,u=i.validate();c.then=u.then.bind(u),c.catch=u.catch.bind(u),c.finally=u.finally.bind(u),n("submit",c),c.defaultPrevented||u.then(h=>{let{valid:m}=h;if(m){var f;(f=o.value)==null||f.submit()}}),c.preventDefault()}return O(()=>{var l;return d("form",{ref:o,class:"v-form",novalidate:!0,onReset:r,onSubmit:s},[(l=a.default)==null?void 0:l.call(a,i)])}),Qt(i,o)}}),vy=H({name:"VHover",props:{disabled:Boolean,modelValue:{type:Boolean,default:void 0},...qd()},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const n=he(e,"modelValue"),{runOpenDelay:i,runCloseDelay:o}=Kd(e,r=>!e.disabled&&(n.value=r));return()=>{var r;return(r=a.default)==null?void 0:r.call(a,{isHovering:n.value,props:{onMouseenter:i,onMouseleave:o}})}}});const bh=Symbol.for("vuetify:v-item-group"),by=H({name:"VItemGroup",props:{...pn({selectedClass:"v-item--selected"}),...le(),...ve()},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const{themeClasses:n}=ke(e),{isSelected:i,select:o,next:r,prev:s,selected:l}=za(e,bh);return()=>{var c;return d(e.tag,{class:["v-item-group",n.value]},{default:()=>[(c=a.default)==null?void 0:c.call(a,{isSelected:i,select:o,next:r,prev:s,selected:l.value})]})}}}),yy=Fe()({name:"VItem",props:Va(),setup(e,t){let{slots:a}=t;const{isSelected:n,select:i,toggle:o,selectedClass:r,value:s,disabled:l}=gn(e,bh);return()=>{var c;return(c=a.default)==null?void 0:c.call(a,{isSelected:n.value,selectedClass:r.value,select:i,toggle:o,value:s.value,disabled:l.value})}}});const wy=ut("v-kbd");const ky=H({name:"VLayout",props:Eu(),setup(e,t){let{slots:a}=t;const{layoutClasses:n,layoutStyles:i,getLayoutItem:o,items:r,layoutRef:s}=Bu(e);return O(()=>{var l;return d("div",{ref:s,class:n.value,style:i.value},[(l=a.default)==null?void 0:l.call(a)])}),{getLayoutItem:o,items:r}}});const xy=H({name:"VLayoutItem",props:{position:{type:String,required:!0},size:{type:[Number,String],default:300},modelValue:Boolean,...rn()},setup(e,t){let{slots:a}=t;const{layoutItemStyles:n}=sn({id:e.name,order:g(()=>parseInt(e.order,10)),position:z(e,"position"),elementSize:z(e,"size"),layoutSize:z(e,"size"),active:z(e,"modelValue"),absolute:z(e,"absolute")});return()=>{var i;return d("div",{class:["v-layout-item"],style:n.value},[(i=a.default)==null?void 0:i.call(a)])}}}),Cy=H({name:"VLazy",directives:{intersect:co},props:{modelValue:Boolean,options:{type:Object,default:()=>({root:void 0,rootMargin:void 0,threshold:void 0})},...wt(),...le(),...dt({transition:"fade-transition"})},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const{dimensionStyles:n}=kt(e),i=he(e,"modelValue");function o(r){i.value||(i.value=r)}return O(()=>{var r;return Me(d(e.tag,{class:"v-lazy",style:n.value},{default:()=>[i.value&&d(Tt,{transition:e.transition},{default:()=>[(r=a.default)==null?void 0:r.call(a)]})]}),[[ct("intersect"),o,e.options]])}),{}}});const Sy=H({name:"VLocaleProvider",props:{locale:String,fallbackLocale:String,messages:Object,rtl:{type:Boolean,default:void 0}},setup(e,t){let{slots:a}=t;const n=ag(e),{rtlClasses:i}=tg(e,n);return O(()=>{var o;return d("div",{class:["v-locale-provider",i.value]},[(o=a.default)==null?void 0:o.call(a)])}),{}}});const _y=H({name:"VMain",props:le({tag:"main"}),setup(e,t){let{slots:a}=t;const{mainStyles:n}=bg(),{ssrBootStyles:i}=bo();return O(()=>{var o;return d(e.tag,{class:"v-main",style:[n.value,i.value]},{default:()=>[d("div",{class:"v-main__wrap"},[(o=a.default)==null?void 0:o.call(a)])]})}),{}}});const Ty=100,jy=20;function ql(e){const t=1.41421356237;return(e<0?-1:1)*Math.sqrt(Math.abs(e))*t}function Kl(e){if(e.length<2)return 0;if(e.length===2)return e[1].t===e[0].t?0:(e[1].d-e[0].d)/(e[1].t-e[0].t);let t=0;for(let a=e.length-1;a>0;a--){if(e[a].t===e[a-1].t)continue;const n=ql(t),i=(e[a].d-e[a-1].d)/(e[a].t-e[a-1].t);t+=(i-n)*Math.abs(i),a===e.length-1&&(t*=.5)}return ql(t)*1e3}function Py(){const e={};function t(i){Array.from(i.changedTouches).forEach(o=>{var r;((r=e[o.identifier])!=null?r:e[o.identifier]=new gp(jy)).push([i.timeStamp,o])})}function a(i){Array.from(i.changedTouches).forEach(o=>{delete e[o.identifier]})}function n(i){var o;const r=(o=e[i])==null?void 0:o.values().reverse();if(!r)throw new Error(`No samples for touch id ${i}`);const s=r[0],l=[],c=[];for(const u of r){if(s[0]-u[0]>Ty)break;l.push({t:u[0],d:u[1].clientX}),c.push({t:u[0],d:u[1].clientY})}return{x:Kl(l),y:Kl(c),get direction(){const{x:u,y:h}=this,[m,f]=[Math.abs(u),Math.abs(h)];return m>f&&u>=0?"right":m>f&&u<=0?"left":f>m&&h>=0?"down":f>m&&h<=0?"up":Iy()}}}return{addMovement:t,endTouch:a,getVelocity:n}}function Iy(){throw new Error}function Ay(e){let{isActive:t,isTemporary:a,width:n,touchless:i,position:o}=e;yt(()=>{window.addEventListener("touchstart",v,{passive:!0}),window.addEventListener("touchmove",S,{passive:!1}),window.addEventListener("touchend",k,{passive:!0})}),lt(()=>{window.removeEventListener("touchstart",v),window.removeEventListener("touchmove",S),window.removeEventListener("touchend",k)});const r=g(()=>o.value!=="bottom"),{addMovement:s,endTouch:l,getVelocity:c}=Py();let u=!1;const h=D(!1),m=D(0),f=D(0);let p;function b(j,x){return(o.value==="left"?j:o.value==="right"?document.documentElement.clientWidth-j:o.value==="bottom"?document.documentElement.clientHeight-j:Ua())-(x?n.value:0)}function w(j){let x=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;const y=o.value==="left"?(j-f.value)/n.value:o.value==="right"?(document.documentElement.clientWidth-j-f.value)/n.value:o.value==="bottom"?(document.documentElement.clientHeight-j-f.value)/n.value:Ua();return x?Math.max(0,Math.min(1,y)):y}function v(j){if(i.value)return;const x=j.changedTouches[0].clientX,y=j.changedTouches[0].clientY,_=25,M=o.value==="left"?x<_:o.value==="right"?x>document.documentElement.clientWidth-_:o.value==="bottom"?y>document.documentElement.clientHeight-_:Ua(),I=t.value&&(o.value==="left"?x<n.value:o.value==="right"?x>document.documentElement.clientWidth-n.value:o.value==="bottom"?y>document.documentElement.clientHeight-n.value:Ua());(M||I||t.value&&a.value)&&(u=!0,p=[x,y],f.value=b(r.value?x:y,t.value),m.value=w(r.value?x:y),l(j),s(j))}function S(j){const x=j.changedTouches[0].clientX,y=j.changedTouches[0].clientY;if(u){if(!j.cancelable){u=!1;return}const M=Math.abs(x-p[0]),I=Math.abs(y-p[1]);(r.value?M>I&&M>3:I>M&&I>3)?(h.value=!0,u=!1):(r.value?I:M)>3&&(u=!1)}if(!h.value)return;j.preventDefault(),s(j);const _=w(r.value?x:y,!1);m.value=Math.max(0,Math.min(1,_)),_>1?f.value=b(r.value?x:y,!0):_<0&&(f.value=b(r.value?x:y,!1))}function k(j){if(u=!1,!h.value)return;s(j),h.value=!1;const x=c(j.changedTouches[0].identifier),y=Math.abs(x.x),_=Math.abs(x.y);(r.value?y>_&&y>400:_>y&&_>3)?t.value=x.direction===({left:"right",right:"left",bottom:"up"}[o.value]||Ua()):t.value=m.value>.5}const P=g(()=>h.value?{transform:o.value==="left"?`translateX(calc(-100% + ${m.value*n.value}px))`:o.value==="right"?`translateX(calc(100% - ${m.value*n.value}px))`:o.value==="bottom"?`translateY(calc(100% - ${m.value*n.value}px))`:Ua(),transition:"none"}:void 0);return{isDragging:h,dragProgress:m,dragStyles:P}}function Ua(){throw new Error}const My=H({name:"VNavigationDrawer",props:{color:String,disableResizeWatcher:Boolean,disableRouteWatcher:Boolean,expandOnHover:Boolean,floating:Boolean,modelValue:{type:Boolean,default:null},permanent:Boolean,rail:Boolean,railWidth:{type:[Number,String],default:72},image:String,temporary:Boolean,touchless:Boolean,width:{type:[Number,String],default:256},location:{type:String,default:"left",validator:e=>["left","right","bottom"].includes(e)},...ht(),...He(),...rn(),...Ie(),...le({tag:"nav"}),...ve()},emits:{"update:modelValue":e=>!0},setup(e,t){let{attrs:a,slots:n}=t;const{themeClasses:i}=ke(e),{borderClasses:o}=xt(e),{backgroundColorClasses:r,backgroundColorStyles:s}=Be(z(e,"color")),{elevationClasses:l}=qe(e),{mobile:c}=Qr(),{roundedClasses:u}=Re(e),h=ad(),m=he(e,"modelValue",null,I=>!!I),f=D(!1),{ssrBootStyles:p}=bo(),b=g(()=>e.rail&&e.expandOnHover&&f.value?Number(e.width):Number(e.rail?e.railWidth:e.width)),w=g(()=>!e.permanent&&(c.value||e.temporary));e.disableResizeWatcher||re(w,I=>!e.permanent&&(m.value=!I)),!e.disableRouteWatcher&&h&&re(h.currentRoute,()=>w.value&&(m.value=!1)),re(()=>e.permanent,I=>{I&&(m.value=!0)}),ao(()=>{e.modelValue!=null||w.value||(m.value=e.permanent||!c.value)});const v=D(),{isDragging:S,dragProgress:k,dragStyles:P}=Ay({isActive:m,isTemporary:w,width:b,touchless:z(e,"touchless"),position:z(e,"location")}),j=g(()=>{const I=w.value?0:e.rail&&e.expandOnHover?Number(e.railWidth):b.value;return S.value?I*k.value:I}),{layoutItemStyles:x,layoutRect:y,layoutItemScrimStyles:_}=sn({id:e.name,order:g(()=>parseInt(e.order,10)),position:z(e,"location"),layoutSize:j,elementSize:b,active:g(()=>m.value||S.value),disableTransitions:g(()=>S.value),absolute:z(e,"absolute")}),M=g(()=>({...S.value?{opacity:k.value*.2,transition:"none"}:void 0,...y.value?{left:Q(y.value.left),right:Q(y.value.right),top:Q(y.value.top),bottom:Q(y.value.bottom)}:void 0,..._.value}));return O(()=>{var I,J,T,L;const B=n.image||e.image;return d(pe,null,[d(e.tag,oe({ref:v,onMouseenter:()=>f.value=!0,onMouseleave:()=>f.value=!1,class:["v-navigation-drawer",{"v-navigation-drawer--bottom":e.location==="bottom","v-navigation-drawer--end":e.location==="right","v-navigation-drawer--expand-on-hover":e.expandOnHover,"v-navigation-drawer--floating":e.floating,"v-navigation-drawer--is-hovering":f.value,"v-navigation-drawer--rail":e.rail,"v-navigation-drawer--start":e.location==="left","v-navigation-drawer--temporary":w.value,"v-navigation-drawer--active":m.value},i.value,r.value,o.value,l.value,u.value],style:[s.value,x.value,P.value,p.value]},a),{default:()=>[B&&d("div",{key:"image",class:"v-navigation-drawer__img"},[n.image?(I=n.image)==null?void 0:I.call(n,{image:e.image}):d("img",{src:e.image,alt:""},null)]),n.prepend&&d("div",{class:"v-navigation-drawer__prepend"},[(J=n.prepend)==null?void 0:J.call(n)]),d("div",{class:"v-navigation-drawer__content"},[(T=n.default)==null?void 0:T.call(n)]),n.append&&d("div",{class:"v-navigation-drawer__append"},[(L=n.append)==null?void 0:L.call(n)])]}),d(Dt,{name:"fade-transition"},{default:()=>[w.value&&(S.value||m.value)&&d("div",{class:"v-navigation-drawer__scrim",style:M.value,onClick:()=>m.value=!1},null)]})])}),{}}});function Jy(e){var t,a,n;if(!Pe)return;const i=Ke("useHydration"),o=i==null||(t=i.root)==null||(a=t.appContext)==null||(n=a.app)==null?void 0:n._container;return o!=null&&o.__vue_app__?e():yt(e)}const Ly=H({name:"VNoSsr",setup(e,t){let{slots:a}=t;const n=D(!1);return Jy(()=>n.value=!0),()=>{var i;return n.value&&((i=a.default)==null?void 0:i.call(a))}}});function Dy(){const e=D([]);Bc(()=>e.value=[]);function t(a,n){e.value[n]=a}return{refs:e,updateRef:t}}const Ey=H({name:"VPagination",props:{start:{type:[Number,String],default:1},modelValue:{type:Number,default:e=>e.start},disabled:Boolean,length:{type:[Number,String],default:1,validator:e=>e%1===0},totalVisible:[Number,String],firstIcon:{type:se,default:"$first"},prevIcon:{type:se,default:"$prev"},nextIcon:{type:se,default:"$next"},lastIcon:{type:se,default:"$last"},ariaLabel:{type:String,default:"$vuetify.pagination.ariaLabel.root"},pageAriaLabel:{type:String,default:"$vuetify.pagination.ariaLabel.page"},currentPageAriaLabel:{type:String,default:"$vuetify.pagination.ariaLabel.currentPage"},firstAriaLabel:{type:String,default:"$vuetify.pagination.ariaLabel.first"},previousAriaLabel:{type:String,default:"$vuetify.pagination.ariaLabel.previous"},nextAriaLabel:{type:String,default:"$vuetify.pagination.ariaLabel.next"},lastAriaLabel:{type:String,default:"$vuetify.pagination.ariaLabel.last"},ellipsis:{type:String,default:"..."},showFirstLastPage:Boolean,...ht(),...Ge(),...He(),...Ie(),...Yt(),...le({tag:"nav"}),...ve(),...Pt({variant:"text"})},emits:{"update:modelValue":e=>!0,first:e=>!0,prev:e=>!0,next:e=>!0,last:e=>!0},setup(e,t){let{slots:a,emit:n}=t;const i=he(e,"modelValue"),{t:o,n:r}=Kt(),{isRtl:s}=ma(),{themeClasses:l}=ke(e),c=D(-1);Ue(void 0,{scoped:!0});const{resizeRef:u}=an(x=>{if(!x.length)return;const{target:y,contentRect:_}=x[0],M=y.querySelector(".v-pagination__list > *");if(!M)return;const I=_.width,J=M.getBoundingClientRect().width+10;c.value=Math.max(0,Math.floor((I-96)/J))}),h=g(()=>parseInt(e.length,10)),m=g(()=>parseInt(e.start,10)),f=g(()=>{var x;return e.totalVisible?Math.min(parseInt((x=e.totalVisible)!=null?x:"",10),h.value):c.value>=0?c.value:h.value}),p=g(()=>{if(h.value<=0)return[];if(f.value<=2)return[i.value];if(h.value<=f.value)return _a(h.value,m.value);const x=f.value%2===0,y=x?f.value/2:Math.floor(f.value/2),_=x?y:y+1,M=h.value-y;if(_-i.value>=0)return[..._a(Math.max(1,f.value-1),m.value),e.ellipsis,h.value];if(i.value-M>=0){const I=f.value-1,J=h.value-I+m.value;return[m.value,e.ellipsis,..._a(I,J)]}else{const I=Math.max(1,f.value-3),J=I===1?i.value:i.value-Math.ceil(I/2)+m.value;return[m.value,e.ellipsis,..._a(I,J),e.ellipsis,h.value]}});function b(x,y,_){x.preventDefault(),i.value=y,_&&n(_,y)}const{refs:w,updateRef:v}=Dy();Ue({VBtn:{border:z(e,"border"),density:z(e,"density"),size:z(e,"size"),variant:z(e,"variant")}});const S=g(()=>p.value.map((x,y)=>{const _=M=>v(M,y);if(typeof x=="string")return{isActive:!1,page:x,props:{ref:_,ellipsis:!0,icon:!0,disabled:!0}};{const M=x===i.value;return{isActive:M,page:r(x),props:{ref:_,ellipsis:!1,icon:!0,disabled:!!e.disabled||e.length<2,elevation:e.elevation,rounded:e.rounded,color:M?e.color:void 0,ariaCurrent:M,ariaLabel:o(M?e.currentPageAriaLabel:e.pageAriaLabel,y+1),onClick:I=>b(I,x)}}}})),k=g(()=>{const x=!!e.disabled||i.value<=m.value,y=!!e.disabled||i.value>=m.value+h.value-1;return{first:e.showFirstLastPage?{icon:s.value?e.lastIcon:e.firstIcon,onClick:_=>b(_,m.value,"first"),disabled:x,ariaLabel:o(e.firstAriaLabel),ariaDisabled:x}:void 0,prev:{icon:s.value?e.nextIcon:e.prevIcon,onClick:_=>b(_,i.value-1,"prev"),disabled:x,ariaLabel:o(e.previousAriaLabel),ariaDisabled:x},next:{icon:s.value?e.prevIcon:e.nextIcon,onClick:_=>b(_,i.value+1,"next"),disabled:y,ariaLabel:o(e.nextAriaLabel),ariaDisabled:y},last:e.showFirstLastPage?{icon:s.value?e.firstIcon:e.lastIcon,onClick:_=>b(_,m.value+h.value-1,"last"),disabled:y,ariaLabel:o(e.lastAriaLabel),ariaDisabled:y}:void 0}});function P(){var x;const y=i.value-m.value;(x=w.value[y])==null||x.$el.focus()}function j(x){x.key===er.left&&!e.disabled&&i.value>e.start?(i.value=i.value-1,Ee(P)):x.key===er.right&&!e.disabled&&i.value<m.value+h.value-1&&(i.value=i.value+1,Ee(P))}return O(()=>d(e.tag,{ref:u,class:["v-pagination",l.value],role:"navigation","aria-label":o(e.ariaLabel),onKeydown:j,"data-test":"v-pagination-root"},{default:()=>[d("ul",{class:"v-pagination__list"},[e.showFirstLastPage&&d("li",{key:"first",class:"v-pagination__first","data-test":"v-pagination-first"},[a.first?a.first(k.value.first):d(rt,k.value.first,null)]),d("li",{class:"v-pagination__prev","data-test":"v-pagination-prev"},[a.prev?a.prev(k.value.prev):d(rt,k.value.prev,null)]),S.value.map((x,y)=>d("li",{key:`${y}_${x.page}`,class:["v-pagination__item",{"v-pagination__item--is-active":x.isActive}],"data-test":"v-pagination-item"},[a.item?a.item(x):d(rt,x.props,{default:()=>[x.page]})])),d("li",{class:"v-pagination__next","data-test":"v-pagination-next"},[a.next?a.next(k.value.next):d(rt,k.value.next,null)]),e.showFirstLastPage&&d("li",{key:"last",class:"v-pagination__last","data-test":"v-pagination-last"},[a.last?a.last(k.value.last):d(rt,k.value.last,null)])])]})),{}}});function By(e){return Math.floor(Math.abs(e))*Math.sign(e)}const Fy=H({name:"VParallax",props:{scale:{type:[Number,String],default:1.3}},setup(e,t){let{slots:a}=t;const{intersectionRef:n,isIntersecting:i}=ts(),o=D();$t(()=>{var c;n.value=(c=o.value)==null?void 0:c.$el});let r;re(i,c=>{c?(r=Iu(n.value),r=r===document.scrollingElement?document:r,r.addEventListener("scroll",l,{passive:!0}),l()):r.removeEventListener("scroll",l)}),lt(()=>{var c;(c=r)==null||c.removeEventListener("scroll",l)});let s=-1;function l(){!i.value||(cancelAnimationFrame(s),s=requestAnimationFrame(()=>{var c,u,h;const m=((c=o.value)==null?void 0:c.$el).querySelector(".v-img__img");if(!m)return;const f=n.value.getBoundingClientRect(),p=(u=r.clientHeight)!=null?u:window.innerHeight,b=(h=r.scrollTop)!=null?h:window.scrollY,w=f.top+b,v=(b+p-w)/(f.height+p),S=By((f.height*+e.scale-f.height)*(-v+.5));m.style.setProperty("transform",`translateY(${S}px) scale(${e.scale})`)}))}return O(()=>d(cn,{class:["v-parallax",{"v-parallax--active":i.value}],ref:o,cover:!0,onLoadstart:l,onLoad:l},a)),{}}}),Ry=H({name:"VRadio",props:{falseIcon:{type:se,default:"$radioOff"},trueIcon:{type:se,default:"$radioOn"}},setup(e,t){let{slots:a}=t;return O(()=>d(oi,{class:"v-radio",trueIcon:e.trueIcon,falseIcon:e.falseIcon,type:"radio"},a)),{}}});const Vy=H({name:"VRadioGroup",inheritAttrs:!1,props:{height:{type:[Number,String],default:"auto"},...Xt(),...vo(),trueIcon:{type:se,default:"$radioOn"},falseIcon:{type:se,default:"$radioOff"},type:{type:String,default:"radio"}},setup(e,t){let{attrs:a,slots:n}=t;const i=Ye(),o=g(()=>e.id||`radio-group-${i}`);return O(()=>{const[r,s]=Ba(a),[l,c]=pa(e),[u,h]=Id(e),m=n.label?n.label({label:e.label,props:{for:o.value}}):e.label;return d(Ft,oe({class:"v-radio-group"},r,l,{id:o.value}),{...n,default:f=>{let{id:p,isDisabled:b,isReadonly:w}=f;return d(pe,null,[m&&d(fo,{for:p.value},{default:()=>[m]}),d(Pd,oe(u,{id:p.value,trueIcon:e.trueIcon,falseIcon:e.falseIcon,type:e.type,disabled:b.value,readonly:w.value},s),n)])}})}),{}}}),zy=H({name:"VRangeSlider",props:{...ds(),...Xt(),...gd(),strict:Boolean,modelValue:{type:Array,default:()=>[0,0]}},emits:{"update:focused":e=>!0,"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const n=D(),i=D(),o=D();function r(y){if(!n.value||!i.value)return;const _=fr(y,n.value.$el,e.direction),M=fr(y,i.value.$el,e.direction),I=Math.abs(_),J=Math.abs(M);return I<J||I===J&&_<0?n.value.$el:i.value.$el}const{activeThumbRef:s,hasLabels:l,max:c,min:u,mousePressed:h,onSliderMousedown:m,onSliderTouchstart:f,position:p,roundValue:b,trackContainerRef:w}=vd({props:e,handleSliderMouseUp:y=>{var _;v.value=s.value===((_=n.value)==null?void 0:_.$el)?[y,v.value[1]]:[v.value[0],y]},handleMouseMove:y=>{var _;const[M,I]=v.value;if(!e.strict&&M===I&&M!==u.value){var J,T,L;s.value=y>M?(J=i.value)==null?void 0:J.$el:(T=n.value)==null?void 0:T.$el,(L=s.value)==null||L.focus()}s.value===((_=n.value)==null?void 0:_.$el)?v.value=[Math.min(y,I),I]:v.value=[M,Math.max(M,y)]},getActiveThumb:r}),v=he(e,"modelValue",void 0,y=>!y||!y.length?[0,0]:y.map(_=>b(_))),{isFocused:S,focus:k,blur:P}=hs(e),j=g(()=>p(v.value[0])),x=g(()=>p(v.value[1]));return O(()=>{const[y,_]=pa(e);return d(Ft,oe({class:["v-slider","v-range-slider",{"v-slider--has-labels":!!a["tick-label"]||l.value,"v-slider--focused":S.value,"v-slider--pressed":h.value,"v-slider--disabled":e.disabled}],ref:o},y,{focused:S.value}),{...a,default:M=>{var I,J;let{id:T}=M;return d("div",{class:"v-slider__container",onMousedown:m,onTouchstartPassive:f},[d("input",{id:`${T.value}_start`,name:e.name||T.value,disabled:e.disabled,readonly:e.readonly,tabindex:"-1",value:v.value[0]},null),d("input",{id:`${T.value}_stop`,name:e.name||T.value,disabled:e.disabled,readonly:e.readonly,tabindex:"-1",value:v.value[1]},null),d(bd,{ref:w,start:j.value,stop:x.value},{"tick-label":a["tick-label"]}),d(pr,{ref:n,focused:S&&s.value===((I=n.value)==null?void 0:I.$el),modelValue:v.value[0],"onUpdate:modelValue":L=>v.value=[L,v.value[1]],onFocus:L=>{var B,F;if(k(),s.value=(B=n.value)==null?void 0:B.$el,v.value[0]===v.value[1]&&v.value[1]===u.value&&L.relatedTarget!==((F=i.value)==null?void 0:F.$el)){var $,N;($=n.value)==null||$.$el.blur(),(N=i.value)==null||N.$el.focus()}},onBlur:()=>{P(),s.value=void 0},min:u.value,max:v.value[1],position:j.value},{"thumb-label":a["thumb-label"]}),d(pr,{ref:i,focused:S&&s.value===((J=i.value)==null?void 0:J.$el),modelValue:v.value[1],"onUpdate:modelValue":L=>v.value=[v.value[0],L],onFocus:L=>{var B,F;if(k(),s.value=(B=i.value)==null?void 0:B.$el,v.value[0]===v.value[1]&&v.value[0]===c.value&&L.relatedTarget!==((F=n.value)==null?void 0:F.$el)){var $,N;($=i.value)==null||$.$el.blur(),(N=n.value)==null||N.$el.focus()}},onBlur:()=>{P(),s.value=void 0},min:v.value[0],max:c.value,position:x.value},{"thumb-label":a["thumb-label"]})])}})}),{}}});const Hy=Fe()({name:"VRating",props:{name:String,itemAriaLabel:{type:String,default:"$vuetify.rating.ariaLabel.item"},activeColor:String,color:String,clearable:Boolean,disabled:Boolean,emptyIcon:{type:se,default:"$ratingEmpty"},fullIcon:{type:se,default:"$ratingFull"},halfIncrements:Boolean,hover:Boolean,length:{type:[Number,String],default:5},readonly:Boolean,modelValue:{type:Number,default:0},itemLabels:Array,itemLabelPosition:{type:String,default:"top",validator:e=>["top","bottom"].includes(e)},ripple:Boolean,...Ge(),...Yt(),...le(),...ve()},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const{t:n}=Kt(),{themeClasses:i}=ke(e),o=he(e,"modelValue"),r=g(()=>_a(Number(e.length),1)),s=g(()=>r.value.flatMap(k=>e.halfIncrements?[k-.5,k]:[k])),l=D(-1),c=D(-1),u=D();let h=!1;const m=g(()=>s.value.map(k=>{var P;const j=e.hover&&l.value>-1,x=o.value>=k,y=l.value>=k,M=(j?y:x)?e.fullIcon:e.emptyIcon,I=(P=e.activeColor)!=null?P:e.color,J=x||y?I:e.color;return{isFilled:x,isHovered:y,icon:M,color:J}})),f=g(()=>[0,...s.value].map(k=>{function P(){l.value=k}function j(){l.value=-1}function x(){if(k===0&&o.value===0){var M;(M=u.value)==null||M.focus()}else c.value=k}function y(){h||(c.value=-1)}function _(){e.disabled||e.readonly||(o.value=o.value===k&&e.clearable?0:k)}return{onMouseenter:e.hover?P:void 0,onMouseleave:e.hover?j:void 0,onFocus:x,onBlur:y,onClick:_}}));function p(){h=!0}function b(){h=!1}const w=g(()=>{var k;return(k=e.name)!=null?k:`v-rating-${Ye()}`});function v(k){var P,j;let{value:x,index:y,showStar:_=!0}=k;const{onMouseenter:M,onMouseleave:I,onFocus:J,onBlur:T,onClick:L}=f.value[y+1],B=`${w.value}-${String(x).replace(".","-")}`,F={color:(P=m.value[y])==null?void 0:P.color,density:e.density,disabled:e.disabled,icon:(j=m.value[y])==null?void 0:j.icon,ripple:e.ripple,size:e.size,tag:"span",variant:"plain"};return d(pe,null,[d("label",{for:B,class:{"v-rating__item--half":e.halfIncrements&&x%1>0,"v-rating__item--full":e.halfIncrements&&x%1===0},onMousedown:p,onMouseup:b,onMouseenter:M,onMouseleave:I},[d("span",{class:"v-rating__hidden"},[n(e.itemAriaLabel,x,e.length)]),_?a.item?a.item({...m.value[y],props:F,value:x,index:y}):d(rt,F,null):void 0]),d("input",{class:"v-rating__hidden",name:w.value,id:B,type:"radio",value:x,checked:o.value===x,onClick:L,onFocus:J,onBlur:T,ref:y===0?u:void 0,readonly:e.readonly,disabled:e.disabled},null)])}function S(k){return a["item-label"]?a["item-label"](k):k.label?d("span",null,[k.label]):d("span",null,[ei("\xA0")])}return O(()=>{var k;const P=!!((k=e.itemLabels)!=null&&k.length)||a["item-label"];return d(e.tag,{class:["v-rating",{"v-rating--hover":e.hover,"v-rating--readonly":e.readonly},i.value]},{default:()=>[d(v,{value:0,index:-1,showStar:!1},null),r.value.map((j,x)=>{var y,_;return d("div",{class:"v-rating__wrapper"},[P&&e.itemLabelPosition==="top"?S({value:j,index:x,label:(y=e.itemLabels)==null?void 0:y[x]}):void 0,d("div",{class:["v-rating__item",{"v-rating__item--focused":Math.ceil(c.value)===j}]},[e.halfIncrements?d(pe,null,[d(v,{value:j-.5,index:x*2},null),d(v,{value:j,index:x*2+1},null)]):d(v,{value:j,index:x},null)]),P&&e.itemLabelPosition==="bottom"?S({value:j,index:x,label:(_=e.itemLabels)==null?void 0:_[x]}):void 0])})]})}),{}}});function Yl(e){const a=Math.abs(e);return Math.sign(e)*(a/((1/.501-2)*(1-a)+1))}function Xl(e){let{selectedElement:t,containerSize:a,contentSize:n,isRtl:i,currentScrollOffset:o,isHorizontal:r}=e;const s=r?t.clientWidth:t.clientHeight,l=r?t.offsetLeft:t.offsetTop,c=i?n-l-s:l;i&&(o=-o);const u=a+o,h=s+c,m=s*.4;return c<=o?o=Math.max(c-m,0):u<=h&&(o=Math.min(o-(u-h-m),n-a)),i?-o:o}function Oy(e){let{selectedElement:t,containerSize:a,contentSize:n,isRtl:i,isHorizontal:o}=e;const r=o?t.clientWidth:t.clientHeight,s=o?t.offsetLeft:t.offsetTop;if(i){const l=n-s-r/2-a/2;return-Math.min(n-a,Math.max(0,l))}else{const l=s+r/2-a/2;return Math.min(n-a,Math.max(0,l))}}const yh=Symbol.for("vuetify:v-slide-group"),wh=H({name:"VSlideGroup",props:{centerActive:Boolean,direction:{type:String,default:"horizontal"},symbol:{type:null,default:yh},nextIcon:{type:se,default:"$next"},prevIcon:{type:se,default:"$prev"},showArrows:{type:[Boolean,String],validator:e=>typeof e=="boolean"||["always","desktop","mobile"].includes(e)},...le(),...pn({selectedClass:"v-slide-group-item--active"})},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const{isRtl:n}=ma(),{mobile:i}=Qr(),o=za(e,e.symbol),r=D(!1),s=D(0),l=D(0),c=D(0),u=g(()=>e.direction==="horizontal"),{resizeRef:h,contentRect:m}=an(),{resizeRef:f,contentRect:p}=an(),b=g(()=>o.selected.value.length?o.items.value.findIndex(Z=>Z.id===o.selected.value[0]):-1),w=g(()=>o.selected.value.length?o.items.value.findIndex(Z=>Z.id===o.selected.value[o.selected.value.length-1]):-1);if(Pe){let Z=-1;re(()=>[o.selected.value,m.value,p.value,u.value],()=>{cancelAnimationFrame(Z),Z=requestAnimationFrame(()=>{if(m.value&&p.value){const te=u.value?"width":"height";l.value=m.value[te],c.value=p.value[te],r.value=l.value+1<c.value}if(b.value>=0&&f.value){const te=f.value.children[w.value];b.value===0||!r.value?s.value=0:e.centerActive?s.value=Oy({selectedElement:te,containerSize:l.value,contentSize:c.value,isRtl:n.value,isHorizontal:u.value}):r.value&&(s.value=Xl({selectedElement:te,containerSize:l.value,contentSize:c.value,isRtl:n.value,currentScrollOffset:s.value,isHorizontal:u.value}))}})})}const v=D(!1);let S=0,k=0;function P(Z){const te=u.value?"clientX":"clientY";k=s.value,S=Z.touches[0][te],v.value=!0}function j(Z){if(!r.value)return;const te=u.value?"clientX":"clientY";s.value=k+S-Z.touches[0][te]}function x(Z){const te=c.value-l.value;n.value?s.value>0||!r.value?s.value=0:s.value<=-te&&(s.value=-te):s.value<0||!r.value?s.value=0:s.value>=te&&(s.value=te),v.value=!1}function y(){h.value&&(h.value.scrollLeft=0)}const _=D(!1);function M(Z){if(_.value=!0,!(!r.value||!f.value)){for(const te of Z.composedPath())for(const fe of f.value.children)if(fe===te){s.value=Xl({selectedElement:fe,containerSize:l.value,contentSize:c.value,isRtl:n.value,currentScrollOffset:s.value,isHorizontal:u.value});return}}}function I(Z){_.value=!1}function J(Z){var te;!_.value&&!(Z.relatedTarget&&(te=f.value)!=null&&te.contains(Z.relatedTarget))&&L()}function T(Z){!f.value||(Z.key===(u.value?"ArrowRight":"ArrowDown")?L("next"):Z.key===(u.value?"ArrowLeft":"ArrowUp")?L("prev"):Z.key==="Home"?L("first"):Z.key==="End"&&L("last"))}function L(Z){if(!!f.value)if(Z){if(Z==="next"){var fe;const ze=(fe=f.value.querySelector(":focus"))==null?void 0:fe.nextElementSibling;ze?ze.focus():L("first")}else if(Z==="prev"){var Je;const ze=(Je=f.value.querySelector(":focus"))==null?void 0:Je.previousElementSibling;ze?ze.focus():L("last")}else if(Z==="first"){var Y;(Y=f.value.firstElementChild)==null||Y.focus()}else if(Z==="last"){var xe;(xe=f.value.lastElementChild)==null||xe.focus()}}else{var te;f.value.querySelector("[tabindex]"),(te=[...f.value.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')].filter(Qe=>!Qe.hasAttribute("disabled"))[0])==null||te.focus()}}function B(Z){const te=n.value?-1:1,fe=te*s.value+(Z==="prev"?-1:1)*l.value;s.value=te*Lt(fe,0,c.value-l.value)}const F=g(()=>{const Z=s.value<=0?Yl(-s.value):s.value>c.value-l.value?-(c.value-l.value)+Yl(c.value-l.value-s.value):-s.value;return{transform:`translate${u.value?"X":"Y"}(${Z}px)`,transition:v.value?"none":"",willChange:v.value?"transform":""}}),$=g(()=>({next:o.next,prev:o.prev,select:o.select,isSelected:o.isSelected})),N=g(()=>{switch(e.showArrows){case"always":return!0;case"desktop":return!i.value;case!0:return r.value||Math.abs(s.value)>0;case"mobile":return i.value||r.value||Math.abs(s.value)>0;default:return!i.value&&(r.value||Math.abs(s.value)>0)}}),K=g(()=>N.value&&s.value>0),de=g(()=>N.value?c.value>Math.abs(s.value)+l.value:!1);return O(()=>{var Z,te,fe,Je,Y;return d(e.tag,{class:["v-slide-group",{"v-slide-group--vertical":!u.value,"v-slide-group--has-affixes":N.value,"v-slide-group--is-overflowing":r.value}],tabindex:_.value||o.selected.value.length?-1:0,onFocus:J},{default:()=>[N.value&&d("div",{key:"prev",class:["v-slide-group__prev",{"v-slide-group__prev--disabled":!K.value}],onClick:()=>B("prev")},[(Z=(te=a.prev)==null?void 0:te.call(a,$.value))!=null?Z:d(mr,null,{default:()=>[d(Te,{icon:e.prevIcon},null)]})]),d("div",{key:"container",ref:h,class:"v-slide-group__container",onScroll:y},[d("div",{ref:f,class:"v-slide-group__content",style:F.value,onTouchstartPassive:P,onTouchmovePassive:j,onTouchendPassive:x,onFocusin:M,onFocusout:I,onKeydown:T},[(fe=a.default)==null?void 0:fe.call(a,$.value)])]),N.value&&d("div",{key:"next",class:["v-slide-group__next",{"v-slide-group__next--disabled":!de.value}],onClick:()=>B("next")},[(Je=(Y=a.next)==null?void 0:Y.call(a,$.value))!=null?Je:d(mr,null,{default:()=>[d(Te,{icon:e.nextIcon},null)]})])]})}),{selected:o.selected,scrollTo:B,scrollOffset:s,focus:L}}}),Gy=H({name:"VSlideGroupItem",props:{...Va()},setup(e,t){let{slots:a}=t;const n=gn(e,yh);return()=>{var i;return(i=a.default)==null?void 0:i.call(a,{isSelected:n.isSelected.value,select:n.select,toggle:n.toggle,selectedClass:n.selectedClass.value})}}});const Ny=H({name:"VSnackbar",props:{app:Boolean,contentClass:{type:String,default:""},multiLine:Boolean,timeout:{type:[Number,String],default:5e3},vertical:Boolean,modelValue:Boolean,...Fa({location:"bottom"}),...hn(),...Ie(),...Pt(),...dt({transition:"v-snackbar-transition"})},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const n=he(e,"modelValue"),{locationStyles:i}=Ra(e),{positionClasses:o}=mn(e),{scopeId:r}=ko(),{colorClasses:s,colorStyles:l,variantClasses:c}=dn(e),{roundedClasses:u}=Re(e);re(n,m),re(()=>e.timeout,m),yt(()=>{n.value&&m()});let h=-1;function m(){window.clearTimeout(h);const p=Number(e.timeout);!n.value||p===-1||(h=window.setTimeout(()=>{n.value=!1},p))}function f(){window.clearTimeout(h)}O(()=>d(si,oe({modelValue:n.value,"onUpdate:modelValue":p=>n.value=p,class:["v-snackbar",{"v-snackbar--active":n.value,"v-snackbar--multi-line":e.multiLine&&!e.vertical,"v-snackbar--vertical":e.vertical},o.value],style:[l.value],contentProps:{style:i.value},persistent:!0,noClickAnimation:!0,scrim:!1,scrollStrategy:"none",transition:e.transition},r),{default:()=>[d("div",{class:["v-snackbar__wrapper",s.value,u.value,c.value],onPointerenter:f,onPointerleave:m},[un(!1,"v-snackbar"),a.default&&d("div",{class:["v-snackbar__content",e.contentClass],role:"status","aria-live":"polite"},[a.default()]),a.actions&&d(Le,{defaults:{VBtn:{variant:"text",ripple:!1}}},{default:()=>[d("div",{class:"v-snackbar__actions"},[a.actions()])]})])],activator:a.activator}))}});const $y=H({name:"VSwitch",inheritAttrs:!1,props:{indeterminate:Boolean,inset:Boolean,flat:Boolean,loading:{type:[Boolean,String],default:!1},...Xt(),...vo()},emits:{"update:indeterminate":e=>!0},setup(e,t){let{attrs:a,slots:n}=t;const i=he(e,"indeterminate"),{loaderClasses:o}=uo(e),r=g(()=>typeof e.loading=="string"&&e.loading!==""?e.loading:e.color),s=Ye(),l=g(()=>e.id||`switch-${s}`);function c(){i.value&&(i.value=!1)}return O(()=>{const[u,h]=Ba(a),[m,f]=pa(e),[p,b]=Id(e),w=D();function v(){var S,k;(S=w.value)==null||(k=S.input)==null||k.click()}return d(Ft,oe({class:["v-switch",{"v-switch--inset":e.inset},{"v-switch--indeterminate":i.value},o.value]},u,m,{id:l.value}),{...n,default:S=>{let{id:k,isDisabled:P,isReadonly:j,isValid:x}=S;return d(oi,oe({ref:w},p,{id:k.value,type:"checkbox","onUpdate:modelValue":c,"aria-checked":i.value?"mixed":void 0,disabled:P.value,readonly:j.value},h),{...n,default:()=>d("div",{class:"v-switch__track",onClick:v},null),input:y=>{let{textColorClasses:_}=y;return d("div",{class:["v-switch__thumb",_.value]},[e.loading&&d(is,{name:"v-switch",active:!0,color:x.value===!1?void 0:r.value},{default:M=>n.loader?n.loader(M):d(ps,{active:M.isActive,color:M.color,indeterminate:!0,size:"16",width:"2"},null)})])}})}})}),{}}});const Uy=H({name:"VSystemBar",props:{color:String,height:[Number,String],window:Boolean,...He(),...rn(),...Ie(),...le(),...ve()},setup(e,t){let{slots:a}=t;const{themeClasses:n}=ke(e),{backgroundColorClasses:i,backgroundColorStyles:o}=Be(z(e,"color")),{elevationClasses:r}=qe(e),{roundedClasses:s}=Re(e),l=g(()=>{var u;return((u=e.height)!=null?u:e.window)?32:24}),{layoutItemStyles:c}=sn({id:e.name,order:g(()=>parseInt(e.order,10)),position:D("top"),layoutSize:l,elementSize:l,active:g(()=>!0),absolute:z(e,"absolute")});return O(()=>d(e.tag,{class:["v-system-bar",{"v-system-bar--window":e.window},n.value,i.value,r.value,s.value],style:[o.value,c.value]},a)),{}}});const kh=Symbol.for("vuetify:v-tabs"),xh=H({name:"VTab",props:{fixed:Boolean,icon:[Boolean,String,Function,Object],prependIcon:se,appendIcon:se,stacked:Boolean,title:String,ripple:{type:Boolean,default:!0},color:String,sliderColor:String,hideSlider:Boolean,direction:{type:String,default:"horizontal"},...le(),...fn(),...Va({selectedClass:"v-tab--selected"}),...ve()},setup(e,t){let{slots:a,attrs:n}=t;const{textColorClasses:i,textColorStyles:o}=at(e,"sliderColor"),r=g(()=>e.direction==="horizontal"),s=D(!1),l=D(),c=D();function u(h){let{value:m}=h;if(s.value=m,m){var f,p;const b=(f=l.value)==null||(p=f.$el.parentElement)==null?void 0:p.querySelector(".v-tab--selected .v-tab__slider"),w=c.value;if(!b||!w)return;const v=getComputedStyle(b).color,S=b.getBoundingClientRect(),k=w.getBoundingClientRect(),P=r.value?"x":"y",j=r.value?"X":"Y",x=r.value?"right":"bottom",y=r.value?"width":"height",_=S[P],M=k[P],I=_>M?S[x]-k[x]:S[P]-k[P],J=Math.sign(I)>0?r.value?"right":"bottom":Math.sign(I)<0?r.value?"left":"top":"center",L=(Math.abs(I)+(Math.sign(I)<0?S[y]:k[y]))/Math.max(S[y],k[y]),B=S[y]/k[y],F=1.5;w.animate({backgroundColor:[v,""],transform:[`translate${j}(${I}px) scale${j}(${B})`,`translate${j}(${I/F}px) scale${j}(${(L-1)/F+1})`,""],transformOrigin:Array(3).fill(J)},{duration:225,easing:Nn})}}return O(()=>{const[h]=Bt(e,["href","to","replace","icon","stacked","prependIcon","appendIcon","ripple","theme","disabled","selectedClass","value","color"]);return d(rt,oe({_as:"VTab",symbol:kh,ref:l,class:["v-tab"],tabindex:s.value?0:-1,role:"tab","aria-selected":String(s.value),block:e.fixed,maxWidth:e.fixed?300:void 0,variant:"text",rounded:0},h,n,{"onGroup:selected":u}),{default:()=>[a.default?a.default():e.title,!e.hideSlider&&d("div",{ref:c,class:["v-tab__slider",i.value],style:o.value},null)]})}),{}}});function Wy(e){return e?e.map(t=>typeof t=="string"?{title:t,value:t}:t):[]}const qy=H({name:"VTabs",props:{alignWithTitle:Boolean,color:String,direction:{type:String,default:"horizontal"},fixedTabs:Boolean,items:{type:Array,default:()=>[]},stacked:Boolean,backgroundColor:String,centered:Boolean,grow:Boolean,height:{type:[Number,String],default:void 0},hideSlider:Boolean,optional:Boolean,end:Boolean,sliderColor:String,modelValue:null,...Ge(),...le()},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a,emit:n}=t;const i=g(()=>Wy(e.items)),{densityClasses:o}=Xe(e),{backgroundColorClasses:r,backgroundColorStyles:s}=Be(z(e,"backgroundColor"));return Ue({VTab:{color:z(e,"color"),direction:z(e,"direction"),stacked:z(e,"stacked"),fixed:z(e,"fixedTabs"),sliderColor:z(e,"sliderColor"),hideSlider:z(e,"hideSlider")}}),O(()=>d(wh,{class:["v-tabs",`v-tabs--${e.direction}`,{"v-tabs--align-with-title":e.alignWithTitle,"v-tabs--centered":e.centered,"v-tabs--fixed-tabs":e.fixedTabs,"v-tabs--grow":e.grow,"v-tabs--end":e.end,"v-tabs--stacked":e.stacked},o.value,r.value],style:s.value,role:"tablist",symbol:kh,mandatory:"force",direction:e.direction,modelValue:e.modelValue,"onUpdate:modelValue":l=>n("update:modelValue",l)},{default:()=>[a.default?a.default():i.value.map(l=>d(xh,oe(l,{key:l.title}),null))]})),{}}});const Ky=H({name:"VTable",props:{fixedHeader:Boolean,fixedFooter:Boolean,height:[Number,String],...Ge(),...le(),...ve()},setup(e,t){let{slots:a}=t;const{themeClasses:n}=ke(e),{densityClasses:i}=Xe(e);return O(()=>{var o,r;return d(e.tag,{class:["v-table",{"v-table--fixed-height":!!e.height,"v-table--fixed-header":e.fixedHeader,"v-table--fixed-footer":e.fixedFooter,"v-table--has-top":!!a.top,"v-table--has-bottom":!!a.bottom},n.value,i.value]},{default:()=>[(o=a.top)==null?void 0:o.call(a),a.default&&d("div",{class:"v-table__wrapper",style:{height:Q(e.height)}},[d("table",null,[a.default()])]),(r=a.bottom)==null?void 0:r.call(a)]})}),{}}});const Yy=H({name:"VTextarea",directives:{Intersect:co},inheritAttrs:!1,props:{autoGrow:Boolean,autofocus:Boolean,counter:[Boolean,Number,String],counterValue:Function,hint:String,persistentHint:Boolean,prefix:String,placeholder:String,persistentPlaceholder:Boolean,persistentCounter:Boolean,noResize:Boolean,rows:{type:[Number,String],default:5,validator:e=>!isNaN(parseFloat(e))},maxRows:{type:[Number,String],validator:e=>!isNaN(parseFloat(e))},suffix:String,...Xt(),...po()},emits:{"click:clear":e=>!0,"click:control":e=>!0,"update:modelValue":e=>!0},setup(e,t){let{attrs:a,emit:n,slots:i}=t;const o=he(e,"modelValue"),r=g(()=>typeof e.counterValue=="function"?e.counterValue(o.value):(o.value||"").toString().length),s=g(()=>{if(a.maxlength)return a.maxlength;if(!(!e.counter||typeof e.counter!="number"&&typeof e.counter!="string"))return e.counter});function l(x,y){var _,M;!e.autofocus||!x||(_=y[0].target)==null||(M=_.focus)==null||M.call(_)}const c=D(),u=D(),h=D(!1),m=D("auto"),f=D(),p=g(()=>h.value||e.persistentPlaceholder),b=g(()=>e.messages.length?e.messages:p.value||e.persistentHint?e.hint:"");function w(){if(f.value!==document.activeElement){var x;(x=f.value)==null||x.focus()}h.value||(h.value=!0)}function v(x){w(),n("click:control",x)}function S(x){x.stopPropagation(),w(),Ee(()=>{o.value="",n("click:clear",x)})}const k=D();function P(){!e.autoGrow||Ee(()=>{if(!k.value)return;const x=getComputedStyle(k.value),y=parseFloat(x.getPropertyValue("--v-field-padding-top"))+parseFloat(x.getPropertyValue("--v-field-padding-bottom")),_=k.value.scrollHeight,M=parseFloat(x.lineHeight),I=parseFloat(e.rows)*M+y,J=parseFloat(e.maxRows)*M+y||1/0;m.value=Q(Math.min(J,Math.max(I,_!=null?_:0)))})}yt(P),re(o,P),re(()=>e.rows,P),re(()=>e.maxRows,P);let j;return re(k,x=>{if(x)j=new ResizeObserver(P),j.observe(k.value);else{var y;(y=j)==null||y.disconnect()}}),lt(()=>{var x;(x=j)==null||x.disconnect()}),O(()=>{const x=!!(i.counter||e.counter||e.counterValue),[y,_]=Ba(a),[{modelValue:M,...I}]=pa(e),[J]=ms(e);return d(Ft,oe({modelValue:o.value,"onUpdate:modelValue":T=>o.value=T,class:["v-textarea",{"v-textarea--prefixed":e.prefix,"v-textarea--suffixed":e.suffix,"v-textarea--auto-grow":e.autoGrow,"v-textarea--no-resize":e.noResize||e.autoGrow}]},y,I,{messages:b.value}),{...i,default:T=>{let{isDisabled:L,isDirty:B,isReadonly:F,isValid:$}=T;return d(ni,oe({style:{"--v-input-control-height":m.value},"onClick:control":v,"onClick:clear":S,role:"textbox"},J,{active:p.value||B.value,dirty:B.value||e.dirty,focused:h.value,error:$.value===!1}),{...i,default:N=>{let{props:{class:K,...de}}=N;return d(pe,null,[e.prefix&&d("span",{class:"v-text-field__prefix"},[e.prefix]),Me(d("textarea",oe({ref:f,class:K,"onUpdate:modelValue":Z=>o.value=Z,autofocus:e.autofocus,readonly:F.value,disabled:L.value,placeholder:e.placeholder,rows:e.rows,name:e.name,onFocus:w,onBlur:()=>h.value=!1},de,_),null),[[Li,o.value],[ct("intersect"),{handler:l},null,{once:!0}]]),e.autoGrow&&Me(d("textarea",{class:[K,"v-textarea__sizer"],"onUpdate:modelValue":Z=>o.value=Z,ref:k,readonly:!0,"aria-hidden":"true"},null),[[Li,o.value]]),e.suffix&&d("span",{class:"v-text-field__suffix"},[e.suffix])])}})},details:x?()=>d(pe,null,[d("span",null,null),d(go,{active:e.persistentCounter||h.value,value:r.value,max:s.value},i.counter)]):void 0})}),Qt({},c,u,f)}});const Xy=H({name:"VThemeProvider",props:{withBackground:Boolean,...ve(),...le()},setup(e,t){let{slots:a}=t;const{themeClasses:n}=ke(e);return()=>{var i,o;return e.withBackground?d(e.tag,{class:["v-theme-provider",n.value]},{default:()=>[(o=a.default)==null?void 0:o.call(a)]}):(i=a.default)==null?void 0:i.call(a)}}});const Qy=H({name:"VTimeline",props:{align:{type:String,default:"center",validator:e=>["center","start"].includes(e)},direction:{type:String,default:"vertical",validator:e=>["vertical","horizontal"].includes(e)},side:{type:String,validator:e=>e==null||["start","end"].includes(e)},lineInset:{type:[String,Number],default:0},lineThickness:{type:[String,Number],default:2},lineColor:String,truncateLine:{type:String,validator:e=>["start","end","both"].includes(e)},...Ge(),...le(),...ve()},setup(e,t){let{slots:a}=t;const{themeClasses:n}=ke(e),{densityClasses:i}=Xe(e);Ue({VTimelineDivider:{lineColor:z(e,"lineColor")},VTimelineItem:{density:z(e,"density")}});const o=g(()=>{const s=e.side?e.side:e.density!=="default"?"end":null;return s&&`v-timeline--side-${s}`}),r=g(()=>{const s=["v-timeline--truncate-line-start","v-timeline--truncate-line-end"];switch(e.truncateLine){case"both":return s;case"start":return s[0];case"end":return s[1];default:return null}});return O(()=>d(e.tag,{class:["v-timeline",`v-timeline--${e.direction}`,`v-timeline--align-${e.align}`,!e.lineInset&&r.value,{"v-timeline--inset-line":!!e.lineInset},n.value,i.value,o.value],style:{"--v-timeline-line-thickness":Q(e.lineThickness),"--v-timeline-line-inset":Q(e.lineInset)}},a)),{}}}),Zy=H({name:"VTimelineDivider",props:{dotColor:String,fillDot:Boolean,hideDot:Boolean,icon:se,iconColor:String,lineColor:String,...Ie(),...Yt(),...He()},setup(e,t){let{slots:a}=t;const{sizeClasses:n,sizeStyles:i}=ln(e,"v-timeline-divider__dot"),{backgroundColorStyles:o,backgroundColorClasses:r}=Be(z(e,"dotColor")),{roundedClasses:s}=Re(e,"v-timeline-divider__dot"),{elevationClasses:l}=qe(e),{backgroundColorClasses:c,backgroundColorStyles:u}=Be(z(e,"lineColor"));return Ue({VIcon:{color:z(e,"iconColor"),icon:z(e,"icon"),size:z(e,"size")}}),O(()=>{var h,m;return d("div",{class:["v-timeline-divider",{"v-timeline-divider--fill-dot":e.fillDot}]},[!e.hideDot&&d("div",{key:"dot",class:["v-timeline-divider__dot",l.value,s.value,n.value],style:i.value},[d("div",{class:["v-timeline-divider__inner-dot",r.value,s.value],style:o.value},[((h=(m=a.default)==null?void 0:m.call(a))!=null?h:e.icon)?d(Te,null,null):void 0])]),d("div",{class:["v-timeline-divider__line",c.value],style:u.value},null)])}),{}}}),e0=H({name:"VTimelineItem",props:{density:String,dotColor:String,fillDot:Boolean,hideDot:Boolean,hideOpposite:{type:Boolean,default:void 0},icon:se,iconColor:String,...Ie(),...He(),...Yt(),...le(),...wt()},setup(e,t){let{slots:a}=t;const{dimensionStyles:n}=kt(e),i=D(0),o=D();return re(o,r=>{var s,l;!r||(i.value=(s=(l=r.$el.querySelector(".v-timeline-divider__dot"))==null?void 0:l.getBoundingClientRect().width)!=null?s:0)},{flush:"post"}),O(()=>{var r,s;return d("div",{class:["v-timeline-item",{"v-timeline-item--fill-dot":e.fillDot}],style:{"--v-timeline-dot-size":Q(i.value)}},[d("div",{class:"v-timeline-item__body",style:n.value},[(r=a.default)==null?void 0:r.call(a)]),d(Zy,{ref:o,hideDot:e.hideDot,icon:e.icon,iconColor:e.iconColor,size:e.size,elevation:e.elevation,dotColor:e.dotColor,fillDot:e.fillDot,rounded:e.rounded},{default:a.icon}),e.density!=="compact"&&d("div",{class:"v-timeline-item__opposite"},[!e.hideOpposite&&((s=a.opposite)==null?void 0:s.call(a))])])}),{}}});const t0=Fe()({name:"VTooltip",inheritAttrs:!1,props:{id:String,modelValue:Boolean,text:String,location:{type:String,default:"end"},origin:{type:String,default:"auto"},...dt({transition:!1})},emits:{"update:modelValue":e=>!0},setup(e,t){let{attrs:a,slots:n}=t;const i=he(e,"modelValue"),{scopeId:o}=ko(),r=Ye(),s=g(()=>e.id||`v-tooltip-${r}`),l=g(()=>e.location.split(" ").length>1?e.location:e.location+" center"),c=g(()=>e.origin==="auto"||e.origin==="overlap"||e.origin.split(" ").length>1||e.location.split(" ").length>1?e.origin:e.origin+" center"),u=g(()=>e.transition?e.transition:i.value?"scale-transition":"fade-transition");return O(()=>d(si,oe({modelValue:i.value,"onUpdate:modelValue":h=>i.value=h,class:["v-tooltip"],id:s.value,transition:u.value,absolute:!0,locationStrategy:"connected",scrollStrategy:"reposition",location:l.value,origin:c.value,"min-width":0,offset:10,scrim:!1,persistent:!0,"open-on-click":!1,"open-on-hover":!0,"close-on-back":!1,role:"tooltip",eager:!0,activatorProps:{"aria-describedby":s.value}},o,a),{activator:n.activator,default:function(){for(var h,m,f=arguments.length,p=new Array(f),b=0;b<f;b++)p[b]=arguments[b];return(h=(m=n.default)==null?void 0:m.call(n,...p))!=null?h:e.text}})),{}}}),a0=H({name:"VValidation",props:{...kd()},emits:{"update:modelValue":e=>!0},setup(e,t){let{slots:a}=t;const n=xd(e,"validation");return()=>{var i;return(i=a.default)==null?void 0:i.call(a,n)}}}),n0=Object.freeze(Object.defineProperty({__proto__:null,VApp:Fu,VAppBar:vv,VAppBarNavIcon:xv,VAppBarTitle:Sv,VAlert:Tv,VAlertTitle:Td,VAutocomplete:fb,VAvatar:Ja,VBadge:pb,VBanner:gb,VBannerActions:ih,VBannerText:oh,VBottomNavigation:vb,VBreadcrumbs:bb,VBreadcrumbsItem:sh,VBreadcrumbsDivider:rh,VBtn:rt,VBtnGroup:Sd,VBtnToggle:wv,VCard:nd,VCardActions:Ru,VCardItem:Uu,VCardSubtitle:Nu,VCardText:Wu,VCardTitle:$u,VCarousel:Tb,VCarouselItem:jb,VCheckbox:Iv,VCheckboxBtn:vn,VChip:ri,VChipGroup:Av,VCode:Pb,VColorPicker:sy,VCombobox:cy,VCounter:go,VDefaultsProvider:Le,VDialog:uy,VDivider:Jd,VExpansionPanels:hy,VExpansionPanel:my,VExpansionPanelText:vh,VExpansionPanelTitle:gh,VField:ni,VFieldLabel:Tn,VFileInput:fy,VFooter:py,VForm:gy,VContainer:ur,VCol:dr,VRow:hr,VSpacer:Vg,VHover:vy,VIcon:Te,VComponentIcon:Au,VSvgIcon:Mu,VLigatureIcon:qp,VClassIcon:Zr,VImg:cn,VInput:Ft,VItemGroup:by,VItem:yy,VKbd:wy,VLabel:fo,VLayout:ky,VLayoutItem:xy,VLazy:Cy,VList:yo,VListGroup:Vd,VListImg:Ov,VListItem:Nt,VListItemAction:Gv,VListItemAvatar:vr,VListItemHeader:zd,VListItemIcon:br,VListItemMedia:Nv,VListItemSubtitle:Hd,VListItemTitle:Od,VListSubheader:Gd,VLocaleProvider:Sy,VMain:_y,VMenu:xo,VMessages:yd,VNavigationDrawer:My,VNoSsr:Ly,VOverlay:si,VPagination:Ey,VParallax:Fy,VProgressCircular:ps,VProgressLinear:as,VRadio:Ry,VRadioGroup:Vy,VRangeSlider:zy,VRating:Hy,VResponsive:zu,VSelect:ub,VSelectionControl:oi,VSelectionControlGroup:Pd,VSheet:fh,VSlideGroup:wh,VSlideGroupItem:Gy,VSlider:Hi,VSnackbar:Ny,VSwitch:$y,VSystemBar:Uy,VTabs:qy,VTab:xh,VTable:Ky,VTextarea:Yy,VTextField:ii,VThemeProvider:Xy,VTimeline:Qy,VTimelineItem:e0,VToolbar:Gi,VToolbarTitle:Oi,VToolbarItems:Cv,VTooltip:t0,VValidation:a0,VWindow:uh,VWindowItem:dh,VDialogTransition:ho,VCarouselTransition:zg,VCarouselReverseTransition:Hg,VTabTransition:Og,VTabReverseTransition:Gg,VMenuTransition:Ng,VFabTransition:$g,VDialogBottomTransition:Ug,VDialogTopTransition:Wg,VFadeTransition:mr,VScaleTransition:pd,VScrollXTransition:qg,VScrollXReverseTransition:Kg,VScrollYTransition:Yg,VScrollYReverseTransition:Xg,VSlideXTransition:Qg,VSlideXReverseTransition:Zg,VSlideYTransition:ls,VSlideYReverseTransition:ev,VExpandTransition:mo,VExpandXTransition:cs},Symbol.toStringTag,{value:"Module"}));function i0(e,t){var a,n,i,o;const r=t.modifiers||{},s=t.value,{once:l,immediate:c,...u}=r,h=!Object.keys(u).length,{handler:m,options:f}=typeof s=="object"?s:{handler:s,options:{attributes:(a=u==null?void 0:u.attr)!=null?a:h,characterData:(n=u==null?void 0:u.char)!=null?n:h,childList:(i=u==null?void 0:u.child)!=null?i:h,subtree:(o=u==null?void 0:u.sub)!=null?o:h}},p=new MutationObserver(function(){let b=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[],w=arguments.length>1?arguments[1]:void 0;m==null||m(b,w),l&&Ch(e,t)});c&&(m==null||m([],p)),e._mutate=Object(e._mutate),e._mutate[t.instance.$.uid]={observer:p},p.observe(e,f)}function Ch(e,t){var a;!((a=e._mutate)!=null&&a[t.instance.$.uid])||(e._mutate[t.instance.$.uid].observer.disconnect(),delete e._mutate[t.instance.$.uid])}const o0={mounted:i0,unmounted:Ch};function r0(e,t){var a,n;const i=t.value,o={passive:!((a=t.modifiers)!=null&&a.active)};window.addEventListener("resize",i,o),e._onResize=Object(e._onResize),e._onResize[t.instance.$.uid]={handler:i,options:o},(n=t.modifiers)!=null&&n.quiet||i()}function s0(e,t){var a;if(!((a=e._onResize)!=null&&a[t.instance.$.uid]))return;const{handler:n,options:i}=e._onResize[t.instance.$.uid];window.removeEventListener("resize",n,i),delete e._onResize[t.instance.$.uid]}const l0={mounted:r0,unmounted:s0};function Sh(e,t){var a;const{self:n=!1}=(a=t.modifiers)!=null?a:{},i=t.value,o=typeof i=="object"&&i.options||{passive:!0},r=typeof i=="function"||"handleEvent"in i?i:i.handler,s=n?e:t.arg?document.querySelector(t.arg):window;!s||(s.addEventListener("scroll",r,o),e._onScroll=Object(e._onScroll),e._onScroll[t.instance.$.uid]={handler:r,options:o,target:n?void 0:s})}function _h(e,t){var a;if(!((a=e._onScroll)!=null&&a[t.instance.$.uid]))return;const{handler:n,options:i,target:o=e}=e._onScroll[t.instance.$.uid];o.removeEventListener("scroll",n,i),delete e._onScroll[t.instance.$.uid]}function c0(e,t){t.value!==t.oldValue&&(_h(e,t),Sh(e,t))}const u0={mounted:Sh,unmounted:_h,updated:c0},d0=Object.freeze(Object.defineProperty({__proto__:null,ClickOutside:th,Intersect:Ou,Mutate:o0,Resize:l0,Ripple:fa,Scroll:u0,Touch:ws},Symbol.toStringTag,{value:"Module"}));fv();const h0=lp(uv),m0=wg({components:n0,directives:d0});h0.use(m0).mount("#app");
